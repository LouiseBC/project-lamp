// Generated by psc-bundle 0.10.5
var PS = {};
(function(exports) {
    "use strict";

  exports.arrayMap = function (f) {
    return function (arr) {
      var l = arr.length;
      var result = new Array(l);
      for (var i = 0; i < l; i++) {
        result[i] = f(arr[i]);
      }
      return result;
    };
  };
})(PS["Data.Functor"] = PS["Data.Functor"] || {});
(function(exports) {
    "use strict";

  /**
 *  | A `Semigroupoid` is similar to a [`Category`](#category) but does not
 *  | require an identity element `id`, just composable morphisms.
 *  |
 *  | `Semigroupoid`s must satisfy the following law:
 *  |
 *  | - Associativity: `p <<< (q <<< r) = (p <<< q) <<< r`
 *  |
 *  | One example of a `Semigroupoid` is the function type constructor `(->)`,
 *  | with `(<<<)` defined as function composition.
 */  
  var Semigroupoid = function (compose) {
      this.compose = compose;
  };
  var semigroupoidFn = new Semigroupoid(function (f) {
      return function (g) {
          return function (x) {
              return f(g(x));
          };
      };
  });

  /**
 *  | A `Semigroupoid` is similar to a [`Category`](#category) but does not
 *  | require an identity element `id`, just composable morphisms.
 *  |
 *  | `Semigroupoid`s must satisfy the following law:
 *  |
 *  | - Associativity: `p <<< (q <<< r) = (p <<< q) <<< r`
 *  |
 *  | One example of a `Semigroupoid` is the function type constructor `(->)`,
 *  | with `(<<<)` defined as function composition.
 */  
  var compose = function (dict) {
      return dict.compose;
  };

  /**
 *  | Forwards composition, or `compose` with its arguments reversed.
 */  
  var composeFlipped = function (dictSemigroupoid) {
      return function (f) {
          return function (g) {
              return compose(dictSemigroupoid)(g)(f);
          };
      };
  };
  exports["Semigroupoid"] = Semigroupoid;
  exports["compose"] = compose;
  exports["composeFlipped"] = composeFlipped;
  exports["semigroupoidFn"] = semigroupoidFn;
})(PS["Control.Semigroupoid"] = PS["Control.Semigroupoid"] || {});
(function(exports) {
    "use strict";
  var Control_Semigroupoid = PS["Control.Semigroupoid"];        

  /**
 *  | `Category`s consist of objects and composable morphisms between them, and
 *  | as such are [`Semigroupoids`](#semigroupoid), but unlike `semigroupoids`
 *  | must have an identity element.
 *  |
 *  | Instances must satisfy the following law in addition to the
 *  | `Semigroupoid` law:
 *  |
 *  | - Identity: `id <<< p = p <<< id = p`
 */  
  var Category = function (__superclass_Control$dotSemigroupoid$dotSemigroupoid_0, id) {
      this["__superclass_Control.Semigroupoid.Semigroupoid_0"] = __superclass_Control$dotSemigroupoid$dotSemigroupoid_0;
      this.id = id;
  };

  /**
 *  | `Category`s consist of objects and composable morphisms between them, and
 *  | as such are [`Semigroupoids`](#semigroupoid), but unlike `semigroupoids`
 *  | must have an identity element.
 *  |
 *  | Instances must satisfy the following law in addition to the
 *  | `Semigroupoid` law:
 *  |
 *  | - Identity: `id <<< p = p <<< id = p`
 */  
  var id = function (dict) {
      return dict.id;
  };
  var categoryFn = new Category(function () {
      return Control_Semigroupoid.semigroupoidFn;
  }, function (x) {
      return x;
  });
  exports["Category"] = Category;
  exports["id"] = id;
  exports["categoryFn"] = categoryFn;
})(PS["Control.Category"] = PS["Control.Category"] || {});
(function(exports) {
    "use strict";
  var Control_Category = PS["Control.Category"];        

  /**
 *  | The `on` function is used to change the domain of a binary operator.
 *  |
 *  | For example, we can create a function which compares two records based on the values of their `x` properties:
 *  |
 *  | ```purescript
 *  | compareX :: forall r. { x :: Number | r } -> { x :: Number | r } -> Ordering
 *  | compareX = compare `on` _.x
 *  | ```
 */  
  var on = function (f) {
      return function (g) {
          return function (x) {
              return function (y) {
                  return f(g(x))(g(y));
              };
          };
      };
  };

  /**
 *  | Flips the order of the arguments to a function of two arguments.
 *  |
 *  | ```purescript
 *  | flip const 1 2 = const 2 1 = 2
 *  | ```
 */  
  var flip = function (f) {
      return function (b) {
          return function (a) {
              return f(a)(b);
          };
      };
  };

  /**
 *  | Returns its first argument and ignores its second.
 *  |
 *  | ```purescript
 *  | const 1 "hello" = 1
 *  | ```
 */  
  var $$const = function (a) {
      return function (v) {
          return a;
      };
  };

  /**
 *  | Applies an argument to a function. This is primarily used as the `(#)`
 *  | operator, which allows parentheses to be ommitted in some cases, or as a
 *  | natural way to apply a value to a chain of composed functions.
 */  
  var applyFlipped = function (x) {
      return function (f) {
          return f(x);
      };
  };

  /**
 *  | Applies a function to an argument. This is primarily used as the operator
 *  | `($)` which allows parentheses to be omitted in some cases, or as a
 *  | natural way to apply a chain of composed functions to a value.
 */  
  var apply = function (f) {
      return function (x) {
          return f(x);
      };
  };
  exports["apply"] = apply;
  exports["applyFlipped"] = applyFlipped;
  exports["const"] = $$const;
  exports["flip"] = flip;
  exports["on"] = on;
})(PS["Data.Function"] = PS["Data.Function"] || {});
(function(exports) {
    "use strict";

  exports.unit = {};
})(PS["Data.Unit"] = PS["Data.Unit"] || {});
(function(exports) {
    "use strict";

  exports.showIntImpl = function (n) {
    return n.toString();
  };

  exports.showNumberImpl = function (n) {
    var str = n.toString();
    return isNaN(str + ".0") ? str : str + ".0";
  };

  exports.showCharImpl = function (c) {
    var code = c.charCodeAt(0);
    if (code < 0x20 || code === 0x7F) {
      switch (c) {
        case "\x07": return "'\\a'";
        case "\b": return "'\\b'";
        case "\f": return "'\\f'";
        case "\n": return "'\\n'";
        case "\r": return "'\\r'";
        case "\t": return "'\\t'";
        case "\v": return "'\\v'";
      }
      return "'\\" + code.toString(10) + "'";
    }
    return c === "'" || c === "\\" ? "'\\" + c + "'" : "'" + c + "'";
  };

  exports.showStringImpl = function (s) {
    var l = s.length;
    return "\"" + s.replace(
      /[\0-\x1F\x7F"\\]/g,
      function (c, i) { // jshint ignore:line
        switch (c) {
          case "\"":
          case "\\":
            return "\\" + c;
          case "\x07": return "\\a";
          case "\b": return "\\b";
          case "\f": return "\\f";
          case "\n": return "\\n";
          case "\r": return "\\r";
          case "\t": return "\\t";
          case "\v": return "\\v";
        }
        var k = i + 1;
        var empty = k < l && s[k] >= "0" && s[k] <= "9" ? "\\&" : "";
        return "\\" + c.charCodeAt(0).toString(10) + empty;
      }
    ) + "\"";
  };

  exports.showArrayImpl = function (f) {
    return function (xs) {
      var ss = [];
      for (var i = 0, l = xs.length; i < l; i++) {
        ss[i] = f(xs[i]);
      }
      return "[" + ss.join(",") + "]";
    };
  };
})(PS["Data.Show"] = PS["Data.Show"] || {});
(function(exports) {
    "use strict";
  var $foreign = PS["Data.Show"];     

  /**
 *  | The `Show` type class represents those types which can be converted into
 *  | a human-readable `String` representation.
 *  |
 *  | While not required, it is recommended that for any expression `x`, the
 *  | string `show x` be executable PureScript code which evaluates to the same
 *  | value as the expression `x`.
 */  
  var Show = function (show) {
      this.show = show;
  };
  var showString = new Show($foreign.showStringImpl);
  var showNumber = new Show($foreign.showNumberImpl);
  var showInt = new Show($foreign.showIntImpl);
  var showChar = new Show($foreign.showCharImpl);
  var showBoolean = new Show(function (v) {
      if (v) {
          return "true";
      };
      if (!v) {
          return "false";
      };
      throw new Error("Failed pattern match at Data.Show line 13, column 3 - line 14, column 3: " + [ v.constructor.name ]);
  });

  /**
 *  | The `Show` type class represents those types which can be converted into
 *  | a human-readable `String` representation.
 *  |
 *  | While not required, it is recommended that for any expression `x`, the
 *  | string `show x` be executable PureScript code which evaluates to the same
 *  | value as the expression `x`.
 */  
  var show = function (dict) {
      return dict.show;
  };
  var showArray = function (dictShow) {
      return new Show($foreign.showArrayImpl(show(dictShow)));
  };
  exports["Show"] = Show;
  exports["show"] = show;
  exports["showBoolean"] = showBoolean;
  exports["showInt"] = showInt;
  exports["showNumber"] = showNumber;
  exports["showChar"] = showChar;
  exports["showString"] = showString;
  exports["showArray"] = showArray;
})(PS["Data.Show"] = PS["Data.Show"] || {});
(function(exports) {
    "use strict";
  var $foreign = PS["Data.Unit"];
  var Data_Show = PS["Data.Show"];        
  var showUnit = new Data_Show.Show(function (v) {
      return "unit";
  });
  exports["showUnit"] = showUnit;
  exports["unit"] = $foreign.unit;
})(PS["Data.Unit"] = PS["Data.Unit"] || {});
(function(exports) {
    "use strict";
  var $foreign = PS["Data.Functor"];
  var Data_Function = PS["Data.Function"];
  var Data_Unit = PS["Data.Unit"];
  var Control_Semigroupoid = PS["Control.Semigroupoid"];        

  /**
 *  | A `Functor` is a type constructor which supports a mapping operation
 *  | `(<$>)`.
 *  |
 *  | `(<$>)` can be used to turn functions `a -> b` into functions
 *  | `f a -> f b` whose argument and return types use the type constructor `f`
 *  | to represent some computational context.
 *  |
 *  | Instances must satisfy the following laws:
 *  |
 *  | - Identity: `(<$>) id = id`
 *  | - Composition: `(<$>) (f <<< g) = (f <$>) <<< (g <$>)`
 */  
  var Functor = function (map) {
      this.map = map;
  };

  /**
 *  | A `Functor` is a type constructor which supports a mapping operation
 *  | `(<$>)`.
 *  |
 *  | `(<$>)` can be used to turn functions `a -> b` into functions
 *  | `f a -> f b` whose argument and return types use the type constructor `f`
 *  | to represent some computational context.
 *  |
 *  | Instances must satisfy the following laws:
 *  |
 *  | - Identity: `(<$>) id = id`
 *  | - Composition: `(<$>) (f <<< g) = (f <$>) <<< (g <$>)`
 */  
  var map = function (dict) {
      return dict.map;
  };

  /**
 *  | `mapFlipped` is `map` with its arguments reversed. For example:
 *  |
 *  | ```purescript
 *  | [1, 2, 3] <#> \n -> n * n
 *  | ```
 */  
  var mapFlipped = function (dictFunctor) {
      return function (fa) {
          return function (f) {
              return map(dictFunctor)(f)(fa);
          };
      };
  };

  /**
 *  | The `void` function is used to ignore the type wrapped by a
 *  | [`Functor`](#functor), replacing it with `Unit` and keeping only the type
 *  | information provided by the type constructor itself.
 *  |
 *  | `void` is often useful when using `do` notation to change the return type
 *  | of a monadic computation:
 *  |
 *  | ```purescript
 *  | main = forE 1 10 \n -> void do
 *  |   print n
 *  |   print (n * n)
 *  | ```
 */  
  var $$void = function (dictFunctor) {
      return map(dictFunctor)(Data_Function["const"](Data_Unit.unit));
  };

  /**
 *  | A version of `voidLast` with its arguments flipped.
 */  
  var voidLeft = function (dictFunctor) {
      return function (f) {
          return function (x) {
              return map(dictFunctor)(Data_Function["const"](x))(f);
          };
      };
  };

  /**
 *  | Ignore the return value of a computation, using the specified return value
 *  | instead.
 */  
  var voidRight = function (dictFunctor) {
      return function (x) {
          return map(dictFunctor)(Data_Function["const"](x));
      };
  };
  var functorFn = new Functor(Control_Semigroupoid.compose(Control_Semigroupoid.semigroupoidFn));
  var functorArray = new Functor($foreign.arrayMap);

  /**
 *  | Apply a value in a computational context to a value in no context.
 *  |
 *  | Generalizes `flip`.
 *  |
 *  | ```purescript
 *  | longEnough :: String -> Bool
 *  | hasSymbol :: String -> Bool
 *  | hasDigit :: String -> Bool
 *  | password :: String
 *  |
 *  | validate :: String -> List Bool
 *  | validate = flap [longEnough, hasSymbol, hasDigit]
 *  | ```
 *  |
 *  | ```purescript
 *  | flap (-) 3 4 == 1
 *  | threeve <$> Just 1 <@> 'a' <*> Just true == Just (threeve 1 'a' true)
 *  | ```
 */  
  var flap = function (dictFunctor) {
      return function (ff) {
          return function (x) {
              return map(dictFunctor)(function (f) {
                  return f(x);
              })(ff);
          };
      };
  };
  exports["Functor"] = Functor;
  exports["flap"] = flap;
  exports["map"] = map;
  exports["mapFlipped"] = mapFlipped;
  exports["void"] = $$void;
  exports["voidLeft"] = voidLeft;
  exports["voidRight"] = voidRight;
  exports["functorFn"] = functorFn;
  exports["functorArray"] = functorArray;
})(PS["Data.Functor"] = PS["Data.Functor"] || {});
(function(exports) {
    "use strict";

  exports.concatString = function (s1) {
    return function (s2) {
      return s1 + s2;
    };
  };

  exports.concatArray = function (xs) {
    return function (ys) {
      if (xs.length === 0) return ys;
      if (ys.length === 0) return xs;
      return xs.concat(ys);
    };
  };
})(PS["Data.Semigroup"] = PS["Data.Semigroup"] || {});
(function(exports) {
    "use strict";
  var Data_Show = PS["Data.Show"];        
  var Void = function (x) {
      return x;
  };
  var absurd = function (a) {
      var spin = function (__copy_v) {
          var v = __copy_v;
          tco: while (true) {
              var __tco_v = v;
              v = __tco_v;
              continue tco;
          };
      };
      return spin(a);
  };
  var showVoid = new Data_Show.Show(absurd);
  exports["absurd"] = absurd;
  exports["showVoid"] = showVoid;
})(PS["Data.Void"] = PS["Data.Void"] || {});
(function(exports) {
    "use strict";
  var $foreign = PS["Data.Semigroup"];
  var Data_Unit = PS["Data.Unit"];
  var Data_Void = PS["Data.Void"];        

  /**
 *  | The `Semigroup` type class identifies an associative operation on a type.
 *  |
 *  | Instances are required to satisfy the following law:
 *  |
 *  | - Associativity: `(x <> y) <> z = x <> (y <> z)`
 *  |
 *  | One example of a `Semigroup` is `String`, with `(<>)` defined as string
 *  | concatenation.
 */  
  var Semigroup = function (append) {
      this.append = append;
  };
  var semigroupVoid = new Semigroup(function (v) {
      return Data_Void.absurd;
  });
  var semigroupUnit = new Semigroup(function (v) {
      return function (v1) {
          return Data_Unit.unit;
      };
  });
  var semigroupString = new Semigroup($foreign.concatString);
  var semigroupArray = new Semigroup($foreign.concatArray);

  /**
 *  | The `Semigroup` type class identifies an associative operation on a type.
 *  |
 *  | Instances are required to satisfy the following law:
 *  |
 *  | - Associativity: `(x <> y) <> z = x <> (y <> z)`
 *  |
 *  | One example of a `Semigroup` is `String`, with `(<>)` defined as string
 *  | concatenation.
 */  
  var append = function (dict) {
      return dict.append;
  };
  var semigroupFn = function (dictSemigroup) {
      return new Semigroup(function (f) {
          return function (g) {
              return function (x) {
                  return append(dictSemigroup)(f(x))(g(x));
              };
          };
      });
  };
  exports["Semigroup"] = Semigroup;
  exports["append"] = append;
  exports["semigroupString"] = semigroupString;
  exports["semigroupUnit"] = semigroupUnit;
  exports["semigroupVoid"] = semigroupVoid;
  exports["semigroupFn"] = semigroupFn;
  exports["semigroupArray"] = semigroupArray;
})(PS["Data.Semigroup"] = PS["Data.Semigroup"] || {});
(function(exports) {
    "use strict";
  var Data_Functor = PS["Data.Functor"];
  var Data_Semigroup = PS["Data.Semigroup"];        

  /**
 *  | The `Alt` type class identifies an associative operation on a type
 *  | constructor.  It is similar to `Semigroup`, except that it applies to
 *  | types of kind `* -> *`, like `Array` or `List`, rather than concrete types
 *  | `String` or `Number`.
 *  |
 *  | `Alt` instances are required to satisfy the following laws:
 *  |
 *  | - Associativity: `(x <|> y) <|> z == x <|> (y <|> z)`
 *  | - Distributivity: `f <$> (x <|> y) == (f <$> x) <|> (f <$> y)`
 *  |
 *  | For example, the `Array` (`[]`) type is an instance of `Alt`, where
 *  | `(<|>)` is defined to be concatenation.
 */  
  var Alt = function (__superclass_Data$dotFunctor$dotFunctor_0, alt) {
      this["__superclass_Data.Functor.Functor_0"] = __superclass_Data$dotFunctor$dotFunctor_0;
      this.alt = alt;
  };
  var altArray = new Alt(function () {
      return Data_Functor.functorArray;
  }, Data_Semigroup.append(Data_Semigroup.semigroupArray));

  /**
 *  | The `Alt` type class identifies an associative operation on a type
 *  | constructor.  It is similar to `Semigroup`, except that it applies to
 *  | types of kind `* -> *`, like `Array` or `List`, rather than concrete types
 *  | `String` or `Number`.
 *  |
 *  | `Alt` instances are required to satisfy the following laws:
 *  |
 *  | - Associativity: `(x <|> y) <|> z == x <|> (y <|> z)`
 *  | - Distributivity: `f <$> (x <|> y) == (f <$> x) <|> (f <$> y)`
 *  |
 *  | For example, the `Array` (`[]`) type is an instance of `Alt`, where
 *  | `(<|>)` is defined to be concatenation.
 */  
  var alt = function (dict) {
      return dict.alt;
  };
  exports["Alt"] = Alt;
  exports["alt"] = alt;
  exports["altArray"] = altArray;
})(PS["Control.Alt"] = PS["Control.Alt"] || {});
(function(exports) {
    "use strict";

  exports.arrayApply = function (fs) {
    return function (xs) {
      var result = [];
      var n = 0;
      for (var i = 0, l = fs.length; i < l; i++) {
        for (var j = 0, k = xs.length; j < k; j++) {
          result[n++] = fs[i](xs[j]);
        }
      }
      return result;
    };
  };
})(PS["Control.Apply"] = PS["Control.Apply"] || {});
(function(exports) {
    "use strict";
  var $foreign = PS["Control.Apply"];
  var Data_Functor = PS["Data.Functor"];
  var Data_Function = PS["Data.Function"];
  var Control_Category = PS["Control.Category"];        

  /**
 *  | The `Apply` class provides the `(<*>)` which is used to apply a function
 *  | to an argument under a type constructor.
 *  |
 *  | `Apply` can be used to lift functions of two or more arguments to work on
 *  | values wrapped with the type constructor `f`. It might also be understood
 *  | in terms of the `lift2` function:
 *  |
 *  | ```purescript
 *  | lift2 :: forall f a b c. Apply f => (a -> b -> c) -> f a -> f b -> f c
 *  | lift2 f a b = f <$> a <*> b
 *  | ```
 *  |
 *  | `(<*>)` is recovered from `lift2` as `lift2 ($)`. That is, `(<*>)` lifts
 *  | the function application operator `($)` to arguments wrapped with the
 *  | type constructor `f`.
 *  |
 *  | Instances must satisfy the following law in addition to the `Functor`
 *  | laws:
 *  |
 *  | - Associative composition: `(<<<) <$> f <*> g <*> h = f <*> (g <*> h)`
 *  |
 *  | Formally, `Apply` represents a strong lax semi-monoidal endofunctor.
 */  
  var Apply = function (__superclass_Data$dotFunctor$dotFunctor_0, apply) {
      this["__superclass_Data.Functor.Functor_0"] = __superclass_Data$dotFunctor$dotFunctor_0;
      this.apply = apply;
  };
  var applyFn = new Apply(function () {
      return Data_Functor.functorFn;
  }, function (f) {
      return function (g) {
          return function (x) {
              return f(x)(g(x));
          };
      };
  });
  var applyArray = new Apply(function () {
      return Data_Functor.functorArray;
  }, $foreign.arrayApply);

  /**
 *  | The `Apply` class provides the `(<*>)` which is used to apply a function
 *  | to an argument under a type constructor.
 *  |
 *  | `Apply` can be used to lift functions of two or more arguments to work on
 *  | values wrapped with the type constructor `f`. It might also be understood
 *  | in terms of the `lift2` function:
 *  |
 *  | ```purescript
 *  | lift2 :: forall f a b c. Apply f => (a -> b -> c) -> f a -> f b -> f c
 *  | lift2 f a b = f <$> a <*> b
 *  | ```
 *  |
 *  | `(<*>)` is recovered from `lift2` as `lift2 ($)`. That is, `(<*>)` lifts
 *  | the function application operator `($)` to arguments wrapped with the
 *  | type constructor `f`.
 *  |
 *  | Instances must satisfy the following law in addition to the `Functor`
 *  | laws:
 *  |
 *  | - Associative composition: `(<<<) <$> f <*> g <*> h = f <*> (g <*> h)`
 *  |
 *  | Formally, `Apply` represents a strong lax semi-monoidal endofunctor.
 */  
  var apply = function (dict) {
      return dict.apply;
  };

  /**
 *  | Combine two effectful actions, keeping only the result of the first.
 */  
  var applyFirst = function (dictApply) {
      return function (a) {
          return function (b) {
              return apply(dictApply)(Data_Functor.map(dictApply["__superclass_Data.Functor.Functor_0"]())(Data_Function["const"])(a))(b);
          };
      };
  };

  /**
 *  | Combine two effectful actions, keeping only the result of the second.
 */  
  var applySecond = function (dictApply) {
      return function (a) {
          return function (b) {
              return apply(dictApply)(Data_Functor.map(dictApply["__superclass_Data.Functor.Functor_0"]())(Data_Function["const"](Control_Category.id(Control_Category.categoryFn)))(a))(b);
          };
      };
  };

  /**
 *  | Lift a function of two arguments to a function which accepts and returns
 *  | values wrapped with the type constructor `f`.
 */  
  var lift2 = function (dictApply) {
      return function (f) {
          return function (a) {
              return function (b) {
                  return apply(dictApply)(Data_Functor.map(dictApply["__superclass_Data.Functor.Functor_0"]())(f)(a))(b);
              };
          };
      };
  };

  /**
 *  | Lift a function of three arguments to a function which accepts and returns
 *  | values wrapped with the type constructor `f`.
 */  
  var lift3 = function (dictApply) {
      return function (f) {
          return function (a) {
              return function (b) {
                  return function (c) {
                      return apply(dictApply)(apply(dictApply)(Data_Functor.map(dictApply["__superclass_Data.Functor.Functor_0"]())(f)(a))(b))(c);
                  };
              };
          };
      };
  };

  /**
 *  | Lift a function of four arguments to a function which accepts and returns
 *  | values wrapped with the type constructor `f`.
 */  
  var lift4 = function (dictApply) {
      return function (f) {
          return function (a) {
              return function (b) {
                  return function (c) {
                      return function (d) {
                          return apply(dictApply)(apply(dictApply)(apply(dictApply)(Data_Functor.map(dictApply["__superclass_Data.Functor.Functor_0"]())(f)(a))(b))(c))(d);
                      };
                  };
              };
          };
      };
  };

  /**
 *  | Lift a function of five arguments to a function which accepts and returns
 *  | values wrapped with the type constructor `f`.
 */  
  var lift5 = function (dictApply) {
      return function (f) {
          return function (a) {
              return function (b) {
                  return function (c) {
                      return function (d) {
                          return function (e) {
                              return apply(dictApply)(apply(dictApply)(apply(dictApply)(apply(dictApply)(Data_Functor.map(dictApply["__superclass_Data.Functor.Functor_0"]())(f)(a))(b))(c))(d))(e);
                          };
                      };
                  };
              };
          };
      };
  };
  exports["Apply"] = Apply;
  exports["apply"] = apply;
  exports["applyFirst"] = applyFirst;
  exports["applySecond"] = applySecond;
  exports["lift2"] = lift2;
  exports["lift3"] = lift3;
  exports["lift4"] = lift4;
  exports["lift5"] = lift5;
  exports["applyFn"] = applyFn;
  exports["applyArray"] = applyArray;
})(PS["Control.Apply"] = PS["Control.Apply"] || {});
(function(exports) {
    "use strict";
  var Control_Apply = PS["Control.Apply"];
  var Data_Functor = PS["Data.Functor"];
  var Data_Unit = PS["Data.Unit"];        

  /**
 *  | The `Applicative` type class extends the [`Apply`](#apply) type class
 *  | with a `pure` function, which can be used to create values of type `f a`
 *  | from values of type `a`.
 *  |
 *  | Where [`Apply`](#apply) provides the ability to lift functions of two or
 *  | more arguments to functions whose arguments are wrapped using `f`, and
 *  | [`Functor`](#functor) provides the ability to lift functions of one
 *  | argument, `pure` can be seen as the function which lifts functions of
 *  | _zero_ arguments. That is, `Applicative` functors support a lifting
 *  | operation for any number of function arguments.
 *  |
 *  | Instances must satisfy the following laws in addition to the `Apply`
 *  | laws:
 *  |
 *  | - Identity: `(pure id) <*> v = v`
 *  | - Composition: `(pure <<<) <*> f <*> g <*> h = f <*> (g <*> h)`
 *  | - Homomorphism: `(pure f) <*> (pure x) = pure (f x)`
 *  | - Interchange: `u <*> (pure y) = (pure ($ y)) <*> u`
 */  
  var Applicative = function (__superclass_Control$dotApply$dotApply_0, pure) {
      this["__superclass_Control.Apply.Apply_0"] = __superclass_Control$dotApply$dotApply_0;
      this.pure = pure;
  };

  /**
 *  | The `Applicative` type class extends the [`Apply`](#apply) type class
 *  | with a `pure` function, which can be used to create values of type `f a`
 *  | from values of type `a`.
 *  |
 *  | Where [`Apply`](#apply) provides the ability to lift functions of two or
 *  | more arguments to functions whose arguments are wrapped using `f`, and
 *  | [`Functor`](#functor) provides the ability to lift functions of one
 *  | argument, `pure` can be seen as the function which lifts functions of
 *  | _zero_ arguments. That is, `Applicative` functors support a lifting
 *  | operation for any number of function arguments.
 *  |
 *  | Instances must satisfy the following laws in addition to the `Apply`
 *  | laws:
 *  |
 *  | - Identity: `(pure id) <*> v = v`
 *  | - Composition: `(pure <<<) <*> f <*> g <*> h = f <*> (g <*> h)`
 *  | - Homomorphism: `(pure f) <*> (pure x) = pure (f x)`
 *  | - Interchange: `u <*> (pure y) = (pure ($ y)) <*> u`
 */  
  var pure = function (dict) {
      return dict.pure;
  };

  /**
 *  | Perform a applicative action unless a condition is true.
 */  
  var unless = function (dictApplicative) {
      return function (v) {
          return function (v1) {
              if (!v) {
                  return v1;
              };
              if (v) {
                  return pure(dictApplicative)(Data_Unit.unit);
              };
              throw new Error("Failed pattern match at Control.Applicative line 63, column 1 - line 63, column 19: " + [ v.constructor.name, v1.constructor.name ]);
          };
      };
  };

  /**
 *  | Perform a applicative action when a condition is true.
 */  
  var when = function (dictApplicative) {
      return function (v) {
          return function (v1) {
              if (v) {
                  return v1;
              };
              if (!v) {
                  return pure(dictApplicative)(Data_Unit.unit);
              };
              throw new Error("Failed pattern match at Control.Applicative line 58, column 1 - line 58, column 16: " + [ v.constructor.name, v1.constructor.name ]);
          };
      };
  };

  /**
 *  | `liftA1` provides a default implementation of `(<$>)` for any
 *  | [`Applicative`](#applicative) functor, without using `(<$>)` as provided
 *  | by the [`Functor`](#functor)-[`Applicative`](#applicative) superclass
 *  | relationship.
 *  |
 *  | `liftA1` can therefore be used to write [`Functor`](#functor) instances
 *  | as follows:
 *  |
 *  | ```purescript
 *  | instance functorF :: Functor F where
 *  |   map = liftA1
 *  | ```
 */  
  var liftA1 = function (dictApplicative) {
      return function (f) {
          return function (a) {
              return Control_Apply.apply(dictApplicative["__superclass_Control.Apply.Apply_0"]())(pure(dictApplicative)(f))(a);
          };
      };
  };
  var applicativeFn = new Applicative(function () {
      return Control_Apply.applyFn;
  }, function (x) {
      return function (v) {
          return x;
      };
  });
  var applicativeArray = new Applicative(function () {
      return Control_Apply.applyArray;
  }, function (x) {
      return [ x ];
  });
  exports["Applicative"] = Applicative;
  exports["liftA1"] = liftA1;
  exports["pure"] = pure;
  exports["unless"] = unless;
  exports["when"] = when;
  exports["applicativeFn"] = applicativeFn;
  exports["applicativeArray"] = applicativeArray;
})(PS["Control.Applicative"] = PS["Control.Applicative"] || {});
(function(exports) {
    "use strict";
  var Control_Alt = PS["Control.Alt"];
  var Data_Functor = PS["Data.Functor"];        

  /**
 *  | The `Plus` type class extends the `Alt` type class with a value that
 *  | should be the left and right identity for `(<|>)`.
 *  |
 *  | It is similar to `Monoid`, except that it applies to types of
 *  | kind `* -> *`, like `Array` or `List`, rather than concrete types like
 *  | `String` or `Number`.
 *  |
 *  | `Plus` instances should satisfy the following laws:
 *  |
 *  | - Left identity: `empty <|> x == x`
 *  | - Right identity: `x <|> empty == x`
 *  | - Annihilation: `f <$> empty == empty`
 */  
  var Plus = function (__superclass_Control$dotAlt$dotAlt_0, empty) {
      this["__superclass_Control.Alt.Alt_0"] = __superclass_Control$dotAlt$dotAlt_0;
      this.empty = empty;
  };
  var plusArray = new Plus(function () {
      return Control_Alt.altArray;
  }, [  ]);

  /**
 *  | The `Plus` type class extends the `Alt` type class with a value that
 *  | should be the left and right identity for `(<|>)`.
 *  |
 *  | It is similar to `Monoid`, except that it applies to types of
 *  | kind `* -> *`, like `Array` or `List`, rather than concrete types like
 *  | `String` or `Number`.
 *  |
 *  | `Plus` instances should satisfy the following laws:
 *  |
 *  | - Left identity: `empty <|> x == x`
 *  | - Right identity: `x <|> empty == x`
 *  | - Annihilation: `f <$> empty == empty`
 */  
  var empty = function (dict) {
      return dict.empty;
  };
  exports["Plus"] = Plus;
  exports["empty"] = empty;
  exports["plusArray"] = plusArray;
})(PS["Control.Plus"] = PS["Control.Plus"] || {});
(function(exports) {
    "use strict";
  var Control_Alt = PS["Control.Alt"];
  var Control_Applicative = PS["Control.Applicative"];
  var Control_Apply = PS["Control.Apply"];
  var Control_Plus = PS["Control.Plus"];
  var Data_Functor = PS["Data.Functor"];        

  /**
 *  | The `Alternative` type class has no members of its own; it just specifies
 *  | that the type constructor has both `Applicative` and `Plus` instances.
 *  |
 *  | Types which have `Alternative` instances should also satisfy the following
 *  | laws:
 *  |
 *  | - Distributivity: `(f <|> g) <*> x == (f <*> x) <|> (g <*> x)`
 *  | - Annihilation: `empty <*> f = empty`
 */  
  var Alternative = function (__superclass_Control$dotApplicative$dotApplicative_0, __superclass_Control$dotPlus$dotPlus_1) {
      this["__superclass_Control.Applicative.Applicative_0"] = __superclass_Control$dotApplicative$dotApplicative_0;
      this["__superclass_Control.Plus.Plus_1"] = __superclass_Control$dotPlus$dotPlus_1;
  };
  var alternativeArray = new Alternative(function () {
      return Control_Applicative.applicativeArray;
  }, function () {
      return Control_Plus.plusArray;
  });
  exports["Alternative"] = Alternative;
  exports["alternativeArray"] = alternativeArray;
})(PS["Control.Alternative"] = PS["Control.Alternative"] || {});
(function(exports) {
    "use strict";
  var Control_Category = PS["Control.Category"];        

  /**
 *  | A `Bifunctor` is a `Functor` from the pair category `(Type, Type)` to `Type`.
 *  |
 *  | A type constructor with two type arguments can be made into a `Bifunctor` if
 *  | both of its type arguments are covariant.
 *  |
 *  | The `bimap` function maps a pair of functions over the two type arguments
 *  | of the bifunctor.
 *  |
 *  | Laws:
 *  |
 *  | - Identity: `bimap id id == id`
 *  | - Composition: `bimap f1 g1 <<< bimap f2 g2 == bimap (f1 <<< f2) (g1 <<< g2)`
 *  |
 */  
  var Bifunctor = function (bimap) {
      this.bimap = bimap;
  };

  /**
 *  | A `Bifunctor` is a `Functor` from the pair category `(Type, Type)` to `Type`.
 *  |
 *  | A type constructor with two type arguments can be made into a `Bifunctor` if
 *  | both of its type arguments are covariant.
 *  |
 *  | The `bimap` function maps a pair of functions over the two type arguments
 *  | of the bifunctor.
 *  |
 *  | Laws:
 *  |
 *  | - Identity: `bimap id id == id`
 *  | - Composition: `bimap f1 g1 <<< bimap f2 g2 == bimap (f1 <<< f2) (g1 <<< g2)`
 *  |
 */  
  var bimap = function (dict) {
      return dict.bimap;
  };

  /**
 *  | Map a function over the first type argument of a `Bifunctor`.
 */  
  var lmap = function (dictBifunctor) {
      return function (f) {
          return bimap(dictBifunctor)(f)(Control_Category.id(Control_Category.categoryFn));
      };
  };

  /**
 *  | Map a function over the second type arguments of a `Bifunctor`.
 */  
  var rmap = function (dictBifunctor) {
      return bimap(dictBifunctor)(Control_Category.id(Control_Category.categoryFn));
  };
  exports["Bifunctor"] = Bifunctor;
  exports["bimap"] = bimap;
  exports["lmap"] = lmap;
  exports["rmap"] = rmap;
})(PS["Data.Bifunctor"] = PS["Data.Bifunctor"] || {});
(function(exports) {
    "use strict";
  var Data_Function = PS["Data.Function"];
  var Data_Bifunctor = PS["Data.Bifunctor"];
  var Control_Category = PS["Control.Category"];        

  /**
 *  | `Biapply` captures type constructors of two arguments which support lifting of
 *  | functions of one or more arguments, in the sense of `Apply`.
 */  
  var Biapply = function (__superclass_Data$dotBifunctor$dotBifunctor_0, biapply) {
      this["__superclass_Data.Bifunctor.Bifunctor_0"] = __superclass_Data$dotBifunctor$dotBifunctor_0;
      this.biapply = biapply;
  };

  /**
 *  | `Biapply` captures type constructors of two arguments which support lifting of
 *  | functions of one or more arguments, in the sense of `Apply`.
 */  
  var biapply = function (dict) {
      return dict.biapply;
  };

  /**
 *  | Keep the results of the second computation.
 */  
  var biapplyFirst = function (dictBiapply) {
      return function (a) {
          return function (b) {
              return biapply(dictBiapply)(Control_Category.id(Control_Category.categoryFn)(Data_Bifunctor.bimap(dictBiapply["__superclass_Data.Bifunctor.Bifunctor_0"]())(Data_Function["const"](Control_Category.id(Control_Category.categoryFn)))(Data_Function["const"](Control_Category.id(Control_Category.categoryFn))))(a))(b);
          };
      };
  };

  /**
 *  | Keep the results of the first computation.
 */  
  var biapplySecond = function (dictBiapply) {
      return function (a) {
          return function (b) {
              return biapply(dictBiapply)(Control_Category.id(Control_Category.categoryFn)(Data_Bifunctor.bimap(dictBiapply["__superclass_Data.Bifunctor.Bifunctor_0"]())(Data_Function["const"])(Data_Function["const"]))(a))(b);
          };
      };
  };

  /**
 *  | Lift a function of two arguments.
 */  
  var bilift2 = function (dictBiapply) {
      return function (f) {
          return function (g) {
              return function (a) {
                  return function (b) {
                      return biapply(dictBiapply)(Control_Category.id(Control_Category.categoryFn)(Data_Bifunctor.bimap(dictBiapply["__superclass_Data.Bifunctor.Bifunctor_0"]())(f)(g))(a))(b);
                  };
              };
          };
      };
  };

  /**
 *  | Lift a function of three arguments.
 */  
  var bilift3 = function (dictBiapply) {
      return function (f) {
          return function (g) {
              return function (a) {
                  return function (b) {
                      return function (c) {
                          return biapply(dictBiapply)(biapply(dictBiapply)(Control_Category.id(Control_Category.categoryFn)(Data_Bifunctor.bimap(dictBiapply["__superclass_Data.Bifunctor.Bifunctor_0"]())(f)(g))(a))(b))(c);
                      };
                  };
              };
          };
      };
  };
  exports["Biapply"] = Biapply;
  exports["biapply"] = biapply;
  exports["biapplyFirst"] = biapplyFirst;
  exports["biapplySecond"] = biapplySecond;
  exports["bilift2"] = bilift2;
  exports["bilift3"] = bilift3;
})(PS["Control.Biapply"] = PS["Control.Biapply"] || {});
(function(exports) {
    "use strict";
  var Control_Biapply = PS["Control.Biapply"];        

  /**
 *  | `Biapplicative` captures type constructors of two arguments which support lifting of
 *  | functions of zero or more arguments, in the sense of `Applicative`.
 */  
  var Biapplicative = function (__superclass_Control$dotBiapply$dotBiapply_0, bipure) {
      this["__superclass_Control.Biapply.Biapply_0"] = __superclass_Control$dotBiapply$dotBiapply_0;
      this.bipure = bipure;
  };

  /**
 *  | `Biapplicative` captures type constructors of two arguments which support lifting of
 *  | functions of zero or more arguments, in the sense of `Applicative`.
 */  
  var bipure = function (dict) {
      return dict.bipure;
  };
  exports["Biapplicative"] = Biapplicative;
  exports["bipure"] = bipure;
})(PS["Control.Biapplicative"] = PS["Control.Biapplicative"] || {});
(function(exports) {
    "use strict";

  exports.arrayBind = function (arr) {
    return function (f) {
      var result = [];
      for (var i = 0, l = arr.length; i < l; i++) {
        Array.prototype.push.apply(result, f(arr[i]));
      }
      return result;
    };
  };
})(PS["Control.Bind"] = PS["Control.Bind"] || {});
(function(exports) {
    "use strict";
  var $foreign = PS["Control.Bind"];
  var Control_Applicative = PS["Control.Applicative"];
  var Control_Apply = PS["Control.Apply"];
  var Control_Category = PS["Control.Category"];
  var Data_Function = PS["Data.Function"];
  var Data_Functor = PS["Data.Functor"];        

  /**
 *  | The `Bind` type class extends the [`Apply`](#apply) type class with a
 *  | "bind" operation `(>>=)` which composes computations in sequence, using
 *  | the return value of one computation to determine the next computation.
 *  |
 *  | The `>>=` operator can also be expressed using `do` notation, as follows:
 *  |
 *  | ```purescript
 *  | x >>= f = do y <- x
 *  |              f y
 *  | ```
 *  |
 *  | where the function argument of `f` is given the name `y`.
 *  |
 *  | Instances must satisfy the following law in addition to the `Apply`
 *  | laws:
 *  |
 *  | - Associativity: `(x >>= f) >>= g = x >>= (\k -> f k >>= g)`
 *  |
 *  | Associativity tells us that we can regroup operations which use `do`
 *  | notation so that we can unambiguously write, for example:
 *  |
 *  | ```purescript
 *  | do x <- m1
 *  |    y <- m2 x
 *  |    m3 x y
 *  | ```
 */  
  var Bind = function (__superclass_Control$dotApply$dotApply_0, bind) {
      this["__superclass_Control.Apply.Apply_0"] = __superclass_Control$dotApply$dotApply_0;
      this.bind = bind;
  };
  var bindFn = new Bind(function () {
      return Control_Apply.applyFn;
  }, function (m) {
      return function (f) {
          return function (x) {
              return f(m(x))(x);
          };
      };
  });
  var bindArray = new Bind(function () {
      return Control_Apply.applyArray;
  }, $foreign.arrayBind);

  /**
 *  | The `Bind` type class extends the [`Apply`](#apply) type class with a
 *  | "bind" operation `(>>=)` which composes computations in sequence, using
 *  | the return value of one computation to determine the next computation.
 *  |
 *  | The `>>=` operator can also be expressed using `do` notation, as follows:
 *  |
 *  | ```purescript
 *  | x >>= f = do y <- x
 *  |              f y
 *  | ```
 *  |
 *  | where the function argument of `f` is given the name `y`.
 *  |
 *  | Instances must satisfy the following law in addition to the `Apply`
 *  | laws:
 *  |
 *  | - Associativity: `(x >>= f) >>= g = x >>= (\k -> f k >>= g)`
 *  |
 *  | Associativity tells us that we can regroup operations which use `do`
 *  | notation so that we can unambiguously write, for example:
 *  |
 *  | ```purescript
 *  | do x <- m1
 *  |    y <- m2 x
 *  |    m3 x y
 *  | ```
 */  
  var bind = function (dict) {
      return dict.bind;
  };

  /**
 *  | `bindFlipped` is `bind` with its arguments reversed. For example:
 *  |
 *  | ```purescript
 *  | print =<< random
 *  | ```
 */  
  var bindFlipped = function (dictBind) {
      return Data_Function.flip(bind(dictBind));
  };

  /**
 *  | Backwards Kleisli composition.
 */  
  var composeKleisliFlipped = function (dictBind) {
      return function (f) {
          return function (g) {
              return function (a) {
                  return bindFlipped(dictBind)(f)(g(a));
              };
          };
      };
  };

  /**
 *  | Forwards Kleisli composition.
 *  |
 *  | For example:
 *  |
 *  | ```purescript
 *  | import Data.Array (head, tail)
 *  |
 *  | third = tail >=> tail >=> head
 *  | ```
 */  
  var composeKleisli = function (dictBind) {
      return function (f) {
          return function (g) {
              return function (a) {
                  return bind(dictBind)(f(a))(g);
              };
          };
      };
  };

  /**
 *  | Execute a monadic action if a condition holds.
 *  |
 *  | For example:
 *  |
 *  | ```purescript
 *  | main = ifM ((< 0.5) <$> random)
 *  |          (trace "Heads")
 *  |          (trace "Tails")
 *  | ```
 */  
  var ifM = function (dictBind) {
      return function (cond) {
          return function (t) {
              return function (f) {
                  return bind(dictBind)(cond)(function (cond$prime) {
                      if (cond$prime) {
                          return t;
                      };
                      if (!cond$prime) {
                          return f;
                      };
                      throw new Error("Failed pattern match at Control.Bind line 103, column 35 - line 103, column 56: " + [ cond$prime.constructor.name ]);
                  });
              };
          };
      };
  };

  /**
 *  | Collapse two applications of a monadic type constructor into one.
 */  
  var join = function (dictBind) {
      return function (m) {
          return bind(dictBind)(m)(Control_Category.id(Control_Category.categoryFn));
      };
  };
  exports["Bind"] = Bind;
  exports["bind"] = bind;
  exports["bindFlipped"] = bindFlipped;
  exports["composeKleisli"] = composeKleisli;
  exports["composeKleisliFlipped"] = composeKleisliFlipped;
  exports["ifM"] = ifM;
  exports["join"] = join;
  exports["bindFn"] = bindFn;
  exports["bindArray"] = bindArray;
})(PS["Control.Bind"] = PS["Control.Bind"] || {});
(function(exports) {
    "use strict";
  var Control_Category = PS["Control.Category"];
  var Data_Functor = PS["Data.Functor"];
  var Data_Semigroup = PS["Data.Semigroup"];        

  /**
 *  | The `Extend` class defines the extension operator `(<<=)`
 *  | which extends a local context-dependent computation to
 *  | a global computation.
 *  |
 *  | `Extend` is the dual of `Bind`, and `(<<=)` is the dual of
 *  | `(>>=)`.
 *  |
 *  | Laws:
 *  |
 *  | - Associativity: `extend f <<< extend g = extend (f <<< extend g)`
 */  
  var Extend = function (__superclass_Data$dotFunctor$dotFunctor_0, extend) {
      this["__superclass_Data.Functor.Functor_0"] = __superclass_Data$dotFunctor$dotFunctor_0;
      this.extend = extend;
  };
  var extendFn = function (dictSemigroup) {
      return new Extend(function () {
          return Data_Functor.functorFn;
      }, function (f) {
          return function (g) {
              return function (w) {
                  return f(function (w$prime) {
                      return g(Data_Semigroup.append(dictSemigroup)(w)(w$prime));
                  });
              };
          };
      });
  };

  /**
 *  | The `Extend` class defines the extension operator `(<<=)`
 *  | which extends a local context-dependent computation to
 *  | a global computation.
 *  |
 *  | `Extend` is the dual of `Bind`, and `(<<=)` is the dual of
 *  | `(>>=)`.
 *  |
 *  | Laws:
 *  |
 *  | - Associativity: `extend f <<< extend g = extend (f <<< extend g)`
 */  
  var extend = function (dict) {
      return dict.extend;
  };

  /**
 *  | A version of `extend` with its arguments flipped.
 */  
  var extendFlipped = function (dictExtend) {
      return function (w) {
          return function (f) {
              return extend(dictExtend)(f)(w);
          };
      };
  };

  /**
 *  | Duplicate a comonadic context.
 *  |
 *  | `duplicate` is dual to `Control.Bind.join`.
 */  
  var duplicate = function (dictExtend) {
      return extend(dictExtend)(Control_Category.id(Control_Category.categoryFn));
  };

  /**
 *  | Backwards co-Kleisli composition.
 */  
  var composeCoKleisliFlipped = function (dictExtend) {
      return function (f) {
          return function (g) {
              return function (w) {
                  return f(extend(dictExtend)(g)(w));
              };
          };
      };
  };

  /**
 *  | Forwards co-Kleisli composition.
 */  
  var composeCoKleisli = function (dictExtend) {
      return function (f) {
          return function (g) {
              return function (w) {
                  return g(extend(dictExtend)(f)(w));
              };
          };
      };
  };
  exports["Extend"] = Extend;
  exports["composeCoKleisli"] = composeCoKleisli;
  exports["composeCoKleisliFlipped"] = composeCoKleisliFlipped;
  exports["duplicate"] = duplicate;
  exports["extend"] = extend;
  exports["extendFlipped"] = extendFlipped;
  exports["extendFn"] = extendFn;
})(PS["Control.Extend"] = PS["Control.Extend"] || {});
(function(exports) {
    "use strict";
  var Control_Extend = PS["Control.Extend"];
  var Data_Functor = PS["Data.Functor"];        

  /**
 *  | `Comonad` extends the `Extend` class with the `extract` function
 *  | which extracts a value, discarding the comonadic context.
 *  |
 *  | `Comonad` is the dual of `Monad`, and `extract` is the dual of `pure`.
 *  |
 *  | Laws:
 *  |
 *  | - Left Identity: `extract <<= xs = xs`
 *  | - Right Identity: `extract (f <<= xs) = f xs`
 */  
  var Comonad = function (__superclass_Control$dotExtend$dotExtend_0, extract) {
      this["__superclass_Control.Extend.Extend_0"] = __superclass_Control$dotExtend$dotExtend_0;
      this.extract = extract;
  };

  /**
 *  | `Comonad` extends the `Extend` class with the `extract` function
 *  | which extracts a value, discarding the comonadic context.
 *  |
 *  | `Comonad` is the dual of `Monad`, and `extract` is the dual of `pure`.
 *  |
 *  | Laws:
 *  |
 *  | - Left Identity: `extract <<= xs = xs`
 *  | - Right Identity: `extract (f <<= xs) = f xs`
 */  
  var extract = function (dict) {
      return dict.extract;
  };
  exports["Comonad"] = Comonad;
  exports["extract"] = extract;
})(PS["Control.Comonad"] = PS["Control.Comonad"] || {});
(function(exports) {
    "use strict";

  exports.foldrArray = function (f) {
    return function (init) {
      return function (xs) {
        var acc = init;
        var len = xs.length;
        for (var i = len - 1; i >= 0; i--) {
          acc = f(xs[i])(acc);
        }
        return acc;
      };
    };
  };

  exports.foldlArray = function (f) {
    return function (init) {
      return function (xs) {
        var acc = init;
        var len = xs.length;
        for (var i = 0; i < len; i++) {
          acc = f(acc)(xs[i]);
        }
        return acc;
      };
    };
  };
})(PS["Data.Foldable"] = PS["Data.Foldable"] || {});
(function(exports) {
    "use strict";
  var Control_Applicative = PS["Control.Applicative"];
  var Control_Apply = PS["Control.Apply"];
  var Control_Bind = PS["Control.Bind"];
  var Data_Functor = PS["Data.Functor"];
  var Data_Unit = PS["Data.Unit"];        

  /**
 *  | The `Monad` type class combines the operations of the `Bind` and
 *  | `Applicative` type classes. Therefore, `Monad` instances represent type
 *  | constructors which support sequential composition, and also lifting of
 *  | functions of arbitrary arity.
 *  |
 *  | Instances must satisfy the following laws in addition to the
 *  | `Applicative` and `Bind` laws:
 *  |
 *  | - Left Identity: `pure x >>= f = f x`
 *  | - Right Identity: `x >>= pure = x`
 */  
  var Monad = function (__superclass_Control$dotApplicative$dotApplicative_0, __superclass_Control$dotBind$dotBind_1) {
      this["__superclass_Control.Applicative.Applicative_0"] = __superclass_Control$dotApplicative$dotApplicative_0;
      this["__superclass_Control.Bind.Bind_1"] = __superclass_Control$dotBind$dotBind_1;
  };

  /**
 *  | Perform a monadic action when a condition is true, where the conditional
 *  | value is also in a monadic context.
 */  
  var whenM = function (dictMonad) {
      return function (mb) {
          return function (m) {
              return Control_Bind.bind(dictMonad["__superclass_Control.Bind.Bind_1"]())(mb)(function (v) {
                  return Control_Applicative.when(dictMonad["__superclass_Control.Applicative.Applicative_0"]())(v)(m);
              });
          };
      };
  };

  /**
 *  | Perform a monadic action unless a condition is true, where the conditional
 *  | value is also in a monadic context.
 */  
  var unlessM = function (dictMonad) {
      return function (mb) {
          return function (m) {
              return Control_Bind.bind(dictMonad["__superclass_Control.Bind.Bind_1"]())(mb)(function (v) {
                  return Control_Applicative.unless(dictMonad["__superclass_Control.Applicative.Applicative_0"]())(v)(m);
              });
          };
      };
  };
  var monadFn = new Monad(function () {
      return Control_Applicative.applicativeFn;
  }, function () {
      return Control_Bind.bindFn;
  });
  var monadArray = new Monad(function () {
      return Control_Applicative.applicativeArray;
  }, function () {
      return Control_Bind.bindArray;
  });

  /**
 *  | `liftM1` provides a default implementation of `(<$>)` for any
 *  | [`Monad`](#monad), without using `(<$>)` as provided by the
 *  | [`Functor`](#functor)-[`Monad`](#monad) superclass relationship.
 *  |
 *  | `liftM1` can therefore be used to write [`Functor`](#functor) instances
 *  | as follows:
 *  |
 *  | ```purescript
 *  | instance functorF :: Functor F where
 *  |   map = liftM1
 *  | ```
 */  
  var liftM1 = function (dictMonad) {
      return function (f) {
          return function (a) {
              return Control_Bind.bind(dictMonad["__superclass_Control.Bind.Bind_1"]())(a)(function (v) {
                  return Control_Applicative.pure(dictMonad["__superclass_Control.Applicative.Applicative_0"]())(f(v));
              });
          };
      };
  };

  /**
 *  | `ap` provides a default implementation of `(<*>)` for any
 *  | [`Monad`](#monad), without using `(<*>)` as provided by the
 *  | [`Apply`](#apply)-[`Monad`](#monad) superclass relationship.
 *  |
 *  | `ap` can therefore be used to write [`Apply`](#apply) instances as
 *  | follows:
 *  |
 *  | ```purescript
 *  | instance applyF :: Apply F where
 *  |   apply = ap
 *  | ```
 */  
  var ap = function (dictMonad) {
      return function (f) {
          return function (a) {
              return Control_Bind.bind(dictMonad["__superclass_Control.Bind.Bind_1"]())(f)(function (v) {
                  return Control_Bind.bind(dictMonad["__superclass_Control.Bind.Bind_1"]())(a)(function (v1) {
                      return Control_Applicative.pure(dictMonad["__superclass_Control.Applicative.Applicative_0"]())(v(v1));
                  });
              });
          };
      };
  };
  exports["Monad"] = Monad;
  exports["ap"] = ap;
  exports["liftM1"] = liftM1;
  exports["unlessM"] = unlessM;
  exports["whenM"] = whenM;
  exports["monadFn"] = monadFn;
  exports["monadArray"] = monadArray;
})(PS["Control.Monad"] = PS["Control.Monad"] || {});
(function(exports) {
    "use strict";
  var Control_Alt = PS["Control.Alt"];
  var Control_Alternative = PS["Control.Alternative"];
  var Control_Applicative = PS["Control.Applicative"];
  var Control_Apply = PS["Control.Apply"];
  var Control_Bind = PS["Control.Bind"];
  var Control_Monad = PS["Control.Monad"];
  var Control_Plus = PS["Control.Plus"];
  var Data_Functor = PS["Data.Functor"];
  var Data_Unit = PS["Data.Unit"];        

  /**
 *  | The `MonadZero` type class has no members of its own; it just specifies
 *  | that the type has both `Monad` and `Alternative` instances.
 *  |
 *  | Types which have `MonadZero` instances should also satisfy the following
 *  | laws:
 *  |
 *  | - Annihilation: `empty >>= f = empty`
 */  
  var MonadZero = function (__superclass_Control$dotAlternative$dotAlternative_1, __superclass_Control$dotMonad$dotMonad_0) {
      this["__superclass_Control.Alternative.Alternative_1"] = __superclass_Control$dotAlternative$dotAlternative_1;
      this["__superclass_Control.Monad.Monad_0"] = __superclass_Control$dotMonad$dotMonad_0;
  };
  var monadZeroArray = new MonadZero(function () {
      return Control_Alternative.alternativeArray;
  }, function () {
      return Control_Monad.monadArray;
  });

  /**
 *  | Fail using `Plus` if a condition does not hold, or
 *  | succeed using `Monad` if it does.
 *  |
 *  | For example:
 *  |
 *  | ```purescript
 *  | import Data.Array
 *  |
 *  | factors :: Number -> Array Number
 *  | factors n = do
 *  |   a <- 1 .. n
 *  |   b <- 1 .. a
 *  |   guard $ a * b == n
 *  |   pure a
 *  | ```
 */  
  var guard = function (dictMonadZero) {
      return function (v) {
          if (v) {
              return Control_Applicative.pure((dictMonadZero["__superclass_Control.Alternative.Alternative_1"]())["__superclass_Control.Applicative.Applicative_0"]())(Data_Unit.unit);
          };
          if (!v) {
              return Control_Plus.empty((dictMonadZero["__superclass_Control.Alternative.Alternative_1"]())["__superclass_Control.Plus.Plus_1"]());
          };
          throw new Error("Failed pattern match at Control.MonadZero line 52, column 1 - line 52, column 23: " + [ v.constructor.name ]);
      };
  };
  exports["MonadZero"] = MonadZero;
  exports["guard"] = guard;
  exports["monadZeroArray"] = monadZeroArray;
})(PS["Control.MonadZero"] = PS["Control.MonadZero"] || {});
(function(exports) {
    "use strict";
  var Data_Functor = PS["Data.Functor"];        

  /**
 *  | A type of functor that can be used to adapt the type of a wrapped function
 *  | where the parameterised type occurs in both the positive and negative
 *  | position, for example, `F (a -> a)`.
 *  |
 *  | An `Invariant` instance should satisfy the following laws:
 *  |
 *  | - Identity: `imap id id = id`
 *  | - Composition: `imap g1 g2 <<< imap f1 f2 = imap (g1 <<< f1) (f2 <<< g2)`
 *  |
 */  
  var Invariant = function (imap) {
      this.imap = imap;
  };

  /**
 *  | As all `Functor`s are also trivially `Invariant`, this function can be
 *  | used as the `imap` implementation for any types that has an existing
 *  | `Functor` instance.
 */  
  var imapF = function (dictFunctor) {
      return function (f) {
          return function (v) {
              return Data_Functor.map(dictFunctor)(f);
          };
      };
  };
  var invariantArray = new Invariant(imapF(Data_Functor.functorArray));
  var invariantFn = new Invariant(imapF(Data_Functor.functorFn));

  /**
 *  | A type of functor that can be used to adapt the type of a wrapped function
 *  | where the parameterised type occurs in both the positive and negative
 *  | position, for example, `F (a -> a)`.
 *  |
 *  | An `Invariant` instance should satisfy the following laws:
 *  |
 *  | - Identity: `imap id id = id`
 *  | - Composition: `imap g1 g2 <<< imap f1 f2 = imap (g1 <<< f1) (f2 <<< g2)`
 *  |
 */  
  var imap = function (dict) {
      return dict.imap;
  };
  exports["Invariant"] = Invariant;
  exports["imap"] = imap;
  exports["imapF"] = imapF;
  exports["invariantFn"] = invariantFn;
  exports["invariantArray"] = invariantArray;
})(PS["Data.Functor.Invariant"] = PS["Data.Functor.Invariant"] || {});
(function(exports) {
    "use strict";
  var Data_Function = PS["Data.Function"];
  var Data_Semigroup = PS["Data.Semigroup"];
  var Data_Unit = PS["Data.Unit"];        

  /**
 *  | A `Monoid` is a `Semigroup` with a value `mempty`, which is both a
 *  | left and right unit for the associative operation `<>`:
 *  |
 *  | ```text
 *  | forall x. mempty <> x = x <> mempty = x
 *  | ```
 *  |
 *  | `Monoid`s are commonly used as the result of fold operations, where
 *  | `<>` is used to combine individual results, and `mempty` gives the result
 *  | of folding an empty collection of elements.
 */  
  var Monoid = function (__superclass_Data$dotSemigroup$dotSemigroup_0, mempty) {
      this["__superclass_Data.Semigroup.Semigroup_0"] = __superclass_Data$dotSemigroup$dotSemigroup_0;
      this.mempty = mempty;
  };
  var monoidUnit = new Monoid(function () {
      return Data_Semigroup.semigroupUnit;
  }, Data_Unit.unit);
  var monoidString = new Monoid(function () {
      return Data_Semigroup.semigroupString;
  }, "");
  var monoidArray = new Monoid(function () {
      return Data_Semigroup.semigroupArray;
  }, [  ]);

  /**
 *  | A `Monoid` is a `Semigroup` with a value `mempty`, which is both a
 *  | left and right unit for the associative operation `<>`:
 *  |
 *  | ```text
 *  | forall x. mempty <> x = x <> mempty = x
 *  | ```
 *  |
 *  | `Monoid`s are commonly used as the result of fold operations, where
 *  | `<>` is used to combine individual results, and `mempty` gives the result
 *  | of folding an empty collection of elements.
 */  
  var mempty = function (dict) {
      return dict.mempty;
  };
  var monoidFn = function (dictMonoid) {
      return new Monoid(function () {
          return Data_Semigroup.semigroupFn(dictMonoid["__superclass_Data.Semigroup.Semigroup_0"]());
      }, Data_Function["const"](mempty(dictMonoid)));
  };
  exports["Monoid"] = Monoid;
  exports["mempty"] = mempty;
  exports["monoidUnit"] = monoidUnit;
  exports["monoidFn"] = monoidFn;
  exports["monoidString"] = monoidString;
  exports["monoidArray"] = monoidArray;
})(PS["Data.Monoid"] = PS["Data.Monoid"] || {});
(function(exports) {
    "use strict";

  exports.refEq = function (r1) {
    return function (r2) {
      return r1 === r2;
    };
  };

  exports.refIneq = function (r1) {
    return function (r2) {
      return r1 !== r2;
    };
  };

  exports.eqArrayImpl = function (f) {
    return function (xs) {
      return function (ys) {
        if (xs.length !== ys.length) return false;
        for (var i = 0; i < xs.length; i++) {
          if (!f(xs[i])(ys[i])) return false;
        }
        return true;
      };
    };
  };
})(PS["Data.Eq"] = PS["Data.Eq"] || {});
(function(exports) {
    "use strict";
  var $foreign = PS["Data.Eq"];
  var Data_Unit = PS["Data.Unit"];
  var Data_Void = PS["Data.Void"];        

  /**
 *  | The `Eq` type class represents types which support decidable equality.
 *  |
 *  | `Eq` instances should satisfy the following laws:
 *  |
 *  | - Reflexivity: `x == x = true`
 *  | - Symmetry: `x == y = y == x`
 *  | - Transitivity: if `x == y` and `y == z` then `x == z`
 *  |
 *  | **Note:** The `Number` type is not an entirely law abiding member of this
 *  | class due to the presence of `NaN`, since `NaN /= NaN`. Additionally,
 *  | computing with `Number` can result in a loss of precision, so sometimes
 *  | values that should be equivalent are not.
 */  
  var Eq = function (eq) {
      this.eq = eq;
  };
  var eqVoid = new Eq(function (v) {
      return function (v1) {
          return true;
      };
  });
  var eqUnit = new Eq(function (v) {
      return function (v1) {
          return true;
      };
  });
  var eqString = new Eq($foreign.refEq);
  var eqNumber = new Eq($foreign.refEq);
  var eqInt = new Eq($foreign.refEq);
  var eqChar = new Eq($foreign.refEq);
  var eqBoolean = new Eq($foreign.refEq);

  /**
 *  | The `Eq` type class represents types which support decidable equality.
 *  |
 *  | `Eq` instances should satisfy the following laws:
 *  |
 *  | - Reflexivity: `x == x = true`
 *  | - Symmetry: `x == y = y == x`
 *  | - Transitivity: if `x == y` and `y == z` then `x == z`
 *  |
 *  | **Note:** The `Number` type is not an entirely law abiding member of this
 *  | class due to the presence of `NaN`, since `NaN /= NaN`. Additionally,
 *  | computing with `Number` can result in a loss of precision, so sometimes
 *  | values that should be equivalent are not.
 */  
  var eq = function (dict) {
      return dict.eq;
  };
  var eqArray = function (dictEq) {
      return new Eq($foreign.eqArrayImpl(eq(dictEq)));
  };

  /**
 *  | `notEq` tests whether one value is _not equal_ to another. Shorthand for
 *  | `not (eq x y)`.
 */  
  var notEq = function (dictEq) {
      return function (x) {
          return function (y) {
              return eq(eqBoolean)(eq(dictEq)(x)(y))(false);
          };
      };
  };
  exports["Eq"] = Eq;
  exports["eq"] = eq;
  exports["notEq"] = notEq;
  exports["eqBoolean"] = eqBoolean;
  exports["eqInt"] = eqInt;
  exports["eqNumber"] = eqNumber;
  exports["eqChar"] = eqChar;
  exports["eqString"] = eqString;
  exports["eqUnit"] = eqUnit;
  exports["eqVoid"] = eqVoid;
  exports["eqArray"] = eqArray;
})(PS["Data.Eq"] = PS["Data.Eq"] || {});
(function(exports) {
    "use strict";

  exports.ordArrayImpl = function (f) {
    return function (xs) {
      return function (ys) {
        var i = 0;
        var xlen = xs.length;
        var ylen = ys.length;
        while (i < xlen && i < ylen) {
          var x = xs[i];
          var y = ys[i];
          var o = f(x)(y);
          if (o !== 0) {
            return o;
          }
          i++;
        }
        if (xlen === ylen) {
          return 0;
        } else if (xlen > ylen) {
          return -1;
        } else {
          return 1;
        }
      };
    };
  };
})(PS["Data.Ord"] = PS["Data.Ord"] || {});
(function(exports) {
    "use strict";

  exports.unsafeCompareImpl = function (lt) {
    return function (eq) {
      return function (gt) {
        return function (x) {
          return function (y) {
            return x < y ? lt : x === y ? eq : gt;
          };
        };
      };
    };
  };
})(PS["Data.Ord.Unsafe"] = PS["Data.Ord.Unsafe"] || {});
(function(exports) {
    "use strict";
  var Data_Eq = PS["Data.Eq"];
  var Data_Semigroup = PS["Data.Semigroup"];
  var Data_Show = PS["Data.Show"];        

  /**
 *  | The `Ordering` data type represents the three possible outcomes of
 *  | comparing two values:
 *  |
 *  | `LT` - The first value is _less than_ the second.
 *  | `GT` - The first value is _greater than_ the second.
 *  | `EQ` - The first value is _equal to_ the second.
 */  
  var LT = (function () {
      function LT() {

      };
      LT.value = new LT();
      return LT;
  })();

  /**
 *  | The `Ordering` data type represents the three possible outcomes of
 *  | comparing two values:
 *  |
 *  | `LT` - The first value is _less than_ the second.
 *  | `GT` - The first value is _greater than_ the second.
 *  | `EQ` - The first value is _equal to_ the second.
 */  
  var GT = (function () {
      function GT() {

      };
      GT.value = new GT();
      return GT;
  })();

  /**
 *  | The `Ordering` data type represents the three possible outcomes of
 *  | comparing two values:
 *  |
 *  | `LT` - The first value is _less than_ the second.
 *  | `GT` - The first value is _greater than_ the second.
 *  | `EQ` - The first value is _equal to_ the second.
 */  
  var EQ = (function () {
      function EQ() {

      };
      EQ.value = new EQ();
      return EQ;
  })();
  var showOrdering = new Data_Show.Show(function (v) {
      if (v instanceof LT) {
          return "LT";
      };
      if (v instanceof GT) {
          return "GT";
      };
      if (v instanceof EQ) {
          return "EQ";
      };
      throw new Error("Failed pattern match at Data.Ordering line 27, column 3 - line 28, column 3: " + [ v.constructor.name ]);
  });
  var semigroupOrdering = new Data_Semigroup.Semigroup(function (v) {
      return function (v1) {
          if (v instanceof LT) {
              return LT.value;
          };
          if (v instanceof GT) {
              return GT.value;
          };
          if (v instanceof EQ) {
              return v1;
          };
          throw new Error("Failed pattern match at Data.Ordering line 22, column 3 - line 22, column 19: " + [ v.constructor.name, v1.constructor.name ]);
      };
  });

  /**
 *  | Reverses an `Ordering` value, flipping greater than for less than while
 *  | preserving equality.
 */  
  var invert = function (v) {
      if (v instanceof GT) {
          return LT.value;
      };
      if (v instanceof EQ) {
          return EQ.value;
      };
      if (v instanceof LT) {
          return GT.value;
      };
      throw new Error("Failed pattern match at Data.Ordering line 34, column 1 - line 34, column 15: " + [ v.constructor.name ]);
  };
  var eqOrdering = new Data_Eq.Eq(function (v) {
      return function (v1) {
          if (v instanceof LT && v1 instanceof LT) {
              return true;
          };
          if (v instanceof GT && v1 instanceof GT) {
              return true;
          };
          if (v instanceof EQ && v1 instanceof EQ) {
              return true;
          };
          return false;
      };
  });
  exports["LT"] = LT;
  exports["GT"] = GT;
  exports["EQ"] = EQ;
  exports["invert"] = invert;
  exports["eqOrdering"] = eqOrdering;
  exports["semigroupOrdering"] = semigroupOrdering;
  exports["showOrdering"] = showOrdering;
})(PS["Data.Ordering"] = PS["Data.Ordering"] || {});
(function(exports) {
    "use strict";
  var $foreign = PS["Data.Ord.Unsafe"];
  var Data_Ordering = PS["Data.Ordering"];        
  var unsafeCompare = $foreign.unsafeCompareImpl(Data_Ordering.LT.value)(Data_Ordering.EQ.value)(Data_Ordering.GT.value);
  exports["unsafeCompare"] = unsafeCompare;
})(PS["Data.Ord.Unsafe"] = PS["Data.Ord.Unsafe"] || {});
(function(exports) {
    "use strict";

  exports.intSub = function (x) {
    return function (y) {
      /* jshint bitwise: false */
      return x - y | 0;
    };
  };

  exports.numSub = function (n1) {
    return function (n2) {
      return n1 - n2;
    };
  };
})(PS["Data.Ring"] = PS["Data.Ring"] || {});
(function(exports) {
    "use strict";

  exports.intAdd = function (x) {
    return function (y) {
      /* jshint bitwise: false */
      return x + y | 0;
    };
  };

  exports.intMul = function (x) {
    return function (y) {
      /* jshint bitwise: false */
      return x * y | 0;
    };
  };

  exports.numAdd = function (n1) {
    return function (n2) {
      return n1 + n2;
    };
  };

  exports.numMul = function (n1) {
    return function (n2) {
      return n1 * n2;
    };
  };
})(PS["Data.Semiring"] = PS["Data.Semiring"] || {});
(function(exports) {
    "use strict";
  var $foreign = PS["Data.Semiring"];
  var Data_Unit = PS["Data.Unit"];        

  /**
 *  | The `Semiring` class is for types that support an addition and
 *  | multiplication operation.
 *  |
 *  | Instances must satisfy the following laws:
 *  |
 *  | - Commutative monoid under addition:
 *  |   - Associativity: `(a + b) + c = a + (b + c)`
 *  |   - Identity: `zero + a = a + zero = a`
 *  |   - Commutative: `a + b = b + a`
 *  | - Monoid under multiplication:
 *  |   - Associativity: `(a * b) * c = a * (b * c)`
 *  |   - Identity: `one * a = a * one = a`
 *  | - Multiplication distributes over addition:
 *  |   - Left distributivity: `a * (b + c) = (a * b) + (a * c)`
 *  |   - Right distributivity: `(a + b) * c = (a * c) + (b * c)`
 *  | - Annihilation: `zero * a = a * zero = zero`
 *  |
 *  | **Note:** The `Number` and `Int` types are not fully law abiding
 *  | members of this class hierarchy due to the potential for arithmetic
 *  | overflows, and in the case of `Number`, the presence of `NaN` and
 *  | `Infinity` values. The behaviour is unspecified in these cases.
 */  
  var Semiring = function (add, mul, one, zero) {
      this.add = add;
      this.mul = mul;
      this.one = one;
      this.zero = zero;
  };

  /**
 *  | The `Semiring` class is for types that support an addition and
 *  | multiplication operation.
 *  |
 *  | Instances must satisfy the following laws:
 *  |
 *  | - Commutative monoid under addition:
 *  |   - Associativity: `(a + b) + c = a + (b + c)`
 *  |   - Identity: `zero + a = a + zero = a`
 *  |   - Commutative: `a + b = b + a`
 *  | - Monoid under multiplication:
 *  |   - Associativity: `(a * b) * c = a * (b * c)`
 *  |   - Identity: `one * a = a * one = a`
 *  | - Multiplication distributes over addition:
 *  |   - Left distributivity: `a * (b + c) = (a * b) + (a * c)`
 *  |   - Right distributivity: `(a + b) * c = (a * c) + (b * c)`
 *  | - Annihilation: `zero * a = a * zero = zero`
 *  |
 *  | **Note:** The `Number` and `Int` types are not fully law abiding
 *  | members of this class hierarchy due to the potential for arithmetic
 *  | overflows, and in the case of `Number`, the presence of `NaN` and
 *  | `Infinity` values. The behaviour is unspecified in these cases.
 */  
  var zero = function (dict) {
      return dict.zero;
  };
  var semiringUnit = new Semiring(function (v) {
      return function (v1) {
          return Data_Unit.unit;
      };
  }, function (v) {
      return function (v1) {
          return Data_Unit.unit;
      };
  }, Data_Unit.unit, Data_Unit.unit);
  var semiringNumber = new Semiring($foreign.numAdd, $foreign.numMul, 1.0, 0.0);
  var semiringInt = new Semiring($foreign.intAdd, $foreign.intMul, 1, 0);

  /**
 *  | The `Semiring` class is for types that support an addition and
 *  | multiplication operation.
 *  |
 *  | Instances must satisfy the following laws:
 *  |
 *  | - Commutative monoid under addition:
 *  |   - Associativity: `(a + b) + c = a + (b + c)`
 *  |   - Identity: `zero + a = a + zero = a`
 *  |   - Commutative: `a + b = b + a`
 *  | - Monoid under multiplication:
 *  |   - Associativity: `(a * b) * c = a * (b * c)`
 *  |   - Identity: `one * a = a * one = a`
 *  | - Multiplication distributes over addition:
 *  |   - Left distributivity: `a * (b + c) = (a * b) + (a * c)`
 *  |   - Right distributivity: `(a + b) * c = (a * c) + (b * c)`
 *  | - Annihilation: `zero * a = a * zero = zero`
 *  |
 *  | **Note:** The `Number` and `Int` types are not fully law abiding
 *  | members of this class hierarchy due to the potential for arithmetic
 *  | overflows, and in the case of `Number`, the presence of `NaN` and
 *  | `Infinity` values. The behaviour is unspecified in these cases.
 */  
  var one = function (dict) {
      return dict.one;
  };

  /**
 *  | The `Semiring` class is for types that support an addition and
 *  | multiplication operation.
 *  |
 *  | Instances must satisfy the following laws:
 *  |
 *  | - Commutative monoid under addition:
 *  |   - Associativity: `(a + b) + c = a + (b + c)`
 *  |   - Identity: `zero + a = a + zero = a`
 *  |   - Commutative: `a + b = b + a`
 *  | - Monoid under multiplication:
 *  |   - Associativity: `(a * b) * c = a * (b * c)`
 *  |   - Identity: `one * a = a * one = a`
 *  | - Multiplication distributes over addition:
 *  |   - Left distributivity: `a * (b + c) = (a * b) + (a * c)`
 *  |   - Right distributivity: `(a + b) * c = (a * c) + (b * c)`
 *  | - Annihilation: `zero * a = a * zero = zero`
 *  |
 *  | **Note:** The `Number` and `Int` types are not fully law abiding
 *  | members of this class hierarchy due to the potential for arithmetic
 *  | overflows, and in the case of `Number`, the presence of `NaN` and
 *  | `Infinity` values. The behaviour is unspecified in these cases.
 */  
  var mul = function (dict) {
      return dict.mul;
  };

  /**
 *  | The `Semiring` class is for types that support an addition and
 *  | multiplication operation.
 *  |
 *  | Instances must satisfy the following laws:
 *  |
 *  | - Commutative monoid under addition:
 *  |   - Associativity: `(a + b) + c = a + (b + c)`
 *  |   - Identity: `zero + a = a + zero = a`
 *  |   - Commutative: `a + b = b + a`
 *  | - Monoid under multiplication:
 *  |   - Associativity: `(a * b) * c = a * (b * c)`
 *  |   - Identity: `one * a = a * one = a`
 *  | - Multiplication distributes over addition:
 *  |   - Left distributivity: `a * (b + c) = (a * b) + (a * c)`
 *  |   - Right distributivity: `(a + b) * c = (a * c) + (b * c)`
 *  | - Annihilation: `zero * a = a * zero = zero`
 *  |
 *  | **Note:** The `Number` and `Int` types are not fully law abiding
 *  | members of this class hierarchy due to the potential for arithmetic
 *  | overflows, and in the case of `Number`, the presence of `NaN` and
 *  | `Infinity` values. The behaviour is unspecified in these cases.
 */  
  var add = function (dict) {
      return dict.add;
  };
  exports["Semiring"] = Semiring;
  exports["add"] = add;
  exports["mul"] = mul;
  exports["one"] = one;
  exports["zero"] = zero;
  exports["semiringInt"] = semiringInt;
  exports["semiringNumber"] = semiringNumber;
  exports["semiringUnit"] = semiringUnit;
})(PS["Data.Semiring"] = PS["Data.Semiring"] || {});
(function(exports) {
    "use strict";
  var $foreign = PS["Data.Ring"];
  var Data_Semiring = PS["Data.Semiring"];
  var Data_Unit = PS["Data.Unit"];        

  /**
 *  | The `Ring` class is for types that support addition, multiplication,
 *  | and subtraction operations.
 *  |
 *  | Instances must satisfy the following law in addition to the `Semiring`
 *  | laws:
 *  |
 *  | - Additive inverse: `a - a = (zero - a) + a = zero`
 */  
  var Ring = function (__superclass_Data$dotSemiring$dotSemiring_0, sub) {
      this["__superclass_Data.Semiring.Semiring_0"] = __superclass_Data$dotSemiring$dotSemiring_0;
      this.sub = sub;
  };

  /**
 *  | The `Ring` class is for types that support addition, multiplication,
 *  | and subtraction operations.
 *  |
 *  | Instances must satisfy the following law in addition to the `Semiring`
 *  | laws:
 *  |
 *  | - Additive inverse: `a - a = (zero - a) + a = zero`
 */  
  var sub = function (dict) {
      return dict.sub;
  };
  var ringUnit = new Ring(function () {
      return Data_Semiring.semiringUnit;
  }, function (v) {
      return function (v1) {
          return Data_Unit.unit;
      };
  });
  var ringNumber = new Ring(function () {
      return Data_Semiring.semiringNumber;
  }, $foreign.numSub);
  var ringInt = new Ring(function () {
      return Data_Semiring.semiringInt;
  }, $foreign.intSub);

  /**
 *  | `negate x` can be used as a shorthand for `zero - x`.
 */  
  var negate = function (dictRing) {
      return function (a) {
          return sub(dictRing)(Data_Semiring.zero(dictRing["__superclass_Data.Semiring.Semiring_0"]()))(a);
      };
  };
  exports["Ring"] = Ring;
  exports["negate"] = negate;
  exports["sub"] = sub;
  exports["ringInt"] = ringInt;
  exports["ringNumber"] = ringNumber;
  exports["ringUnit"] = ringUnit;
})(PS["Data.Ring"] = PS["Data.Ring"] || {});
(function(exports) {
    "use strict";
  var $foreign = PS["Data.Ord"];
  var Data_Eq = PS["Data.Eq"];
  var Data_Function = PS["Data.Function"];
  var Data_Ord_Unsafe = PS["Data.Ord.Unsafe"];
  var Data_Ordering = PS["Data.Ordering"];
  var Data_Ring = PS["Data.Ring"];
  var Data_Unit = PS["Data.Unit"];
  var Data_Void = PS["Data.Void"];
  var Data_Semiring = PS["Data.Semiring"];        

  /**
 *  | The `Ord` type class represents types which support comparisons with a
 *  | _total order_.
 *  |
 *  | `Ord` instances should satisfy the laws of total orderings:
 *  |
 *  | - Reflexivity: `a <= a`
 *  | - Antisymmetry: if `a <= b` and `b <= a` then `a = b`
 *  | - Transitivity: if `a <= b` and `b <= c` then `a <= c`
 */  
  var Ord = function (__superclass_Data$dotEq$dotEq_0, compare) {
      this["__superclass_Data.Eq.Eq_0"] = __superclass_Data$dotEq$dotEq_0;
      this.compare = compare;
  };
  var ordVoid = new Ord(function () {
      return Data_Eq.eqVoid;
  }, function (v) {
      return function (v1) {
          return Data_Ordering.EQ.value;
      };
  });
  var ordUnit = new Ord(function () {
      return Data_Eq.eqUnit;
  }, function (v) {
      return function (v1) {
          return Data_Ordering.EQ.value;
      };
  });
  var ordString = new Ord(function () {
      return Data_Eq.eqString;
  }, Data_Ord_Unsafe.unsafeCompare);
  var ordOrdering = new Ord(function () {
      return Data_Ordering.eqOrdering;
  }, function (v) {
      return function (v1) {
          if (v instanceof Data_Ordering.LT && v1 instanceof Data_Ordering.LT) {
              return Data_Ordering.EQ.value;
          };
          if (v instanceof Data_Ordering.EQ && v1 instanceof Data_Ordering.EQ) {
              return Data_Ordering.EQ.value;
          };
          if (v instanceof Data_Ordering.GT && v1 instanceof Data_Ordering.GT) {
              return Data_Ordering.EQ.value;
          };
          if (v instanceof Data_Ordering.LT) {
              return Data_Ordering.LT.value;
          };
          if (v instanceof Data_Ordering.EQ && v1 instanceof Data_Ordering.LT) {
              return Data_Ordering.GT.value;
          };
          if (v instanceof Data_Ordering.EQ && v1 instanceof Data_Ordering.GT) {
              return Data_Ordering.LT.value;
          };
          if (v instanceof Data_Ordering.GT) {
              return Data_Ordering.GT.value;
          };
          throw new Error("Failed pattern match at Data.Ord line 68, column 3 - line 68, column 21: " + [ v.constructor.name, v1.constructor.name ]);
      };
  });
  var ordNumber = new Ord(function () {
      return Data_Eq.eqNumber;
  }, Data_Ord_Unsafe.unsafeCompare);
  var ordInt = new Ord(function () {
      return Data_Eq.eqInt;
  }, Data_Ord_Unsafe.unsafeCompare);
  var ordChar = new Ord(function () {
      return Data_Eq.eqChar;
  }, Data_Ord_Unsafe.unsafeCompare);
  var ordBoolean = new Ord(function () {
      return Data_Eq.eqBoolean;
  }, Data_Ord_Unsafe.unsafeCompare);

  /**
 *  | The `Ord` type class represents types which support comparisons with a
 *  | _total order_.
 *  |
 *  | `Ord` instances should satisfy the laws of total orderings:
 *  |
 *  | - Reflexivity: `a <= a`
 *  | - Antisymmetry: if `a <= b` and `b <= a` then `a = b`
 *  | - Transitivity: if `a <= b` and `b <= c` then `a <= c`
 */  
  var compare = function (dict) {
      return dict.compare;
  };

  /**
 *  | Compares two values by mapping them to a type with an `Ord` instance.
 */  
  var comparing = function (dictOrd) {
      return function (f) {
          return Data_Function.on(compare(dictOrd))(f);
      };
  };

  /**
 *  | Test whether one value is _strictly greater than_ another.
 */  
  var greaterThan = function (dictOrd) {
      return function (a1) {
          return function (a2) {
              var $22 = compare(dictOrd)(a1)(a2);
              if ($22 instanceof Data_Ordering.GT) {
                  return true;
              };
              return false;
          };
      };
  };

  /**
 *  | Test whether one value is _non-strictly greater than_ another.
 */  
  var greaterThanOrEq = function (dictOrd) {
      return function (a1) {
          return function (a2) {
              var $23 = compare(dictOrd)(a1)(a2);
              if ($23 instanceof Data_Ordering.LT) {
                  return false;
              };
              return true;
          };
      };
  };

  /**
 *  | The sign function; always evaluates to either `one` or `negate one`. For
 *  | any `x`, we should have `signum x * abs x == x`.
 */  
  var signum = function (dictOrd) {
      return function (dictRing) {
          return function (x) {
              var $24 = greaterThanOrEq(dictOrd)(x)(Data_Semiring.zero(dictRing["__superclass_Data.Semiring.Semiring_0"]()));
              if ($24) {
                  return Data_Semiring.one(dictRing["__superclass_Data.Semiring.Semiring_0"]());
              };
              if (!$24) {
                  return Data_Ring.negate(dictRing)(Data_Semiring.one(dictRing["__superclass_Data.Semiring.Semiring_0"]()));
              };
              throw new Error("Failed pattern match at Data.Ord line 163, column 12 - line 163, column 46: " + [ $24.constructor.name ]);
          };
      };
  };

  /**
 *  | Test whether one value is _strictly less than_ another.
 */  
  var lessThan = function (dictOrd) {
      return function (a1) {
          return function (a2) {
              var $25 = compare(dictOrd)(a1)(a2);
              if ($25 instanceof Data_Ordering.LT) {
                  return true;
              };
              return false;
          };
      };
  };

  /**
 *  | Test whether one value is _non-strictly less than_ another.
 */  
  var lessThanOrEq = function (dictOrd) {
      return function (a1) {
          return function (a2) {
              var $26 = compare(dictOrd)(a1)(a2);
              if ($26 instanceof Data_Ordering.GT) {
                  return false;
              };
              return true;
          };
      };
  };

  /**
 *  | Take the maximum of two values. If they are considered equal, the first
 *  | argument is chosen.
 */  
  var max = function (dictOrd) {
      return function (x) {
          return function (y) {
              var $27 = compare(dictOrd)(x)(y);
              if ($27 instanceof Data_Ordering.LT) {
                  return y;
              };
              if ($27 instanceof Data_Ordering.EQ) {
                  return x;
              };
              if ($27 instanceof Data_Ordering.GT) {
                  return x;
              };
              throw new Error("Failed pattern match at Data.Ord line 122, column 3 - line 125, column 12: " + [ $27.constructor.name ]);
          };
      };
  };

  /**
 *  | Take the minimum of two values. If they are considered equal, the first
 *  | argument is chosen.
 */  
  var min = function (dictOrd) {
      return function (x) {
          return function (y) {
              var $28 = compare(dictOrd)(x)(y);
              if ($28 instanceof Data_Ordering.LT) {
                  return x;
              };
              if ($28 instanceof Data_Ordering.EQ) {
                  return x;
              };
              if ($28 instanceof Data_Ordering.GT) {
                  return y;
              };
              throw new Error("Failed pattern match at Data.Ord line 113, column 3 - line 116, column 12: " + [ $28.constructor.name ]);
          };
      };
  };
  var ordArray = function (dictOrd) {
      return new Ord(function () {
          return Data_Eq.eqArray(dictOrd["__superclass_Data.Eq.Eq_0"]());
      }, (function () {
          var toDelta = function (x) {
              return function (y) {
                  var $29 = compare(dictOrd)(x)(y);
                  if ($29 instanceof Data_Ordering.EQ) {
                      return 0;
                  };
                  if ($29 instanceof Data_Ordering.LT) {
                      return 1;
                  };
                  if ($29 instanceof Data_Ordering.GT) {
                      return -1;
                  };
                  throw new Error("Failed pattern match at Data.Ord line 60, column 7 - line 65, column 1: " + [ $29.constructor.name ]);
              };
          };
          return function (xs) {
              return function (ys) {
                  return compare(ordInt)(0)($foreign.ordArrayImpl(toDelta)(xs)(ys));
              };
          };
      })());
  };

  /**
 *  | Clamp a value between a minimum and a maximum. For example:
 *  |
 *  | ``` purescript
 *  | let f = clamp 0 10
 *  | f (-5) == 0
 *  | f 5    == 5
 *  | f 15   == 10
 *  | ```
 */  
  var clamp = function (dictOrd) {
      return function (low) {
          return function (hi) {
              return function (x) {
                  return min(dictOrd)(hi)(max(dictOrd)(low)(x));
              };
          };
      };
  };

  /**
 *  | Test whether a value is between a minimum and a maximum (inclusive).
 *  | For example:
 *  |
 *  | ``` purescript
 *  | let f = between 0 10
 *  | f 0    == true
 *  | f (-5) == false
 *  | f 5    == true
 *  | f 10   == true
 *  | f 15   == false
 *  | ```
 */  
  var between = function (dictOrd) {
      return function (low) {
          return function (hi) {
              return function (x) {
                  if (lessThan(dictOrd)(x)(low)) {
                      return false;
                  };
                  if (greaterThan(dictOrd)(x)(hi)) {
                      return false;
                  };
                  if (true) {
                      return true;
                  };
                  throw new Error("Failed pattern match at Data.Ord line 150, column 1 - line 153, column 16: " + [ low.constructor.name, hi.constructor.name, x.constructor.name ]);
              };
          };
      };
  };

  /**
 *  | The absolute value function. `abs x` is defined as `if x >= zero then x
 *  | else negate x`.
 */  
  var abs = function (dictOrd) {
      return function (dictRing) {
          return function (x) {
              var $33 = greaterThanOrEq(dictOrd)(x)(Data_Semiring.zero(dictRing["__superclass_Data.Semiring.Semiring_0"]()));
              if ($33) {
                  return x;
              };
              if (!$33) {
                  return Data_Ring.negate(dictRing)(x);
              };
              throw new Error("Failed pattern match at Data.Ord line 158, column 9 - line 158, column 42: " + [ $33.constructor.name ]);
          };
      };
  };
  exports["Ord"] = Ord;
  exports["abs"] = abs;
  exports["between"] = between;
  exports["clamp"] = clamp;
  exports["compare"] = compare;
  exports["comparing"] = comparing;
  exports["greaterThan"] = greaterThan;
  exports["greaterThanOrEq"] = greaterThanOrEq;
  exports["lessThan"] = lessThan;
  exports["lessThanOrEq"] = lessThanOrEq;
  exports["max"] = max;
  exports["min"] = min;
  exports["signum"] = signum;
  exports["ordBoolean"] = ordBoolean;
  exports["ordInt"] = ordInt;
  exports["ordNumber"] = ordNumber;
  exports["ordString"] = ordString;
  exports["ordChar"] = ordChar;
  exports["ordUnit"] = ordUnit;
  exports["ordVoid"] = ordVoid;
  exports["ordArray"] = ordArray;
  exports["ordOrdering"] = ordOrdering;
})(PS["Data.Ord"] = PS["Data.Ord"] || {});
(function(exports) {
    "use strict";

  exports.topInt = 2147483647;
  exports.bottomInt = -2147483648;

  exports.topChar = String.fromCharCode(65535);
  exports.bottomChar = String.fromCharCode(0);
})(PS["Data.Bounded"] = PS["Data.Bounded"] || {});
(function(exports) {
    "use strict";
  var $foreign = PS["Data.Bounded"];
  var Data_Ord = PS["Data.Ord"];
  var Data_Unit = PS["Data.Unit"];
  var Data_Ordering = PS["Data.Ordering"];        

  /**
 *  | The `Bounded` type class represents totally ordered types that have an
 *  | upper and lower boundary.
 *  |
 *  | Instances should satisfy the following law in addition to the `Ord` laws:
 *  |
 *  | - Bounded: `bottom <= a <= top`
 */  
  var Bounded = function (__superclass_Data$dotOrd$dotOrd_0, bottom, top) {
      this["__superclass_Data.Ord.Ord_0"] = __superclass_Data$dotOrd$dotOrd_0;
      this.bottom = bottom;
      this.top = top;
  };

  /**
 *  | The `Bounded` type class represents totally ordered types that have an
 *  | upper and lower boundary.
 *  |
 *  | Instances should satisfy the following law in addition to the `Ord` laws:
 *  |
 *  | - Bounded: `bottom <= a <= top`
 */  
  var top = function (dict) {
      return dict.top;
  };
  var boundedUnit = new Bounded(function () {
      return Data_Ord.ordUnit;
  }, Data_Unit.unit, Data_Unit.unit);
  var boundedOrdering = new Bounded(function () {
      return Data_Ord.ordOrdering;
  }, Data_Ordering.LT.value, Data_Ordering.GT.value);
  var boundedInt = new Bounded(function () {
      return Data_Ord.ordInt;
  }, $foreign.bottomInt, $foreign.topInt);

  /**
 *  | Characters fall within the Unicode range.
 */  
  var boundedChar = new Bounded(function () {
      return Data_Ord.ordChar;
  }, $foreign.bottomChar, $foreign.topChar);
  var boundedBoolean = new Bounded(function () {
      return Data_Ord.ordBoolean;
  }, false, true);

  /**
 *  | The `Bounded` type class represents totally ordered types that have an
 *  | upper and lower boundary.
 *  |
 *  | Instances should satisfy the following law in addition to the `Ord` laws:
 *  |
 *  | - Bounded: `bottom <= a <= top`
 */  
  var bottom = function (dict) {
      return dict.bottom;
  };
  exports["Bounded"] = Bounded;
  exports["bottom"] = bottom;
  exports["top"] = top;
  exports["boundedBoolean"] = boundedBoolean;
  exports["boundedInt"] = boundedInt;
  exports["boundedChar"] = boundedChar;
  exports["boundedOrdering"] = boundedOrdering;
  exports["boundedUnit"] = boundedUnit;
})(PS["Data.Bounded"] = PS["Data.Bounded"] || {});
(function(exports) {
    "use strict";
  var Prelude = PS["Prelude"];
  var Control_Alt = PS["Control.Alt"];
  var Control_Alternative = PS["Control.Alternative"];
  var Control_Extend = PS["Control.Extend"];
  var Control_MonadZero = PS["Control.MonadZero"];
  var Control_Plus = PS["Control.Plus"];
  var Data_Functor_Invariant = PS["Data.Functor.Invariant"];
  var Data_Monoid = PS["Data.Monoid"];
  var Data_Functor = PS["Data.Functor"];
  var Control_Apply = PS["Control.Apply"];
  var Control_Applicative = PS["Control.Applicative"];
  var Control_Bind = PS["Control.Bind"];
  var Control_Monad = PS["Control.Monad"];
  var Data_Semigroup = PS["Data.Semigroup"];
  var Data_Eq = PS["Data.Eq"];
  var Data_Ord = PS["Data.Ord"];
  var Data_Ordering = PS["Data.Ordering"];
  var Data_Bounded = PS["Data.Bounded"];
  var Data_Show = PS["Data.Show"];
  var Data_Unit = PS["Data.Unit"];
  var Data_Function = PS["Data.Function"];
  var Control_Category = PS["Control.Category"];        

  /**
 *  | The `Maybe` type is used to represent optional values and can be seen as
 *  | something like a type-safe `null`, where `Nothing` is `null` and `Just x`
 *  | is the non-null value `x`.
 */  
  var Nothing = (function () {
      function Nothing() {

      };
      Nothing.value = new Nothing();
      return Nothing;
  })();

  /**
 *  | The `Maybe` type is used to represent optional values and can be seen as
 *  | something like a type-safe `null`, where `Nothing` is `null` and `Just x`
 *  | is the non-null value `x`.
 */  
  var Just = (function () {
      function Just(value0) {
          this.value0 = value0;
      };
      Just.create = function (value0) {
          return new Just(value0);
      };
      return Just;
  })();

  /**
 *  | The `Show` instance allows `Maybe` values to be rendered as a string with
 *  | `show` whenever there is an `Show` instance for the type the `Maybe`
 *  | contains.
 */  
  var showMaybe = function (dictShow) {
      return new Data_Show.Show(function (v) {
          if (v instanceof Just) {
              return "(Just " + (Data_Show.show(dictShow)(v.value0) + ")");
          };
          if (v instanceof Nothing) {
              return "Nothing";
          };
          throw new Error("Failed pattern match at Data.Maybe line 202, column 3 - line 203, column 3: " + [ v.constructor.name ]);
      });
  };

  /**
 *  | The `Semigroup` instance enables use of the operator `<>` on `Maybe` values
 *  | whenever there is a `Semigroup` instance for the type the `Maybe` contains.
 *  | The exact behaviour of `<>` depends on the "inner" `Semigroup` instance,
 *  | but generally captures the notion of appending or combining things.
 *  |
 *  | ``` purescript
 *  | Just x <> Just y = Just (x <> y)
 *  | Just x <> Nothing = Just x
 *  | Nothing <> Just y = Just y
 *  | Nothing <> Nothing = Nothing
 *  | ```
 */  
  var semigroupMaybe = function (dictSemigroup) {
      return new Data_Semigroup.Semigroup(function (v) {
          return function (v1) {
              if (v instanceof Nothing) {
                  return v1;
              };
              if (v1 instanceof Nothing) {
                  return v;
              };
              if (v instanceof Just && v1 instanceof Just) {
                  return new Just(Data_Semigroup.append(dictSemigroup)(v.value0)(v1.value0));
              };
              throw new Error("Failed pattern match at Data.Maybe line 175, column 3 - line 175, column 23: " + [ v.constructor.name, v1.constructor.name ]);
          };
      });
  };
  var monoidMaybe = function (dictSemigroup) {
      return new Data_Monoid.Monoid(function () {
          return semigroupMaybe(dictSemigroup);
      }, Nothing.value);
  };

  /**
 *  | Similar to `maybe` but for use in cases where the default value may be
 *  | expensive to compute. As PureScript is not lazy, the standard `maybe` has
 *  | to evaluate the default value before returning the result, whereas here
 *  | the value is only computed when the `Maybe` is known to be `Nothing`.
 *  |
 *  | ``` purescript
 *  | maybe' (\_ -> x) f Nothing == x
 *  | maybe' (\_ -> x) f (Just y) == f y
 *  | ```
 */  
  var maybe$prime = function (v) {
      return function (v1) {
          return function (v2) {
              if (v2 instanceof Nothing) {
                  return v(Data_Unit.unit);
              };
              if (v2 instanceof Just) {
                  return v1(v2.value0);
              };
              throw new Error("Failed pattern match at Data.Maybe line 227, column 1 - line 227, column 28: " + [ v.constructor.name, v1.constructor.name, v2.constructor.name ]);
          };
      };
  };

  /**
 *  | Takes a default value, a function, and a `Maybe` value. If the `Maybe`
 *  | value is `Nothing` the default value is returned, otherwise the function
 *  | is applied to the value inside the `Just` and the result is returned.
 *  |
 *  | ``` purescript
 *  | maybe x f Nothing == x
 *  | maybe x f (Just y) == f y
 *  | ```
 */  
  var maybe = function (v) {
      return function (v1) {
          return function (v2) {
              if (v2 instanceof Nothing) {
                  return v;
              };
              if (v2 instanceof Just) {
                  return v1(v2.value0);
              };
              throw new Error("Failed pattern match at Data.Maybe line 214, column 1 - line 214, column 22: " + [ v.constructor.name, v1.constructor.name, v2.constructor.name ]);
          };
      };
  };

  /**
 *  | Returns `true` when the `Maybe` value is `Nothing`.
 */  
  var isNothing = maybe(true)(Data_Function["const"](false));

  /**
 *  | Returns `true` when the `Maybe` value was constructed with `Just`.
 */  
  var isJust = maybe(false)(Data_Function["const"](true));

  /**
 *  | The `Functor` instance allows functions to transform the contents of a
 *  | `Just` with the `<$>` operator:
 *  |
 *  | ``` purescript
 *  | f <$> Just x == Just (f x)
 *  | ```
 *  |
 *  | `Nothing` values are left untouched:
 *  |
 *  | ``` purescript
 *  | f <$> Nothing == Nothing
 *  | ```
 */  
  var functorMaybe = new Data_Functor.Functor(function (v) {
      return function (v1) {
          if (v1 instanceof Just) {
              return new Just(v(v1.value0));
          };
          return Nothing.value;
      };
  });
  var invariantMaybe = new Data_Functor_Invariant.Invariant(Data_Functor_Invariant.imapF(functorMaybe));

  /**
 *  | Similar to `fromMaybe` but for use in cases where the default value may be
 *  | expensive to compute. As PureScript is not lazy, the standard `fromMaybe`
 *  | has to evaluate the default value before returning the result, whereas here
 *  | the value is only computed when the `Maybe` is known to be `Nothing`.
 *  |
 *  | ``` purescript
 *  | fromMaybe' (\_ -> x) Nothing == x
 *  | fromMaybe' (\_ -> x) (Just y) == y
 *  | ```
 */  
  var fromMaybe$prime = function (a) {
      return maybe$prime(a)(Control_Category.id(Control_Category.categoryFn));
  };

  /**
 *  | Takes a default value, and a `Maybe` value. If the `Maybe` value is
 *  | `Nothing` the default value is returned, otherwise the value inside the
 *  | `Just` is returned.
 *  |
 *  | ``` purescript
 *  | fromMaybe x Nothing == x
 *  | fromMaybe x (Just y) == y
 *  | ```
 */  
  var fromMaybe = function (a) {
      return maybe(a)(Control_Category.id(Control_Category.categoryFn));
  };

  /**
 *  | A partial function that extracts the value from the `Just` data
 *  | constructor. Passing `Nothing` to `fromJust` will throw an error at
 *  | runtime.
 */  
  var fromJust = function (dictPartial) {
      return function (v) {
          var __unused = function (dictPartial1) {
              return function ($dollar33) {
                  return $dollar33;
              };
          };
          return __unused(dictPartial)((function () {
              if (v instanceof Just) {
                  return v.value0;
              };
              throw new Error("Failed pattern match at Data.Maybe line 265, column 1 - line 265, column 21: " + [ v.constructor.name ]);
          })());
      };
  };

  /**
 *  | The `Extend` instance allows sequencing of `Maybe` values and functions
 *  | that accept a `Maybe a` and return a non-`Maybe` result using the
 *  | `<<=` operator.
 *  |
 *  | ``` purescript
 *  | f <<= Nothing = Nothing
 *  | f <<= Just x = Just (f x)
 *  | ```
 */  
  var extendMaybe = new Control_Extend.Extend(function () {
      return functorMaybe;
  }, function (v) {
      return function (v1) {
          if (v1 instanceof Nothing) {
              return Nothing.value;
          };
          return new Just(v(v1));
      };
  });

  /**
 *  | The `Eq` instance allows `Maybe` values to be checked for equality with
 *  | `==` and inequality with `/=` whenever there is an `Eq` instance for the
 *  | type the `Maybe` contains.
 */  
  var eqMaybe = function (dictEq) {
      return new Data_Eq.Eq(function (x) {
          return function (y) {
              if (x instanceof Nothing && y instanceof Nothing) {
                  return true;
              };
              if (x instanceof Just && y instanceof Just) {
                  return Data_Eq.eq(dictEq)(x.value0)(y.value0);
              };
              return false;
          };
      });
  };

  /**
 *  | The `Ord` instance allows `Maybe` values to be compared with
 *  | `compare`, `>`, `>=`, `<` and `<=` whenever there is an `Ord` instance for
 *  | the type the `Maybe` contains.
 *  |
 *  | `Nothing` is considered to be less than any `Just` value.
 */  
  var ordMaybe = function (dictOrd) {
      return new Data_Ord.Ord(function () {
          return eqMaybe(dictOrd["__superclass_Data.Eq.Eq_0"]());
      }, function (x) {
          return function (y) {
              if (x instanceof Nothing && y instanceof Nothing) {
                  return Data_Ordering.EQ.value;
              };
              if (x instanceof Nothing) {
                  return Data_Ordering.LT.value;
              };
              if (y instanceof Nothing) {
                  return Data_Ordering.GT.value;
              };
              if (x instanceof Just && y instanceof Just) {
                  return Data_Ord.compare(dictOrd)(x.value0)(y.value0);
              };
              throw new Error("Failed pattern match at Data.Maybe line 192, column 1 - line 192, column 51: " + [ x.constructor.name, y.constructor.name ]);
          };
      });
  };
  var boundedMaybe = function (dictBounded) {
      return new Data_Bounded.Bounded(function () {
          return ordMaybe(dictBounded["__superclass_Data.Ord.Ord_0"]());
      }, Nothing.value, new Just(Data_Bounded.top(dictBounded)));
  };

  /**
 *  | The `Apply` instance allows functions contained within a `Just` to
 *  | transform a value contained within a `Just` using the `apply` operator:
 *  |
 *  | ``` purescript
 *  | Just f <*> Just x == Just (f x)
 *  | ```
 *  |
 *  | `Nothing` values are left untouched:
 *  |
 *  | ``` purescript
 *  | Just f <*> Nothing == Nothing
 *  | Nothing <*> Just x == Nothing
 *  | ```
 *  |
 *  | Combining `Functor`'s `<$>` with `Apply`'s `<*>` can be used transform a
 *  | pure function to take `Maybe`-typed arguments so `f :: a -> b -> c`
 *  | becomes `f :: Maybe a -> Maybe b -> Maybe c`:
 *  |
 *  | ``` purescript
 *  | f <$> Just x <*> Just y == Just (f x y)
 *  | ```
 *  |
 *  | The `Nothing`-preserving behaviour of both operators means the result of
 *  | an expression like the above but where any one of the values is `Nothing`
 *  | means the whole result becomes `Nothing` also:
 *  |
 *  | ``` purescript
 *  | f <$> Nothing <*> Just y == Nothing
 *  | f <$> Just x <*> Nothing == Nothing
 *  | f <$> Nothing <*> Nothing == Nothing
 *  | ```
 */  
  var applyMaybe = new Control_Apply.Apply(function () {
      return functorMaybe;
  }, function (v) {
      return function (v1) {
          if (v instanceof Just) {
              return Data_Functor.map(functorMaybe)(v.value0)(v1);
          };
          if (v instanceof Nothing) {
              return Nothing.value;
          };
          throw new Error("Failed pattern match at Data.Maybe line 67, column 3 - line 67, column 31: " + [ v.constructor.name, v1.constructor.name ]);
      };
  });

  /**
 *  | The `Bind` instance allows sequencing of `Maybe` values and functions that
 *  | return a `Maybe` by using the `>>=` operator:
 *  |
 *  | ``` purescript
 *  | Just x >>= f = f x
 *  | Nothing >>= f = Nothing
 *  | ```
 */  
  var bindMaybe = new Control_Bind.Bind(function () {
      return applyMaybe;
  }, function (v) {
      return function (v1) {
          if (v instanceof Just) {
              return v1(v.value0);
          };
          if (v instanceof Nothing) {
              return Nothing.value;
          };
          throw new Error("Failed pattern match at Data.Maybe line 126, column 3 - line 126, column 24: " + [ v.constructor.name, v1.constructor.name ]);
      };
  });

  /**
 *  | The `Applicative` instance enables lifting of values into `Maybe` with the
 *  | `pure` or `return` function (`return` is an alias for `pure`):
 *  |
 *  | ``` purescript
 *  | pure x :: Maybe _ == Just x
 *  | return x :: Maybe _ == Just x
 *  | ```
 *  |
 *  | Combining `Functor`'s `<$>` with `Apply`'s `<*>` and `Applicative`'s
 *  | `pure` can be used to pass a mixture of `Maybe` and non-`Maybe` typed
 *  | values to a function that does not usually expect them, by using `pure`
 *  | for any value that is not already `Maybe` typed:
 *  |
 *  | ``` purescript
 *  | f <$> Just x <*> pure y == Just (f x y)
 *  | ```
 *  |
 *  | Even though `pure = Just` it is recommended to use `pure` in situations
 *  | like this as it allows the choice of `Applicative` to be changed later
 *  | without having to go through and replace `Just` with a new constructor.
 */  
  var applicativeMaybe = new Control_Applicative.Applicative(function () {
      return applyMaybe;
  }, Just.create);

  /**
 *  | The `Monad` instance guarantees that there are both `Applicative` and
 *  | `Bind` instances for `Maybe`. This also enables the `do` syntactic sugar:
 *  |
 *  | ``` purescript
 *  | do
 *  |   x' <- x
 *  |   y' <- y
 *  |   pure (f x' y')
 *  | ```
 *  |
 *  | Which is equivalent to:
 *  |
 *  | ``` purescript
 *  | x >>= (\x' -> y >>= (\y' -> pure (f x' y')))
 *  | ```
 */  
  var monadMaybe = new Control_Monad.Monad(function () {
      return applicativeMaybe;
  }, function () {
      return bindMaybe;
  });

  /**
 *  | The `Alt` instance allows for a choice to be made between two `Maybe`
 *  | values with the `<|>` operator, where the first `Just` encountered
 *  | is taken.
 *  |
 *  | ``` purescript
 *  | Just x <|> Just y == Just x
 *  | Nothing <|> Just y == Just y
 *  | Nothing <|> Nothing == Nothing
 *  | ```
 */  
  var altMaybe = new Control_Alt.Alt(function () {
      return functorMaybe;
  }, function (v) {
      return function (v1) {
          if (v instanceof Nothing) {
              return v1;
          };
          return v;
      };
  });

  /**
 *  | The `Plus` instance provides a default `Maybe` value:
 *  |
 *  | ``` purescript
 *  | empty :: Maybe _ == Nothing
 *  | ```
 */  
  var plusMaybe = new Control_Plus.Plus(function () {
      return altMaybe;
  }, Nothing.value);

  /**
 *  | The `Alternative` instance guarantees that there are both `Applicative` and
 *  | `Plus` instances for `Maybe`.
 */  
  var alternativeMaybe = new Control_Alternative.Alternative(function () {
      return applicativeMaybe;
  }, function () {
      return plusMaybe;
  });
  var monadZeroMaybe = new Control_MonadZero.MonadZero(function () {
      return alternativeMaybe;
  }, function () {
      return monadMaybe;
  });
  exports["Nothing"] = Nothing;
  exports["Just"] = Just;
  exports["fromJust"] = fromJust;
  exports["fromMaybe"] = fromMaybe;
  exports["fromMaybe'"] = fromMaybe$prime;
  exports["isJust"] = isJust;
  exports["isNothing"] = isNothing;
  exports["maybe"] = maybe;
  exports["maybe'"] = maybe$prime;
  exports["functorMaybe"] = functorMaybe;
  exports["applyMaybe"] = applyMaybe;
  exports["applicativeMaybe"] = applicativeMaybe;
  exports["altMaybe"] = altMaybe;
  exports["plusMaybe"] = plusMaybe;
  exports["alternativeMaybe"] = alternativeMaybe;
  exports["bindMaybe"] = bindMaybe;
  exports["monadMaybe"] = monadMaybe;
  exports["monadZeroMaybe"] = monadZeroMaybe;
  exports["extendMaybe"] = extendMaybe;
  exports["invariantMaybe"] = invariantMaybe;
  exports["semigroupMaybe"] = semigroupMaybe;
  exports["monoidMaybe"] = monoidMaybe;
  exports["eqMaybe"] = eqMaybe;
  exports["ordMaybe"] = ordMaybe;
  exports["boundedMaybe"] = boundedMaybe;
  exports["showMaybe"] = showMaybe;
})(PS["Data.Maybe"] = PS["Data.Maybe"] || {});
(function(exports) {
    "use strict";
  var Prelude = PS["Prelude"];
  var Control_Semigroupoid = PS["Control.Semigroupoid"];
  var Data_Functor = PS["Data.Functor"];        

  /**
 *  | A type class for `newtype`s to enable convenient wrapping and unwrapping,
 *  | and the use of the other functions in this module.
 *  |
 *  | The compiler can derive instances of `Newtype` automatically:
 *  |
 *  | ``` purescript
 *  | newtype EmailAddress = EmailAddress String
 *  |
 *  | derive instance newtypeEmailAddress :: Newtype EmailAddress _
 *  | ```
 *  |
 *  | Note that deriving for `Newtype` instances requires that the type be
 *  | defined as `newtype` rather than `data` declaration (even if the `data`
 *  | structurally fits the rules of a `newtype`), and the use of a wildcard for
 *  | the wrapped type.
 */  
  var Newtype = function (unwrap, wrap) {
      this.unwrap = unwrap;
      this.wrap = wrap;
  };

  /**
 *  | A type class for `newtype`s to enable convenient wrapping and unwrapping,
 *  | and the use of the other functions in this module.
 *  |
 *  | The compiler can derive instances of `Newtype` automatically:
 *  |
 *  | ``` purescript
 *  | newtype EmailAddress = EmailAddress String
 *  |
 *  | derive instance newtypeEmailAddress :: Newtype EmailAddress _
 *  | ```
 *  |
 *  | Note that deriving for `Newtype` instances requires that the type be
 *  | defined as `newtype` rather than `data` declaration (even if the `data`
 *  | structurally fits the rules of a `newtype`), and the use of a wildcard for
 *  | the wrapped type.
 */  
  var wrap = function (dict) {
      return dict.wrap;
  };

  /**
 *  | A type class for `newtype`s to enable convenient wrapping and unwrapping,
 *  | and the use of the other functions in this module.
 *  |
 *  | The compiler can derive instances of `Newtype` automatically:
 *  |
 *  | ``` purescript
 *  | newtype EmailAddress = EmailAddress String
 *  |
 *  | derive instance newtypeEmailAddress :: Newtype EmailAddress _
 *  | ```
 *  |
 *  | Note that deriving for `Newtype` instances requires that the type be
 *  | defined as `newtype` rather than `data` declaration (even if the `data`
 *  | structurally fits the rules of a `newtype`), and the use of a wildcard for
 *  | the wrapped type.
 */  
  var unwrap = function (dict) {
      return dict.unwrap;
  };

  /**
 *  | Much like `under`, but where the lifted function operates on values in a
 *  | `Functor`:
 *  |
 *  | ``` purescript
 *  | newtype EmailAddress = EmailAddress String
 *  | derive instance newtypeEmailAddress :: Newtype EmailAddress _
 *  |
 *  | isValid :: EmailAddress -> Boolean
 *  | isValid x = false -- imagine a slightly less strict predicate here
 *  |
 *  | findValidEmailString :: Array String -> Maybe String
 *  | findValidEmailString = underF EmailAddress (Foldable.find isValid)
 *  | ```
 *  |
 *  | The above example also demonstrates that the functor type is polymorphic
 *  | here too, the input is an `Array` but the result is a `Maybe`.
 */  
  var underF = function (dictFunctor) {
      return function (dictFunctor1) {
          return function (dictNewtype) {
              return function (dictNewtype1) {
                  return function (v) {
                      return function (f) {
                          return function ($27) {
                              return Data_Functor.map(dictFunctor1)(unwrap(dictNewtype1))(f(Data_Functor.map(dictFunctor)(wrap(dictNewtype))($27)));
                          };
                      };
                  };
              };
          };
      };
  };

  /**
 *  | The opposite of `over`: lowers a function that operates on `Newtype`d
 *  | values to operate on the wrapped value instead.
 *  |
 *  | ``` purescript
 *  | newtype Degrees = Degrees Number
 *  | derive instance newtypeDegrees :: Newtype Degrees _
 *  |
 *  | newtype NormalDegrees = NormalDegrees Number
 *  | derive instance newtypeNormalDegrees :: Newtype NormalDegrees _
 *  |
 *  | normaliseDegrees :: Degrees -> NormalDegrees
 *  | normaliseDegrees (Degrees deg) = NormalDegrees (deg `mod` 360.0)
 *  |
 *  | asNormalDegrees :: Number -> Number
 *  | asNormalDegrees = under Degrees normaliseDegrees
 *  | ```
 *  |
 *  | As with `over` the `Newtype` is polymorphic, as illustrated in the example
 *  | above - both `Degrees` and `NormalDegrees` are instances of `Newtype`,
 *  | so even though `normaliseDegrees` changes the result type we can still put
 *  | a `Number` in and get a `Number` out via `under`.
 */  
  var under = function (dictNewtype) {
      return function (dictNewtype1) {
          return function (v) {
              return function (f) {
                  return function ($28) {
                      return unwrap(dictNewtype1)(f(wrap(dictNewtype)($28)));
                  };
              };
          };
      };
  };

  /**
 *  | Much like `over`, but where the lifted function operates on values in a
 *  | `Functor`:
 *  |
 *  | ``` purescript
 *  | findLabel :: String -> Array Label -> Maybe Label
 *  | findLabel s = overF Label (Foldable.find (_ == s))
 *  | ```
 *  |
 *  | The above example also demonstrates that the functor type is polymorphic
 *  | here too, the input is an `Array` but the result is a `Maybe`.
 */  
  var overF = function (dictFunctor) {
      return function (dictFunctor1) {
          return function (dictNewtype) {
              return function (dictNewtype1) {
                  return function (v) {
                      return function (f) {
                          return function ($29) {
                              return Data_Functor.map(dictFunctor1)(wrap(dictNewtype1))(f(Data_Functor.map(dictFunctor)(unwrap(dictNewtype))($29)));
                          };
                      };
                  };
              };
          };
      };
  };

  /**
 *  | Lifts a function operate over newtypes. This can be used to lift a
 *  | function to manipulate the contents of a single newtype, somewhat like
 *  | `map` does for a `Functor`:
 *  |
 *  | ``` purescript
 *  | newtype Label = Label String
 *  | derive instance newtypeLabel :: Newtype Label _
 *  |
 *  | toUpperLabel :: Label -> Label
 *  | toUpperLabel = over Label String.toUpper
 *  | ```
 *  |
 *  | But the result newtype is polymorphic, meaning the result can be returned
 *  | as an alternative newtype:
 *  |
 *  | `` purescript
 *  | newtype UppercaseLabel = UppercaseLabel String
 *  | derive instance newtypeUppercaseLabel :: Newtype UppercaseLabel _
 *  |
 *  | toUpperLabel' :: Label -> UppercaseLabel
 *  | toUpperLabel' = over Label String.toUpper
 *  | ```
 */  
  var over = function (dictNewtype) {
      return function (dictNewtype1) {
          return function (v) {
              return function (f) {
                  return function ($30) {
                      return wrap(dictNewtype1)(f(unwrap(dictNewtype)($30)));
                  };
              };
          };
      };
  };

  /**
 *  | Given a constructor for a `Newtype`, this returns the appropriate `unwrap`
 *  | function.
 */  
  var op = function (dictNewtype) {
      return function (v) {
          return unwrap(dictNewtype);
      };
  };

  /**
 *  | Similar to `ala` but useful for cases where you want to use an additional
 *  | projection with the higher order function:
 *  |
 *  | ``` purescript
 *  | alaF Additive foldMap String.length ["hello", "world"] -- 10
 *  | alaF Multiplicative foldMap Math.abs [1.0, -2.0, 3.0, -4.0] -- 24.0
 *  | ```
 *  |
 *  | The type admits other possibilities due to the polymorphic `Functor`
 *  | constraints, but the case described above works because ((->) a) is a
 *  | `Functor`.
 */  
  var alaF = function (dictFunctor) {
      return function (dictFunctor1) {
          return function (dictNewtype) {
              return function (dictNewtype1) {
                  return function (v) {
                      return function (f) {
                          return function ($31) {
                              return Data_Functor.map(dictFunctor1)(unwrap(dictNewtype1))(f(Data_Functor.map(dictFunctor)(wrap(dictNewtype))($31)));
                          };
                      };
                  };
              };
          };
      };
  };

  /**
 *  | This combinator is for when you have a higher order function that you want
 *  | to use in the context of some newtype - `foldMap` being a common example:
 *  |
 *  | ``` purescript
 *  | ala Additive foldMap [1,2,3,4] -- 10
 *  | ala Multiplicative foldMap [1,2,3,4] -- 24
 *  | ala Conj foldMap [true, false] -- false
 *  | ala Disj foldMap [true, false] -- true
 *  | ```
 */  
  var ala = function (dictFunctor) {
      return function (dictNewtype) {
          return function (dictNewtype1) {
              return function (v) {
                  return function (f) {
                      return Data_Functor.map(dictFunctor)(unwrap(dictNewtype))(f(wrap(dictNewtype1)));
                  };
              };
          };
      };
  };
  exports["Newtype"] = Newtype;
  exports["ala"] = ala;
  exports["alaF"] = alaF;
  exports["op"] = op;
  exports["over"] = over;
  exports["overF"] = overF;
  exports["under"] = under;
  exports["underF"] = underF;
  exports["unwrap"] = unwrap;
  exports["wrap"] = wrap;
})(PS["Data.Newtype"] = PS["Data.Newtype"] || {});
(function(exports) {
    "use strict";
  var Prelude = PS["Prelude"];
  var Control_Extend = PS["Control.Extend"];
  var Data_Functor_Invariant = PS["Data.Functor.Invariant"];
  var Data_Maybe = PS["Data.Maybe"];
  var Data_Monoid = PS["Data.Monoid"];
  var Data_Newtype = PS["Data.Newtype"];
  var Data_Eq = PS["Data.Eq"];
  var Data_Ord = PS["Data.Ord"];
  var Data_Bounded = PS["Data.Bounded"];
  var Data_Functor = PS["Data.Functor"];
  var Control_Apply = PS["Control.Apply"];
  var Control_Applicative = PS["Control.Applicative"];
  var Control_Bind = PS["Control.Bind"];
  var Control_Monad = PS["Control.Monad"];
  var Data_Show = PS["Data.Show"];
  var Data_Semigroup = PS["Data.Semigroup"];        

  /**
 *  | Monoid returning the first (left-most) non-`Nothing` value.
 *  |
 *  | ``` purescript
 *  | First (Just x) <> First (Just y) == First (Just x)
 *  | First Nothing <> First (Just y) == First (Just y)
 *  | First Nothing <> Nothing == First Nothing
 *  | mempty :: First _ == First Nothing
 *  | ```
 */  
  var First = function (x) {
      return x;
  };
  var showFirst = function (dictShow) {
      return new Data_Show.Show(function (v) {
          return "First (" + (Data_Show.show(Data_Maybe.showMaybe(dictShow))(v) + ")");
      });
  };
  var semigroupFirst = new Data_Semigroup.Semigroup(function (v) {
      return function (v1) {
          if (v instanceof Data_Maybe.Just) {
              return v;
          };
          return v1;
      };
  });
  var ordFirst = function (dictOrd) {
      return Data_Maybe.ordMaybe(dictOrd);
  };
  var newtypeFirst = new Data_Newtype.Newtype(function (n) {
      return n;
  }, First);
  var monoidFirst = new Data_Monoid.Monoid(function () {
      return semigroupFirst;
  }, Data_Maybe.Nothing.value);
  var monadFirst = Data_Maybe.monadMaybe;
  var invariantFirst = Data_Maybe.invariantMaybe;
  var functorFirst = Data_Maybe.functorMaybe;
  var extendFirst = Data_Maybe.extendMaybe;
  var eqFirst = function (dictEq) {
      return Data_Maybe.eqMaybe(dictEq);
  };
  var boundedFirst = function (dictBounded) {
      return Data_Maybe.boundedMaybe(dictBounded);
  };
  var bindFirst = Data_Maybe.bindMaybe;
  var applyFirst = Data_Maybe.applyMaybe;
  var applicativeFirst = Data_Maybe.applicativeMaybe;
  exports["First"] = First;
  exports["newtypeFirst"] = newtypeFirst;
  exports["eqFirst"] = eqFirst;
  exports["ordFirst"] = ordFirst;
  exports["boundedFirst"] = boundedFirst;
  exports["functorFirst"] = functorFirst;
  exports["invariantFirst"] = invariantFirst;
  exports["applyFirst"] = applyFirst;
  exports["applicativeFirst"] = applicativeFirst;
  exports["bindFirst"] = bindFirst;
  exports["monadFirst"] = monadFirst;
  exports["extendFirst"] = extendFirst;
  exports["showFirst"] = showFirst;
  exports["semigroupFirst"] = semigroupFirst;
  exports["monoidFirst"] = monoidFirst;
})(PS["Data.Maybe.First"] = PS["Data.Maybe.First"] || {});
(function(exports) {
    "use strict";
  var Prelude = PS["Prelude"];
  var Control_Extend = PS["Control.Extend"];
  var Data_Functor_Invariant = PS["Data.Functor.Invariant"];
  var Data_Maybe = PS["Data.Maybe"];
  var Data_Monoid = PS["Data.Monoid"];
  var Data_Newtype = PS["Data.Newtype"];
  var Data_Eq = PS["Data.Eq"];
  var Data_Ord = PS["Data.Ord"];
  var Data_Bounded = PS["Data.Bounded"];
  var Data_Functor = PS["Data.Functor"];
  var Control_Apply = PS["Control.Apply"];
  var Control_Applicative = PS["Control.Applicative"];
  var Control_Bind = PS["Control.Bind"];
  var Control_Monad = PS["Control.Monad"];
  var Data_Show = PS["Data.Show"];
  var Data_Semigroup = PS["Data.Semigroup"];        

  /**
 *  | Monoid returning the last (right-most) non-`Nothing` value.
 *  |
 *  | ``` purescript
 *  | Last (Just x) <> Last (Just y) == Last (Just y)
 *  | Last (Just x) <> Nothing == Last (Just x)
 *  | Last Nothing <> Nothing == Last Nothing
 *  | mempty :: Last _ == Last Nothing
 *  | ```
 */  
  var Last = function (x) {
      return x;
  };
  var showLast = function (dictShow) {
      return new Data_Show.Show(function (v) {
          return "(Last " + (Data_Show.show(Data_Maybe.showMaybe(dictShow))(v) + ")");
      });
  };
  var semigroupLast = new Data_Semigroup.Semigroup(function (v) {
      return function (v1) {
          if (v1 instanceof Data_Maybe.Just) {
              return v1;
          };
          if (v1 instanceof Data_Maybe.Nothing) {
              return v;
          };
          throw new Error("Failed pattern match at Data.Maybe.Last line 48, column 3 - line 48, column 39: " + [ v.constructor.name, v1.constructor.name ]);
      };
  });
  var ordLast = function (dictOrd) {
      return Data_Maybe.ordMaybe(dictOrd);
  };
  var newtypeLast = new Data_Newtype.Newtype(function (n) {
      return n;
  }, Last);
  var monoidLast = new Data_Monoid.Monoid(function () {
      return semigroupLast;
  }, Data_Maybe.Nothing.value);
  var monadLast = Data_Maybe.monadMaybe;
  var invariantLast = Data_Maybe.invariantMaybe;
  var functorLast = Data_Maybe.functorMaybe;
  var extendLast = Data_Maybe.extendMaybe;
  var eqLast = function (dictEq) {
      return Data_Maybe.eqMaybe(dictEq);
  };
  var boundedLast = function (dictBounded) {
      return Data_Maybe.boundedMaybe(dictBounded);
  };
  var bindLast = Data_Maybe.bindMaybe;
  var applyLast = Data_Maybe.applyMaybe;
  var applicativeLast = Data_Maybe.applicativeMaybe;
  exports["Last"] = Last;
  exports["newtypeLast"] = newtypeLast;
  exports["eqLast"] = eqLast;
  exports["ordLast"] = ordLast;
  exports["boundedLast"] = boundedLast;
  exports["functorLast"] = functorLast;
  exports["invariantLast"] = invariantLast;
  exports["applyLast"] = applyLast;
  exports["applicativeLast"] = applicativeLast;
  exports["bindLast"] = bindLast;
  exports["monadLast"] = monadLast;
  exports["extendLast"] = extendLast;
  exports["showLast"] = showLast;
  exports["semigroupLast"] = semigroupLast;
  exports["monoidLast"] = monoidLast;
})(PS["Data.Maybe.Last"] = PS["Data.Maybe.Last"] || {});
(function(exports) {
    "use strict";
  var Prelude = PS["Prelude"];
  var Control_Comonad = PS["Control.Comonad"];
  var Control_Extend = PS["Control.Extend"];
  var Data_Functor_Invariant = PS["Data.Functor.Invariant"];
  var Data_Monoid = PS["Data.Monoid"];
  var Data_Newtype = PS["Data.Newtype"];
  var Data_Eq = PS["Data.Eq"];
  var Data_Ord = PS["Data.Ord"];
  var Data_Bounded = PS["Data.Bounded"];
  var Data_Functor = PS["Data.Functor"];
  var Control_Apply = PS["Control.Apply"];
  var Control_Applicative = PS["Control.Applicative"];
  var Control_Bind = PS["Control.Bind"];
  var Control_Monad = PS["Control.Monad"];
  var Data_Show = PS["Data.Show"];
  var Data_Semigroup = PS["Data.Semigroup"];
  var Data_Semiring = PS["Data.Semiring"];        

  /**
 *  | Monoid and semigroup for semirings under addition.
 *  |
 *  | ``` purescript
 *  | Additive x <> Additive y == Additive (x + y)
 *  | mempty :: Additive _ == Additive zero
 *  | ```
 */  
  var Additive = function (x) {
      return x;
  };
  var showAdditive = function (dictShow) {
      return new Data_Show.Show(function (v) {
          return "(Additive " + (Data_Show.show(dictShow)(v) + ")");
      });
  };
  var semigroupAdditive = function (dictSemiring) {
      return new Data_Semigroup.Semigroup(function (v) {
          return function (v1) {
              return Data_Semiring.add(dictSemiring)(v)(v1);
          };
      });
  };
  var ordAdditive = function (dictOrd) {
      return dictOrd;
  };
  var newtypeAdditive = new Data_Newtype.Newtype(function (n) {
      return n;
  }, Additive);
  var monoidAdditive = function (dictSemiring) {
      return new Data_Monoid.Monoid(function () {
          return semigroupAdditive(dictSemiring);
      }, Data_Semiring.zero(dictSemiring));
  };
  var invariantAdditive = new Data_Functor_Invariant.Invariant(function (f) {
      return function (v) {
          return function (v1) {
              return f(v1);
          };
      };
  });
  var functorAdditive = new Data_Functor.Functor(function (f) {
      return function (v) {
          return f(v);
      };
  });
  var extendAdditive = new Control_Extend.Extend(function () {
      return functorAdditive;
  }, function (f) {
      return function (x) {
          return f(x);
      };
  });
  var eqAdditive = function (dictEq) {
      return dictEq;
  };
  var comonadAdditive = new Control_Comonad.Comonad(function () {
      return extendAdditive;
  }, Data_Newtype.unwrap(newtypeAdditive));
  var boundedAdditive = function (dictBounded) {
      return dictBounded;
  };
  var applyAdditive = new Control_Apply.Apply(function () {
      return functorAdditive;
  }, function (v) {
      return function (v1) {
          return v(v1);
      };
  });
  var bindAdditive = new Control_Bind.Bind(function () {
      return applyAdditive;
  }, function (v) {
      return function (f) {
          return f(v);
      };
  });
  var applicativeAdditive = new Control_Applicative.Applicative(function () {
      return applyAdditive;
  }, Additive);
  var monadAdditive = new Control_Monad.Monad(function () {
      return applicativeAdditive;
  }, function () {
      return bindAdditive;
  });
  exports["Additive"] = Additive;
  exports["newtypeAdditive"] = newtypeAdditive;
  exports["eqAdditive"] = eqAdditive;
  exports["ordAdditive"] = ordAdditive;
  exports["boundedAdditive"] = boundedAdditive;
  exports["functorAdditive"] = functorAdditive;
  exports["invariantAdditive"] = invariantAdditive;
  exports["applyAdditive"] = applyAdditive;
  exports["applicativeAdditive"] = applicativeAdditive;
  exports["bindAdditive"] = bindAdditive;
  exports["monadAdditive"] = monadAdditive;
  exports["extendAdditive"] = extendAdditive;
  exports["comonadAdditive"] = comonadAdditive;
  exports["showAdditive"] = showAdditive;
  exports["semigroupAdditive"] = semigroupAdditive;
  exports["monoidAdditive"] = monoidAdditive;
})(PS["Data.Monoid.Additive"] = PS["Data.Monoid.Additive"] || {});
(function(exports) {
    "use strict";

  exports.boolConj = function (b1) {
    return function (b2) {
      return b1 && b2;
    };
  };

  exports.boolDisj = function (b1) {
    return function (b2) {
      return b1 || b2;
    };
  };

  exports.boolNot = function (b) {
    return !b;
  };
})(PS["Data.HeytingAlgebra"] = PS["Data.HeytingAlgebra"] || {});
(function(exports) {
    "use strict";
  var $foreign = PS["Data.HeytingAlgebra"];
  var Data_Unit = PS["Data.Unit"];        

  /**
 *  | The `HeytingAlgebra` type class represents types are bounded lattices with
 *  | an implication operator such that the following laws hold:
 *  |
 *  | - Associativity:
 *  |   - `a || (b || c) = (a || b) || c`
 *  |   - `a && (b && c) = (a && b) && c`
 *  | - Commutativity:
 *  |   - `a || b = b || a`
 *  |   - `a && b = b && a`
 *  | - Absorption:
 *  |   - `a || (a && b) = a`
 *  |   - `a && (a || b) = a`
 *  | - Idempotent:
 *  |   - `a || a = a`
 *  |   - `a && a = a`
 *  | - Identity:
 *  |   - `a || ff = a`
 *  |   - `a && tt = a`
 *  | - Implication:
 *  |   - ``a `implies` a = tt``
 *  |   - ``a && (a `implies` b) = a && b``
 *  |   - ``b && (a `implies` b) = b``
 *  |   - ``a `implies` (b && c) = (a `implies` b) && (a `implies` c)``
 *  | - Complemented:
 *  |   - ``not a = a `implies` ff``
 */  
  var HeytingAlgebra = function (conj, disj, ff, implies, not, tt) {
      this.conj = conj;
      this.disj = disj;
      this.ff = ff;
      this.implies = implies;
      this.not = not;
      this.tt = tt;
  };

  /**
 *  | The `HeytingAlgebra` type class represents types are bounded lattices with
 *  | an implication operator such that the following laws hold:
 *  |
 *  | - Associativity:
 *  |   - `a || (b || c) = (a || b) || c`
 *  |   - `a && (b && c) = (a && b) && c`
 *  | - Commutativity:
 *  |   - `a || b = b || a`
 *  |   - `a && b = b && a`
 *  | - Absorption:
 *  |   - `a || (a && b) = a`
 *  |   - `a && (a || b) = a`
 *  | - Idempotent:
 *  |   - `a || a = a`
 *  |   - `a && a = a`
 *  | - Identity:
 *  |   - `a || ff = a`
 *  |   - `a && tt = a`
 *  | - Implication:
 *  |   - ``a `implies` a = tt``
 *  |   - ``a && (a `implies` b) = a && b``
 *  |   - ``b && (a `implies` b) = b``
 *  |   - ``a `implies` (b && c) = (a `implies` b) && (a `implies` c)``
 *  | - Complemented:
 *  |   - ``not a = a `implies` ff``
 */  
  var tt = function (dict) {
      return dict.tt;
  };

  /**
 *  | The `HeytingAlgebra` type class represents types are bounded lattices with
 *  | an implication operator such that the following laws hold:
 *  |
 *  | - Associativity:
 *  |   - `a || (b || c) = (a || b) || c`
 *  |   - `a && (b && c) = (a && b) && c`
 *  | - Commutativity:
 *  |   - `a || b = b || a`
 *  |   - `a && b = b && a`
 *  | - Absorption:
 *  |   - `a || (a && b) = a`
 *  |   - `a && (a || b) = a`
 *  | - Idempotent:
 *  |   - `a || a = a`
 *  |   - `a && a = a`
 *  | - Identity:
 *  |   - `a || ff = a`
 *  |   - `a && tt = a`
 *  | - Implication:
 *  |   - ``a `implies` a = tt``
 *  |   - ``a && (a `implies` b) = a && b``
 *  |   - ``b && (a `implies` b) = b``
 *  |   - ``a `implies` (b && c) = (a `implies` b) && (a `implies` c)``
 *  | - Complemented:
 *  |   - ``not a = a `implies` ff``
 */  
  var not = function (dict) {
      return dict.not;
  };

  /**
 *  | The `HeytingAlgebra` type class represents types are bounded lattices with
 *  | an implication operator such that the following laws hold:
 *  |
 *  | - Associativity:
 *  |   - `a || (b || c) = (a || b) || c`
 *  |   - `a && (b && c) = (a && b) && c`
 *  | - Commutativity:
 *  |   - `a || b = b || a`
 *  |   - `a && b = b && a`
 *  | - Absorption:
 *  |   - `a || (a && b) = a`
 *  |   - `a && (a || b) = a`
 *  | - Idempotent:
 *  |   - `a || a = a`
 *  |   - `a && a = a`
 *  | - Identity:
 *  |   - `a || ff = a`
 *  |   - `a && tt = a`
 *  | - Implication:
 *  |   - ``a `implies` a = tt``
 *  |   - ``a && (a `implies` b) = a && b``
 *  |   - ``b && (a `implies` b) = b``
 *  |   - ``a `implies` (b && c) = (a `implies` b) && (a `implies` c)``
 *  | - Complemented:
 *  |   - ``not a = a `implies` ff``
 */  
  var implies = function (dict) {
      return dict.implies;
  };
  var heytingAlgebraUnit = new HeytingAlgebra(function (v) {
      return function (v1) {
          return Data_Unit.unit;
      };
  }, function (v) {
      return function (v1) {
          return Data_Unit.unit;
      };
  }, Data_Unit.unit, function (v) {
      return function (v1) {
          return Data_Unit.unit;
      };
  }, function (v) {
      return Data_Unit.unit;
  }, Data_Unit.unit);

  /**
 *  | The `HeytingAlgebra` type class represents types are bounded lattices with
 *  | an implication operator such that the following laws hold:
 *  |
 *  | - Associativity:
 *  |   - `a || (b || c) = (a || b) || c`
 *  |   - `a && (b && c) = (a && b) && c`
 *  | - Commutativity:
 *  |   - `a || b = b || a`
 *  |   - `a && b = b && a`
 *  | - Absorption:
 *  |   - `a || (a && b) = a`
 *  |   - `a && (a || b) = a`
 *  | - Idempotent:
 *  |   - `a || a = a`
 *  |   - `a && a = a`
 *  | - Identity:
 *  |   - `a || ff = a`
 *  |   - `a && tt = a`
 *  | - Implication:
 *  |   - ``a `implies` a = tt``
 *  |   - ``a && (a `implies` b) = a && b``
 *  |   - ``b && (a `implies` b) = b``
 *  |   - ``a `implies` (b && c) = (a `implies` b) && (a `implies` c)``
 *  | - Complemented:
 *  |   - ``not a = a `implies` ff``
 */  
  var ff = function (dict) {
      return dict.ff;
  };

  /**
 *  | The `HeytingAlgebra` type class represents types are bounded lattices with
 *  | an implication operator such that the following laws hold:
 *  |
 *  | - Associativity:
 *  |   - `a || (b || c) = (a || b) || c`
 *  |   - `a && (b && c) = (a && b) && c`
 *  | - Commutativity:
 *  |   - `a || b = b || a`
 *  |   - `a && b = b && a`
 *  | - Absorption:
 *  |   - `a || (a && b) = a`
 *  |   - `a && (a || b) = a`
 *  | - Idempotent:
 *  |   - `a || a = a`
 *  |   - `a && a = a`
 *  | - Identity:
 *  |   - `a || ff = a`
 *  |   - `a && tt = a`
 *  | - Implication:
 *  |   - ``a `implies` a = tt``
 *  |   - ``a && (a `implies` b) = a && b``
 *  |   - ``b && (a `implies` b) = b``
 *  |   - ``a `implies` (b && c) = (a `implies` b) && (a `implies` c)``
 *  | - Complemented:
 *  |   - ``not a = a `implies` ff``
 */  
  var disj = function (dict) {
      return dict.disj;
  };
  var heytingAlgebraBoolean = new HeytingAlgebra($foreign.boolConj, $foreign.boolDisj, false, function (a) {
      return function (b) {
          return disj(heytingAlgebraBoolean)(not(heytingAlgebraBoolean)(a))(b);
      };
  }, $foreign.boolNot, true);

  /**
 *  | The `HeytingAlgebra` type class represents types are bounded lattices with
 *  | an implication operator such that the following laws hold:
 *  |
 *  | - Associativity:
 *  |   - `a || (b || c) = (a || b) || c`
 *  |   - `a && (b && c) = (a && b) && c`
 *  | - Commutativity:
 *  |   - `a || b = b || a`
 *  |   - `a && b = b && a`
 *  | - Absorption:
 *  |   - `a || (a && b) = a`
 *  |   - `a && (a || b) = a`
 *  | - Idempotent:
 *  |   - `a || a = a`
 *  |   - `a && a = a`
 *  | - Identity:
 *  |   - `a || ff = a`
 *  |   - `a && tt = a`
 *  | - Implication:
 *  |   - ``a `implies` a = tt``
 *  |   - ``a && (a `implies` b) = a && b``
 *  |   - ``b && (a `implies` b) = b``
 *  |   - ``a `implies` (b && c) = (a `implies` b) && (a `implies` c)``
 *  | - Complemented:
 *  |   - ``not a = a `implies` ff``
 */  
  var conj = function (dict) {
      return dict.conj;
  };
  var heytingAlgebraFunction = function (dictHeytingAlgebra) {
      return new HeytingAlgebra(function (f) {
          return function (g) {
              return function (a) {
                  return conj(dictHeytingAlgebra)(f(a))(g(a));
              };
          };
      }, function (f) {
          return function (g) {
              return function (a) {
                  return disj(dictHeytingAlgebra)(f(a))(g(a));
              };
          };
      }, function (v) {
          return ff(dictHeytingAlgebra);
      }, function (f) {
          return function (g) {
              return function (a) {
                  return implies(dictHeytingAlgebra)(f(a))(g(a));
              };
          };
      }, function (f) {
          return function (a) {
              return not(dictHeytingAlgebra)(f(a));
          };
      }, function (v) {
          return tt(dictHeytingAlgebra);
      });
  };
  exports["HeytingAlgebra"] = HeytingAlgebra;
  exports["conj"] = conj;
  exports["disj"] = disj;
  exports["ff"] = ff;
  exports["implies"] = implies;
  exports["not"] = not;
  exports["tt"] = tt;
  exports["heytingAlgebraBoolean"] = heytingAlgebraBoolean;
  exports["heytingAlgebraUnit"] = heytingAlgebraUnit;
  exports["heytingAlgebraFunction"] = heytingAlgebraFunction;
})(PS["Data.HeytingAlgebra"] = PS["Data.HeytingAlgebra"] || {});
(function(exports) {
    "use strict";
  var Prelude = PS["Prelude"];
  var Control_Comonad = PS["Control.Comonad"];
  var Control_Extend = PS["Control.Extend"];
  var Data_Functor_Invariant = PS["Data.Functor.Invariant"];
  var Data_HeytingAlgebra = PS["Data.HeytingAlgebra"];
  var Data_Monoid = PS["Data.Monoid"];
  var Data_Newtype = PS["Data.Newtype"];
  var Data_Eq = PS["Data.Eq"];
  var Data_Ord = PS["Data.Ord"];
  var Data_Bounded = PS["Data.Bounded"];
  var Data_Functor = PS["Data.Functor"];
  var Control_Apply = PS["Control.Apply"];
  var Control_Applicative = PS["Control.Applicative"];
  var Control_Bind = PS["Control.Bind"];
  var Control_Monad = PS["Control.Monad"];
  var Data_Show = PS["Data.Show"];
  var Data_Semigroup = PS["Data.Semigroup"];
  var Data_Semiring = PS["Data.Semiring"];        

  /**
 *  | Monoid under conjuntion.
 *  |
 *  | ``` purescript
 *  | Conj x <> Conj y == Conj (x && y)
 *  | mempty :: Conj _ == Conj top
 *  | ```
 */  
  var Conj = function (x) {
      return x;
  };
  var showConj = function (dictShow) {
      return new Data_Show.Show(function (v) {
          return "(Conj " + (Data_Show.show(dictShow)(v) + ")");
      });
  };
  var semiringConj = function (dictHeytingAlgebra) {
      return new Data_Semiring.Semiring(function (v) {
          return function (v1) {
              return Data_HeytingAlgebra.conj(dictHeytingAlgebra)(v)(v1);
          };
      }, function (v) {
          return function (v1) {
              return Data_HeytingAlgebra.disj(dictHeytingAlgebra)(v)(v1);
          };
      }, Data_HeytingAlgebra.ff(dictHeytingAlgebra), Data_HeytingAlgebra.tt(dictHeytingAlgebra));
  };
  var semigroupConj = function (dictHeytingAlgebra) {
      return new Data_Semigroup.Semigroup(function (v) {
          return function (v1) {
              return Data_HeytingAlgebra.conj(dictHeytingAlgebra)(v)(v1);
          };
      });
  };
  var ordConj = function (dictOrd) {
      return dictOrd;
  };
  var newtypeConj = new Data_Newtype.Newtype(function (n) {
      return n;
  }, Conj);
  var monoidConj = function (dictHeytingAlgebra) {
      return new Data_Monoid.Monoid(function () {
          return semigroupConj(dictHeytingAlgebra);
      }, Data_HeytingAlgebra.tt(dictHeytingAlgebra));
  };
  var invariantConj = new Data_Functor_Invariant.Invariant(function (f) {
      return function (v) {
          return function (v1) {
              return f(v1);
          };
      };
  });
  var functorConj = new Data_Functor.Functor(function (f) {
      return function (v) {
          return f(v);
      };
  });
  var extendConj = new Control_Extend.Extend(function () {
      return functorConj;
  }, function (f) {
      return function (x) {
          return f(x);
      };
  });
  var eqConj = function (dictEq) {
      return dictEq;
  };
  var comonadConj = new Control_Comonad.Comonad(function () {
      return extendConj;
  }, Data_Newtype.unwrap(newtypeConj));
  var boundedConj = function (dictBounded) {
      return dictBounded;
  };
  var applyConj = new Control_Apply.Apply(function () {
      return functorConj;
  }, function (v) {
      return function (v1) {
          return v(v1);
      };
  });
  var bindConj = new Control_Bind.Bind(function () {
      return applyConj;
  }, function (v) {
      return function (f) {
          return f(v);
      };
  });
  var applicativeConj = new Control_Applicative.Applicative(function () {
      return applyConj;
  }, Conj);
  var monadConj = new Control_Monad.Monad(function () {
      return applicativeConj;
  }, function () {
      return bindConj;
  });
  exports["Conj"] = Conj;
  exports["newtypeConj"] = newtypeConj;
  exports["eqConj"] = eqConj;
  exports["ordConj"] = ordConj;
  exports["boundedConj"] = boundedConj;
  exports["functorConj"] = functorConj;
  exports["invariantConj"] = invariantConj;
  exports["applyConj"] = applyConj;
  exports["applicativeConj"] = applicativeConj;
  exports["bindConj"] = bindConj;
  exports["monadConj"] = monadConj;
  exports["extendConj"] = extendConj;
  exports["comonadConj"] = comonadConj;
  exports["showConj"] = showConj;
  exports["semigroupConj"] = semigroupConj;
  exports["monoidConj"] = monoidConj;
  exports["semiringConj"] = semiringConj;
})(PS["Data.Monoid.Conj"] = PS["Data.Monoid.Conj"] || {});
(function(exports) {
    "use strict";
  var Prelude = PS["Prelude"];
  var Control_Comonad = PS["Control.Comonad"];
  var Control_Extend = PS["Control.Extend"];
  var Data_Functor_Invariant = PS["Data.Functor.Invariant"];
  var Data_HeytingAlgebra = PS["Data.HeytingAlgebra"];
  var Data_Monoid = PS["Data.Monoid"];
  var Data_Newtype = PS["Data.Newtype"];
  var Data_Eq = PS["Data.Eq"];
  var Data_Ord = PS["Data.Ord"];
  var Data_Bounded = PS["Data.Bounded"];
  var Data_Functor = PS["Data.Functor"];
  var Control_Apply = PS["Control.Apply"];
  var Control_Applicative = PS["Control.Applicative"];
  var Control_Bind = PS["Control.Bind"];
  var Control_Monad = PS["Control.Monad"];
  var Data_Show = PS["Data.Show"];
  var Data_Semigroup = PS["Data.Semigroup"];
  var Data_Semiring = PS["Data.Semiring"];        

  /**
 *  | Monoid under disjuntion.
 *  |
 *  | ``` purescript
 *  | Disj x <> Disj y == Disj (x || y)
 *  | mempty :: Disj _ == Disj bottom
 *  | ```
 */  
  var Disj = function (x) {
      return x;
  };
  var showDisj = function (dictShow) {
      return new Data_Show.Show(function (v) {
          return "(Disj " + (Data_Show.show(dictShow)(v) + ")");
      });
  };
  var semiringDisj = function (dictHeytingAlgebra) {
      return new Data_Semiring.Semiring(function (v) {
          return function (v1) {
              return Data_HeytingAlgebra.disj(dictHeytingAlgebra)(v)(v1);
          };
      }, function (v) {
          return function (v1) {
              return Data_HeytingAlgebra.conj(dictHeytingAlgebra)(v)(v1);
          };
      }, Data_HeytingAlgebra.tt(dictHeytingAlgebra), Data_HeytingAlgebra.ff(dictHeytingAlgebra));
  };
  var semigroupDisj = function (dictHeytingAlgebra) {
      return new Data_Semigroup.Semigroup(function (v) {
          return function (v1) {
              return Data_HeytingAlgebra.disj(dictHeytingAlgebra)(v)(v1);
          };
      });
  };
  var ordDisj = function (dictOrd) {
      return dictOrd;
  };
  var newtypeDisj = new Data_Newtype.Newtype(function (n) {
      return n;
  }, Disj);
  var monoidDisj = function (dictHeytingAlgebra) {
      return new Data_Monoid.Monoid(function () {
          return semigroupDisj(dictHeytingAlgebra);
      }, Data_HeytingAlgebra.ff(dictHeytingAlgebra));
  };
  var invariantDisj = new Data_Functor_Invariant.Invariant(function (f) {
      return function (v) {
          return function (v1) {
              return f(v1);
          };
      };
  });
  var functorDisj = new Data_Functor.Functor(function (f) {
      return function (v) {
          return f(v);
      };
  });
  var extendDisj = new Control_Extend.Extend(function () {
      return functorDisj;
  }, function (f) {
      return function (x) {
          return f(x);
      };
  });
  var eqDisj = function (dictEq) {
      return dictEq;
  };
  var comonadDisj = new Control_Comonad.Comonad(function () {
      return extendDisj;
  }, Data_Newtype.unwrap(newtypeDisj));
  var boundedDisj = function (dictBounded) {
      return dictBounded;
  };
  var applyDisj = new Control_Apply.Apply(function () {
      return functorDisj;
  }, function (v) {
      return function (v1) {
          return v(v1);
      };
  });
  var bindDisj = new Control_Bind.Bind(function () {
      return applyDisj;
  }, function (v) {
      return function (f) {
          return f(v);
      };
  });
  var applicativeDisj = new Control_Applicative.Applicative(function () {
      return applyDisj;
  }, Disj);
  var monadDisj = new Control_Monad.Monad(function () {
      return applicativeDisj;
  }, function () {
      return bindDisj;
  });
  exports["Disj"] = Disj;
  exports["newtypeDisj"] = newtypeDisj;
  exports["eqDisj"] = eqDisj;
  exports["ordDisj"] = ordDisj;
  exports["boundedDisj"] = boundedDisj;
  exports["functorDisj"] = functorDisj;
  exports["invariantDisj"] = invariantDisj;
  exports["applyDisj"] = applyDisj;
  exports["applicativeDisj"] = applicativeDisj;
  exports["bindDisj"] = bindDisj;
  exports["monadDisj"] = monadDisj;
  exports["extendDisj"] = extendDisj;
  exports["comonadDisj"] = comonadDisj;
  exports["showDisj"] = showDisj;
  exports["semigroupDisj"] = semigroupDisj;
  exports["monoidDisj"] = monoidDisj;
  exports["semiringDisj"] = semiringDisj;
})(PS["Data.Monoid.Disj"] = PS["Data.Monoid.Disj"] || {});
(function(exports) {
    "use strict";
  var Prelude = PS["Prelude"];
  var Control_Comonad = PS["Control.Comonad"];
  var Control_Extend = PS["Control.Extend"];
  var Data_Functor_Invariant = PS["Data.Functor.Invariant"];
  var Data_Monoid = PS["Data.Monoid"];
  var Data_Newtype = PS["Data.Newtype"];
  var Data_Eq = PS["Data.Eq"];
  var Data_Ord = PS["Data.Ord"];
  var Data_Bounded = PS["Data.Bounded"];
  var Data_Functor = PS["Data.Functor"];
  var Control_Apply = PS["Control.Apply"];
  var Control_Applicative = PS["Control.Applicative"];
  var Control_Bind = PS["Control.Bind"];
  var Control_Monad = PS["Control.Monad"];
  var Data_Show = PS["Data.Show"];
  var Data_Semigroup = PS["Data.Semigroup"];        

  /**
 *  | The dual of a monoid.
 *  |
 *  | ``` purescript
 *  | Dual x <> Dual y == Dual (y <> x)
 *  | mempty :: Dual _ == Dual mempty
 *  | ```
 */  
  var Dual = function (x) {
      return x;
  };
  var showDual = function (dictShow) {
      return new Data_Show.Show(function (v) {
          return "(Dual " + (Data_Show.show(dictShow)(v) + ")");
      });
  };
  var semigroupDual = function (dictSemigroup) {
      return new Data_Semigroup.Semigroup(function (v) {
          return function (v1) {
              return Data_Semigroup.append(dictSemigroup)(v1)(v);
          };
      });
  };
  var ordDual = function (dictOrd) {
      return dictOrd;
  };
  var newtypeDual = new Data_Newtype.Newtype(function (n) {
      return n;
  }, Dual);
  var monoidDual = function (dictMonoid) {
      return new Data_Monoid.Monoid(function () {
          return semigroupDual(dictMonoid["__superclass_Data.Semigroup.Semigroup_0"]());
      }, Data_Monoid.mempty(dictMonoid));
  };
  var invariantDual = new Data_Functor_Invariant.Invariant(function (f) {
      return function (v) {
          return function (v1) {
              return f(v1);
          };
      };
  });
  var functorDual = new Data_Functor.Functor(function (f) {
      return function (v) {
          return f(v);
      };
  });
  var extendDual = new Control_Extend.Extend(function () {
      return functorDual;
  }, function (f) {
      return function (x) {
          return f(x);
      };
  });
  var eqDual = function (dictEq) {
      return dictEq;
  };
  var comonadDual = new Control_Comonad.Comonad(function () {
      return extendDual;
  }, Data_Newtype.unwrap(newtypeDual));
  var boundedDual = function (dictBounded) {
      return dictBounded;
  };
  var applyDual = new Control_Apply.Apply(function () {
      return functorDual;
  }, function (v) {
      return function (v1) {
          return v(v1);
      };
  });
  var bindDual = new Control_Bind.Bind(function () {
      return applyDual;
  }, function (v) {
      return function (f) {
          return f(v);
      };
  });
  var applicativeDual = new Control_Applicative.Applicative(function () {
      return applyDual;
  }, Dual);
  var monadDual = new Control_Monad.Monad(function () {
      return applicativeDual;
  }, function () {
      return bindDual;
  });
  exports["Dual"] = Dual;
  exports["newtypeDual"] = newtypeDual;
  exports["eqDual"] = eqDual;
  exports["ordDual"] = ordDual;
  exports["boundedDual"] = boundedDual;
  exports["functorDual"] = functorDual;
  exports["invariantDual"] = invariantDual;
  exports["applyDual"] = applyDual;
  exports["applicativeDual"] = applicativeDual;
  exports["bindDual"] = bindDual;
  exports["monadDual"] = monadDual;
  exports["extendDual"] = extendDual;
  exports["comonadDual"] = comonadDual;
  exports["showDual"] = showDual;
  exports["semigroupDual"] = semigroupDual;
  exports["monoidDual"] = monoidDual;
})(PS["Data.Monoid.Dual"] = PS["Data.Monoid.Dual"] || {});
(function(exports) {
    "use strict";
  var Prelude = PS["Prelude"];
  var Data_Functor_Invariant = PS["Data.Functor.Invariant"];
  var Data_Monoid = PS["Data.Monoid"];
  var Data_Newtype = PS["Data.Newtype"];
  var Control_Semigroupoid = PS["Control.Semigroupoid"];
  var Data_Semigroup = PS["Data.Semigroup"];
  var Control_Category = PS["Control.Category"];        

  /**
 *  | Monoid of endomorphisms under composition.
 *  |
 *  | Composes of functions of type `a -> a`:
 *  | ``` purescript
 *  | Endo f <> Endo g == Endo (f <<< g)
 *  | mempty :: Endo _ == Endo id
 *  | ```
 */  
  var Endo = function (x) {
      return x;
  };
  var semigroupEndo = new Data_Semigroup.Semigroup(function (v) {
      return function (v1) {
          return function ($11) {
              return v(v1($11));
          };
      };
  });
  var newtypeEndo = new Data_Newtype.Newtype(function (n) {
      return n;
  }, Endo);
  var monoidEndo = new Data_Monoid.Monoid(function () {
      return semigroupEndo;
  }, Control_Category.id(Control_Category.categoryFn));
  var invariantEndo = new Data_Functor_Invariant.Invariant(function (ab) {
      return function (ba) {
          return function (v) {
              return function ($12) {
                  return ab(v(ba($12)));
              };
          };
      };
  });
  exports["Endo"] = Endo;
  exports["newtypeEndo"] = newtypeEndo;
  exports["invariantEndo"] = invariantEndo;
  exports["semigroupEndo"] = semigroupEndo;
  exports["monoidEndo"] = monoidEndo;
})(PS["Data.Monoid.Endo"] = PS["Data.Monoid.Endo"] || {});
(function(exports) {
    "use strict";
  var Prelude = PS["Prelude"];
  var Control_Comonad = PS["Control.Comonad"];
  var Control_Extend = PS["Control.Extend"];
  var Data_Functor_Invariant = PS["Data.Functor.Invariant"];
  var Data_Monoid = PS["Data.Monoid"];
  var Data_Newtype = PS["Data.Newtype"];
  var Data_Eq = PS["Data.Eq"];
  var Data_Ord = PS["Data.Ord"];
  var Data_Bounded = PS["Data.Bounded"];
  var Data_Functor = PS["Data.Functor"];
  var Control_Apply = PS["Control.Apply"];
  var Control_Applicative = PS["Control.Applicative"];
  var Control_Bind = PS["Control.Bind"];
  var Control_Monad = PS["Control.Monad"];
  var Data_Show = PS["Data.Show"];
  var Data_Semigroup = PS["Data.Semigroup"];
  var Data_Semiring = PS["Data.Semiring"];        

  /**
 *  | Monoid and semigroup for semirings under multiplication.
 *  |
 *  | ``` purescript
 *  | Multiplicative x <> Multiplicative y == Multiplicative (x * y)
 *  | mempty :: Multiplicative _ == Multiplicative one
 *  | ```
 */  
  var Multiplicative = function (x) {
      return x;
  };
  var showMultiplicative = function (dictShow) {
      return new Data_Show.Show(function (v) {
          return "(Multiplicative " + (Data_Show.show(dictShow)(v) + ")");
      });
  };
  var semigroupMultiplicative = function (dictSemiring) {
      return new Data_Semigroup.Semigroup(function (v) {
          return function (v1) {
              return Data_Semiring.mul(dictSemiring)(v)(v1);
          };
      });
  };
  var ordMultiplicative = function (dictOrd) {
      return dictOrd;
  };
  var newtypeMultiplicative = new Data_Newtype.Newtype(function (n) {
      return n;
  }, Multiplicative);
  var monoidMultiplicative = function (dictSemiring) {
      return new Data_Monoid.Monoid(function () {
          return semigroupMultiplicative(dictSemiring);
      }, Data_Semiring.one(dictSemiring));
  };
  var invariantMultiplicative = new Data_Functor_Invariant.Invariant(function (f) {
      return function (v) {
          return function (v1) {
              return f(v1);
          };
      };
  });
  var functorMultiplicative = new Data_Functor.Functor(function (f) {
      return function (v) {
          return f(v);
      };
  });
  var extendMultiplicative = new Control_Extend.Extend(function () {
      return functorMultiplicative;
  }, function (f) {
      return function (x) {
          return f(x);
      };
  });
  var eqMultiplicative = function (dictEq) {
      return dictEq;
  };
  var comonadMultiplicative = new Control_Comonad.Comonad(function () {
      return extendMultiplicative;
  }, Data_Newtype.unwrap(newtypeMultiplicative));
  var boundedMultiplicative = function (dictBounded) {
      return dictBounded;
  };
  var applyMultiplicative = new Control_Apply.Apply(function () {
      return functorMultiplicative;
  }, function (v) {
      return function (v1) {
          return v(v1);
      };
  });
  var bindMultiplicative = new Control_Bind.Bind(function () {
      return applyMultiplicative;
  }, function (v) {
      return function (f) {
          return f(v);
      };
  });
  var applicativeMultiplicative = new Control_Applicative.Applicative(function () {
      return applyMultiplicative;
  }, Multiplicative);
  var monadMultiplicative = new Control_Monad.Monad(function () {
      return applicativeMultiplicative;
  }, function () {
      return bindMultiplicative;
  });
  exports["Multiplicative"] = Multiplicative;
  exports["newtypeMultiplicative"] = newtypeMultiplicative;
  exports["eqMultiplicative"] = eqMultiplicative;
  exports["ordMultiplicative"] = ordMultiplicative;
  exports["boundedMultiplicative"] = boundedMultiplicative;
  exports["functorMultiplicative"] = functorMultiplicative;
  exports["invariantMultiplicative"] = invariantMultiplicative;
  exports["applyMultiplicative"] = applyMultiplicative;
  exports["applicativeMultiplicative"] = applicativeMultiplicative;
  exports["bindMultiplicative"] = bindMultiplicative;
  exports["monadMultiplicative"] = monadMultiplicative;
  exports["extendMultiplicative"] = extendMultiplicative;
  exports["comonadMultiplicative"] = comonadMultiplicative;
  exports["showMultiplicative"] = showMultiplicative;
  exports["semigroupMultiplicative"] = semigroupMultiplicative;
  exports["monoidMultiplicative"] = monoidMultiplicative;
})(PS["Data.Monoid.Multiplicative"] = PS["Data.Monoid.Multiplicative"] || {});
(function(exports) {
    "use strict";
  var $foreign = PS["Data.Foldable"];
  var Prelude = PS["Prelude"];
  var Control_Plus = PS["Control.Plus"];
  var Data_Maybe = PS["Data.Maybe"];
  var Data_Maybe_First = PS["Data.Maybe.First"];
  var Data_Maybe_Last = PS["Data.Maybe.Last"];
  var Data_Monoid = PS["Data.Monoid"];
  var Data_Monoid_Additive = PS["Data.Monoid.Additive"];
  var Data_Monoid_Conj = PS["Data.Monoid.Conj"];
  var Data_Monoid_Disj = PS["Data.Monoid.Disj"];
  var Data_Monoid_Dual = PS["Data.Monoid.Dual"];
  var Data_Monoid_Endo = PS["Data.Monoid.Endo"];
  var Data_Monoid_Multiplicative = PS["Data.Monoid.Multiplicative"];
  var Data_Newtype = PS["Data.Newtype"];
  var Control_Alt = PS["Control.Alt"];
  var Control_Semigroupoid = PS["Control.Semigroupoid"];
  var Control_Apply = PS["Control.Apply"];
  var Control_Applicative = PS["Control.Applicative"];
  var Data_Unit = PS["Data.Unit"];
  var Data_Function = PS["Data.Function"];
  var Control_Category = PS["Control.Category"];
  var Data_Semigroup = PS["Data.Semigroup"];
  var Data_Eq = PS["Data.Eq"];
  var Data_Ordering = PS["Data.Ordering"];
  var Data_Ord = PS["Data.Ord"];
  var Data_Semiring = PS["Data.Semiring"];
  var Data_Functor = PS["Data.Functor"];
  var Data_HeytingAlgebra = PS["Data.HeytingAlgebra"];        

  /**
 *  | `Foldable` represents data structures which can be _folded_.
 *  |
 *  | - `foldr` folds a structure from the right
 *  | - `foldl` folds a structure from the left
 *  | - `foldMap` folds a structure by accumulating values in a `Monoid`
 *  |
 *  | Default implementations are provided by the following functions:
 *  |
 *  | - `foldrDefault`
 *  | - `foldlDefault`
 *  | - `foldMapDefaultR`
 *  | - `foldMapDefaultL`
 *  |
 *  | Note: some combinations of the default implementations are unsafe to
 *  | use together - causing a non-terminating mutually recursive cycle.
 *  | These combinations are documented per function.
 */  
  var Foldable = function (foldMap, foldl, foldr) {
      this.foldMap = foldMap;
      this.foldl = foldl;
      this.foldr = foldr;
  };

  /**
 *  | `Foldable` represents data structures which can be _folded_.
 *  |
 *  | - `foldr` folds a structure from the right
 *  | - `foldl` folds a structure from the left
 *  | - `foldMap` folds a structure by accumulating values in a `Monoid`
 *  |
 *  | Default implementations are provided by the following functions:
 *  |
 *  | - `foldrDefault`
 *  | - `foldlDefault`
 *  | - `foldMapDefaultR`
 *  | - `foldMapDefaultL`
 *  |
 *  | Note: some combinations of the default implementations are unsafe to
 *  | use together - causing a non-terminating mutually recursive cycle.
 *  | These combinations are documented per function.
 */  
  var foldr = function (dict) {
      return dict.foldr;
  };

  /**
 *  | Combines a collection of elements using the `Alt` operation.
 */  
  var oneOf = function (dictFoldable) {
      return function (dictPlus) {
          return foldr(dictFoldable)(Control_Alt.alt(dictPlus["__superclass_Control.Alt.Alt_0"]()))(Control_Plus.empty(dictPlus));
      };
  };

  /**
 *  | Traverse a data structure, performing some effects encoded by an
 *  | `Applicative` functor at each value, ignoring the final result.
 *  |
 *  | For example:
 *  |
 *  | ```purescript
 *  | traverse_ print [1, 2, 3]
 *  | ```
 */  
  var traverse_ = function (dictApplicative) {
      return function (dictFoldable) {
          return function (f) {
              return foldr(dictFoldable)(function ($169) {
                  return Control_Apply.applySecond(dictApplicative["__superclass_Control.Apply.Apply_0"]())(f($169));
              })(Control_Applicative.pure(dictApplicative)(Data_Unit.unit));
          };
      };
  };

  /**
 *  | A version of `traverse_` with its arguments flipped.
 *  |
 *  | This can be useful when running an action written using do notation
 *  | for every element in a data structure:
 *  |
 *  | For example:
 *  |
 *  | ```purescript
 *  | for_ [1, 2, 3] \n -> do
 *  |   print n
 *  |   trace "squared is"
 *  |   print (n * n)
 *  | ```
 */  
  var for_ = function (dictApplicative) {
      return function (dictFoldable) {
          return Data_Function.flip(traverse_(dictApplicative)(dictFoldable));
      };
  };

  /**
 *  | Perform all of the effects in some data structure in the order
 *  | given by the `Foldable` instance, ignoring the final result.
 *  |
 *  | For example:
 *  |
 *  | ```purescript
 *  | sequence_ [ trace "Hello, ", trace " world!" ]
 *  | ```
 */  
  var sequence_ = function (dictApplicative) {
      return function (dictFoldable) {
          return traverse_(dictApplicative)(dictFoldable)(Control_Category.id(Control_Category.categoryFn));
      };
  };

  /**
 *  | `Foldable` represents data structures which can be _folded_.
 *  |
 *  | - `foldr` folds a structure from the right
 *  | - `foldl` folds a structure from the left
 *  | - `foldMap` folds a structure by accumulating values in a `Monoid`
 *  |
 *  | Default implementations are provided by the following functions:
 *  |
 *  | - `foldrDefault`
 *  | - `foldlDefault`
 *  | - `foldMapDefaultR`
 *  | - `foldMapDefaultL`
 *  |
 *  | Note: some combinations of the default implementations are unsafe to
 *  | use together - causing a non-terminating mutually recursive cycle.
 *  | These combinations are documented per function.
 */  
  var foldl = function (dict) {
      return dict.foldl;
  };

  /**
 *  | Fold a data structure, accumulating values in some `Monoid`,
 *  | combining adjacent elements using the specified separator.
 */  
  var intercalate = function (dictFoldable) {
      return function (dictMonoid) {
          return function (sep) {
              return function (xs) {
                  var go = function (v) {
                      return function (x) {
                          if (v.init) {
                              return {
                                  init: false, 
                                  acc: x
                              };
                          };
                          return {
                              init: false, 
                              acc: Data_Semigroup.append(dictMonoid["__superclass_Data.Semigroup.Semigroup_0"]())(v.acc)(Data_Semigroup.append(dictMonoid["__superclass_Data.Semigroup.Semigroup_0"]())(sep)(x))
                          };
                      };
                  };
                  return (foldl(dictFoldable)(go)({
                      init: true, 
                      acc: Data_Monoid.mempty(dictMonoid)
                  })(xs)).acc;
              };
          };
      };
  };

  /**
 *  | Find the largest element of a structure, according to a given comparison
 *  | function. The comparison function should represent a total ordering (see
 *  | the `Ord` type class laws); if it does not, the behaviour is undefined.
 */  
  var maximumBy = function (dictFoldable) {
      return function (cmp) {
          var max$prime = function (v) {
              return function (v1) {
                  if (v instanceof Data_Maybe.Nothing) {
                      return new Data_Maybe.Just(v1);
                  };
                  if (v instanceof Data_Maybe.Just) {
                      return new Data_Maybe.Just((function () {
                          var $92 = Data_Eq.eq(Data_Ordering.eqOrdering)(cmp(v.value0)(v1))(Data_Ordering.GT.value);
                          if ($92) {
                              return v.value0;
                          };
                          if (!$92) {
                              return v1;
                          };
                          throw new Error("Failed pattern match at Data.Foldable line 291, column 27 - line 291, column 57: " + [ $92.constructor.name ]);
                      })());
                  };
                  throw new Error("Failed pattern match at Data.Foldable line 290, column 3 - line 290, column 27: " + [ v.constructor.name, v1.constructor.name ]);
              };
          };
          return foldl(dictFoldable)(max$prime)(Data_Maybe.Nothing.value);
      };
  };

  /**
 *  | Find the largest element of a structure, according to its `Ord` instance.
 */  
  var maximum = function (dictOrd) {
      return function (dictFoldable) {
          return maximumBy(dictFoldable)(Data_Ord.compare(dictOrd));
      };
  };

  /**
 *  | Find the smallest element of a structure, according to a given comparison
 *  | function. The comparison function should represent a total ordering (see
 *  | the `Ord` type class laws); if it does not, the behaviour is undefined.
 */  
  var minimumBy = function (dictFoldable) {
      return function (cmp) {
          var min$prime = function (v) {
              return function (v1) {
                  if (v instanceof Data_Maybe.Nothing) {
                      return new Data_Maybe.Just(v1);
                  };
                  if (v instanceof Data_Maybe.Just) {
                      return new Data_Maybe.Just((function () {
                          var $96 = Data_Eq.eq(Data_Ordering.eqOrdering)(cmp(v.value0)(v1))(Data_Ordering.LT.value);
                          if ($96) {
                              return v.value0;
                          };
                          if (!$96) {
                              return v1;
                          };
                          throw new Error("Failed pattern match at Data.Foldable line 304, column 27 - line 304, column 57: " + [ $96.constructor.name ]);
                      })());
                  };
                  throw new Error("Failed pattern match at Data.Foldable line 303, column 3 - line 303, column 27: " + [ v.constructor.name, v1.constructor.name ]);
              };
          };
          return foldl(dictFoldable)(min$prime)(Data_Maybe.Nothing.value);
      };
  };

  /**
 *  | Find the smallest element of a structure, according to its `Ord` instance.
 */  
  var minimum = function (dictOrd) {
      return function (dictFoldable) {
          return minimumBy(dictFoldable)(Data_Ord.compare(dictOrd));
      };
  };

  /**
 *  | Find the product of the numeric values in a data structure.
 */  
  var product = function (dictFoldable) {
      return function (dictSemiring) {
          return foldl(dictFoldable)(Data_Semiring.mul(dictSemiring))(Data_Semiring.one(dictSemiring));
      };
  };

  /**
 *  | Find the sum of the numeric values in a data structure.
 */  
  var sum = function (dictFoldable) {
      return function (dictSemiring) {
          return foldl(dictFoldable)(Data_Semiring.add(dictSemiring))(Data_Semiring.zero(dictSemiring));
      };
  };
  var foldableMultiplicative = new Foldable(function (dictMonoid) {
      return function (f) {
          return function (v) {
              return f(v);
          };
      };
  }, function (f) {
      return function (z) {
          return function (v) {
              return f(z)(v);
          };
      };
  }, function (f) {
      return function (z) {
          return function (v) {
              return f(v)(z);
          };
      };
  });
  var foldableMaybe = new Foldable(function (dictMonoid) {
      return function (f) {
          return function (v) {
              if (v instanceof Data_Maybe.Nothing) {
                  return Data_Monoid.mempty(dictMonoid);
              };
              if (v instanceof Data_Maybe.Just) {
                  return f(v.value0);
              };
              throw new Error("Failed pattern match at Data.Foldable line 126, column 3 - line 126, column 30: " + [ f.constructor.name, v.constructor.name ]);
          };
      };
  }, function (v) {
      return function (z) {
          return function (v1) {
              if (v1 instanceof Data_Maybe.Nothing) {
                  return z;
              };
              if (v1 instanceof Data_Maybe.Just) {
                  return v(z)(v1.value0);
              };
              throw new Error("Failed pattern match at Data.Foldable line 124, column 3 - line 124, column 25: " + [ v.constructor.name, z.constructor.name, v1.constructor.name ]);
          };
      };
  }, function (v) {
      return function (z) {
          return function (v1) {
              if (v1 instanceof Data_Maybe.Nothing) {
                  return z;
              };
              if (v1 instanceof Data_Maybe.Just) {
                  return v(v1.value0)(z);
              };
              throw new Error("Failed pattern match at Data.Foldable line 122, column 3 - line 122, column 25: " + [ v.constructor.name, z.constructor.name, v1.constructor.name ]);
          };
      };
  });
  var foldableDual = new Foldable(function (dictMonoid) {
      return function (f) {
          return function (v) {
              return f(v);
          };
      };
  }, function (f) {
      return function (z) {
          return function (v) {
              return f(z)(v);
          };
      };
  }, function (f) {
      return function (z) {
          return function (v) {
              return f(v)(z);
          };
      };
  });
  var foldableDisj = new Foldable(function (dictMonoid) {
      return function (f) {
          return function (v) {
              return f(v);
          };
      };
  }, function (f) {
      return function (z) {
          return function (v) {
              return f(z)(v);
          };
      };
  }, function (f) {
      return function (z) {
          return function (v) {
              return f(v)(z);
          };
      };
  });
  var foldableConj = new Foldable(function (dictMonoid) {
      return function (f) {
          return function (v) {
              return f(v);
          };
      };
  }, function (f) {
      return function (z) {
          return function (v) {
              return f(z)(v);
          };
      };
  }, function (f) {
      return function (z) {
          return function (v) {
              return f(v)(z);
          };
      };
  });
  var foldableAdditive = new Foldable(function (dictMonoid) {
      return function (f) {
          return function (v) {
              return f(v);
          };
      };
  }, function (f) {
      return function (z) {
          return function (v) {
              return f(z)(v);
          };
      };
  }, function (f) {
      return function (z) {
          return function (v) {
              return f(v)(z);
          };
      };
  });

  /**
 *  | A default implementation of `foldMap` using `foldr`.
 *  |
 *  | Note: when defining a `Foldable` instance, this function is unsafe to use
 *  | in combination with `foldrDefault`.
 */  
  var foldMapDefaultR = function (dictFoldable) {
      return function (dictMonoid) {
          return function (f) {
              return function (xs) {
                  return foldr(dictFoldable)(function (x) {
                      return function (acc) {
                          return Data_Semigroup.append(dictMonoid["__superclass_Data.Semigroup.Semigroup_0"]())(f(x))(acc);
                      };
                  })(Data_Monoid.mempty(dictMonoid))(xs);
              };
          };
      };
  };
  var foldableArray = new Foldable(function (dictMonoid) {
      return foldMapDefaultR(foldableArray)(dictMonoid);
  }, $foreign.foldlArray, $foreign.foldrArray);

  /**
 *  | A default implementation of `foldMap` using `foldl`.
 *  |
 *  | Note: when defining a `Foldable` instance, this function is unsafe to use
 *  | in combination with `foldlDefault`.
 */  
  var foldMapDefaultL = function (dictFoldable) {
      return function (dictMonoid) {
          return function (f) {
              return function (xs) {
                  return foldl(dictFoldable)(function (acc) {
                      return function (x) {
                          return Data_Semigroup.append(dictMonoid["__superclass_Data.Semigroup.Semigroup_0"]())(f(x))(acc);
                      };
                  })(Data_Monoid.mempty(dictMonoid))(xs);
              };
          };
      };
  };

  /**
 *  | `Foldable` represents data structures which can be _folded_.
 *  |
 *  | - `foldr` folds a structure from the right
 *  | - `foldl` folds a structure from the left
 *  | - `foldMap` folds a structure by accumulating values in a `Monoid`
 *  |
 *  | Default implementations are provided by the following functions:
 *  |
 *  | - `foldrDefault`
 *  | - `foldlDefault`
 *  | - `foldMapDefaultR`
 *  | - `foldMapDefaultL`
 *  |
 *  | Note: some combinations of the default implementations are unsafe to
 *  | use together - causing a non-terminating mutually recursive cycle.
 *  | These combinations are documented per function.
 */  
  var foldMap = function (dict) {
      return dict.foldMap;
  };
  var foldableFirst = new Foldable(function (dictMonoid) {
      return function (f) {
          return function (v) {
              return foldMap(foldableMaybe)(dictMonoid)(f)(v);
          };
      };
  }, function (f) {
      return function (z) {
          return function (v) {
              return foldl(foldableMaybe)(f)(z)(v);
          };
      };
  }, function (f) {
      return function (z) {
          return function (v) {
              return foldr(foldableMaybe)(f)(z)(v);
          };
      };
  });
  var foldableLast = new Foldable(function (dictMonoid) {
      return function (f) {
          return function (v) {
              return foldMap(foldableMaybe)(dictMonoid)(f)(v);
          };
      };
  }, function (f) {
      return function (z) {
          return function (v) {
              return foldl(foldableMaybe)(f)(z)(v);
          };
      };
  }, function (f) {
      return function (z) {
          return function (v) {
              return foldr(foldableMaybe)(f)(z)(v);
          };
      };
  });

  /**
 *  | A default implementation of `foldl` using `foldMap`.
 *  |
 *  | Note: when defining a `Foldable` instance, this function is unsafe to use
 *  | in combination with `foldMapDefaultL`.
 */  
  var foldlDefault = function (dictFoldable) {
      return function (c) {
          return function (u) {
              return function (xs) {
                  return Data_Newtype.unwrap(Data_Monoid_Endo.newtypeEndo)(Data_Newtype.unwrap(Data_Monoid_Dual.newtypeDual)(foldMap(dictFoldable)(Data_Monoid_Dual.monoidDual(Data_Monoid_Endo.monoidEndo))(function ($170) {
                      return Data_Monoid_Dual.Dual(Data_Monoid_Endo.Endo(Data_Function.flip(c)($170)));
                  })(xs)))(u);
              };
          };
      };
  };

  /**
 *  | A default implementation of `foldr` using `foldMap`.
 *  |
 *  | Note: when defining a `Foldable` instance, this function is unsafe to use
 *  | in combination with `foldMapDefaultR`.
 */  
  var foldrDefault = function (dictFoldable) {
      return function (c) {
          return function (u) {
              return function (xs) {
                  return Data_Newtype.unwrap(Data_Monoid_Endo.newtypeEndo)(foldMap(dictFoldable)(Data_Monoid_Endo.monoidEndo)(function ($171) {
                      return Data_Monoid_Endo.Endo(c($171));
                  })(xs))(u);
              };
          };
      };
  };

  /**
 *  | Fold a data structure, accumulating values in some `Monoid`.
 */  
  var fold = function (dictFoldable) {
      return function (dictMonoid) {
          return foldMap(dictFoldable)(dictMonoid)(Control_Category.id(Control_Category.categoryFn));
      };
  };

  /**
 *  | Try to find an element in a data structure which satisfies a predicate mapping.
 */  
  var findMap = function (dictFoldable) {
      return function (p) {
          var go = function (v) {
              return function (v1) {
                  if (v instanceof Data_Maybe.Nothing) {
                      return p(v1);
                  };
                  return v;
              };
          };
          return foldl(dictFoldable)(go)(Data_Maybe.Nothing.value);
      };
  };

  /**
 *  | Try to find an element in a data structure which satisfies a predicate.
 */  
  var find = function (dictFoldable) {
      return function (p) {
          var go = function (v) {
              return function (v1) {
                  if (v instanceof Data_Maybe.Nothing && p(v1)) {
                      return new Data_Maybe.Just(v1);
                  };
                  return v;
              };
          };
          return foldl(dictFoldable)(go)(Data_Maybe.Nothing.value);
      };
  };

  /**
 *  | `any f` is the same as `or <<< map f`; map a function over the structure,
 *  | and then get the disjunction of the results.
 */  
  var any = function (dictFoldable) {
      return function (dictHeytingAlgebra) {
          return function (p) {
              return Data_Newtype.alaF(Data_Functor.functorFn)(Data_Functor.functorFn)(Data_Monoid_Disj.newtypeDisj)(Data_Monoid_Disj.newtypeDisj)(Data_Monoid_Disj.Disj)(foldMap(dictFoldable)(Data_Monoid_Disj.monoidDisj(dictHeytingAlgebra)))(p);
          };
      };
  };

  /**
 *  | Test whether a value is an element of a data structure.
 */  
  var elem = function (dictFoldable) {
      return function (dictEq) {
          return function ($172) {
              return any(dictFoldable)(Data_HeytingAlgebra.heytingAlgebraBoolean)(Data_Eq.eq(dictEq)($172));
          };
      };
  };

  /**
 *  | Test whether a value is not an element of a data structure.
 */  
  var notElem = function (dictFoldable) {
      return function (dictEq) {
          return function (x) {
              return function ($173) {
                  return !elem(dictFoldable)(dictEq)(x)($173);
              };
          };
      };
  };

  /**
 *  | The disjunction of all the values in a data structure. When specialized
 *  | to `Boolean`, this function will test whether any of the values in a data
 *  | structure is `true`.
 */  
  var or = function (dictFoldable) {
      return function (dictHeytingAlgebra) {
          return any(dictFoldable)(dictHeytingAlgebra)(Control_Category.id(Control_Category.categoryFn));
      };
  };

  /**
 *  | `all f` is the same as `and <<< map f`; map a function over the structure,
 *  | and then get the conjunction of the results.
 */  
  var all = function (dictFoldable) {
      return function (dictHeytingAlgebra) {
          return function (p) {
              return Data_Newtype.alaF(Data_Functor.functorFn)(Data_Functor.functorFn)(Data_Monoid_Conj.newtypeConj)(Data_Monoid_Conj.newtypeConj)(Data_Monoid_Conj.Conj)(foldMap(dictFoldable)(Data_Monoid_Conj.monoidConj(dictHeytingAlgebra)))(p);
          };
      };
  };

  /**
 *  | The conjunction of all the values in a data structure. When specialized
 *  | to `Boolean`, this function will test whether all of the values in a data
 *  | structure are `true`.
 */  
  var and = function (dictFoldable) {
      return function (dictHeytingAlgebra) {
          return all(dictFoldable)(dictHeytingAlgebra)(Control_Category.id(Control_Category.categoryFn));
      };
  };
  exports["Foldable"] = Foldable;
  exports["all"] = all;
  exports["and"] = and;
  exports["any"] = any;
  exports["elem"] = elem;
  exports["find"] = find;
  exports["findMap"] = findMap;
  exports["fold"] = fold;
  exports["foldMap"] = foldMap;
  exports["foldMapDefaultL"] = foldMapDefaultL;
  exports["foldMapDefaultR"] = foldMapDefaultR;
  exports["foldl"] = foldl;
  exports["foldlDefault"] = foldlDefault;
  exports["foldr"] = foldr;
  exports["foldrDefault"] = foldrDefault;
  exports["for_"] = for_;
  exports["intercalate"] = intercalate;
  exports["maximum"] = maximum;
  exports["maximumBy"] = maximumBy;
  exports["minimum"] = minimum;
  exports["minimumBy"] = minimumBy;
  exports["notElem"] = notElem;
  exports["oneOf"] = oneOf;
  exports["or"] = or;
  exports["product"] = product;
  exports["sequence_"] = sequence_;
  exports["sum"] = sum;
  exports["traverse_"] = traverse_;
  exports["foldableArray"] = foldableArray;
  exports["foldableMaybe"] = foldableMaybe;
  exports["foldableFirst"] = foldableFirst;
  exports["foldableLast"] = foldableLast;
  exports["foldableAdditive"] = foldableAdditive;
  exports["foldableDual"] = foldableDual;
  exports["foldableDisj"] = foldableDisj;
  exports["foldableConj"] = foldableConj;
  exports["foldableMultiplicative"] = foldableMultiplicative;
})(PS["Data.Foldable"] = PS["Data.Foldable"] || {});
(function(exports) {
    "use strict";

  exports.defer = function () {

    function Defer(thunk) {
      if (this instanceof Defer) {
        this.thunk = thunk;
        return this;
      } else {
        return new Defer(thunk);
      }
    }

    Defer.prototype.force = function () {
      var value = this.thunk();
      this.thunk = null;
      this.force = function () {
        return value;
      };
      return value;
    };

    return Defer;

  }();

  exports.force = function (l) {
    return l.force();
  };
})(PS["Data.Lazy"] = PS["Data.Lazy"] || {});
(function(exports) {
    "use strict";
  var Data_Unit = PS["Data.Unit"];        

  /**
 *  | The `Lazy` class represents types which allow evaluation of values
 *  | to be _deferred_.
 *  |
 *  | Usually, this means that a type contains a function arrow which can
 *  | be used to delay evaluation.
 */  
  var Lazy = function (defer) {
      this.defer = defer;
  };

  /**
 *  | The `Lazy` class represents types which allow evaluation of values
 *  | to be _deferred_.
 *  |
 *  | Usually, this means that a type contains a function arrow which can
 *  | be used to delay evaluation.
 */  
  var defer = function (dict) {
      return dict.defer;
  };
  var fix = function (dictLazy) {
      return function (f) {
          return defer(dictLazy)(function (v) {
              return f(fix(dictLazy)(f));
          });
      };
  };
  exports["Lazy"] = Lazy;
  exports["defer"] = defer;
  exports["fix"] = fix;
})(PS["Control.Lazy"] = PS["Control.Lazy"] || {});
(function(exports) {
    "use strict";
  var Data_Ring = PS["Data.Ring"];
  var Data_Semiring = PS["Data.Semiring"];
  var Data_Unit = PS["Data.Unit"];        

  /**
 *  | The `CommutativeRing` class is for rings where multiplication is
 *  | commutative.
 *  |
 *  | Instances must satisfy the following law in addition to the `Ring`
 *  | laws:
 *  |
 *  | - Commutative multiplication: `a * b = b * a`
 */  
  var CommutativeRing = function (__superclass_Data$dotRing$dotRing_0) {
      this["__superclass_Data.Ring.Ring_0"] = __superclass_Data$dotRing$dotRing_0;
  };
  var commutativeRingUnit = new CommutativeRing(function () {
      return Data_Ring.ringUnit;
  });
  var commutativeRingNumber = new CommutativeRing(function () {
      return Data_Ring.ringNumber;
  });
  var commutativeRingInt = new CommutativeRing(function () {
      return Data_Ring.ringInt;
  });
  exports["CommutativeRing"] = CommutativeRing;
  exports["commutativeRingInt"] = commutativeRingInt;
  exports["commutativeRingNumber"] = commutativeRingNumber;
  exports["commutativeRingUnit"] = commutativeRingUnit;
})(PS["Data.CommutativeRing"] = PS["Data.CommutativeRing"] || {});
(function(exports) {
    "use strict";

  exports.intDegree = function (x) {
    return Math.abs(x);
  };

  exports.intDiv = function (x) {
    return function (y) {
      /* jshint bitwise: false */
      return x / y | 0;
    };
  };

  exports.intMod = function (x) {
    return function (y) {
      return x % y;
    };
  };

  exports.numDiv = function (n1) {
    return function (n2) {
      return n1 / n2;
    };
  };
})(PS["Data.EuclideanRing"] = PS["Data.EuclideanRing"] || {});
(function(exports) {
    "use strict";
  var $foreign = PS["Data.EuclideanRing"];
  var Data_CommutativeRing = PS["Data.CommutativeRing"];
  var Data_Ring = PS["Data.Ring"];
  var Data_Semiring = PS["Data.Semiring"];
  var Data_Unit = PS["Data.Unit"];        

  /**
 *  | The `EuclideanRing` class is for commutative rings that support division.
 *  |
 *  | Instances must satisfy the following law in addition to the `Ring`
 *  | laws:
 *  |
 *  | - Integral domain: `a /= 0` and `b /= 0` implies `a * b /= 0`
 *  | - Multiplicative Euclidean function: ``a = (a / b) * b + (a `mod` b)``
 *  |   where `degree a > 0` and `degree a <= degree (a * b)`
 */  
  var EuclideanRing = function (__superclass_Data$dotCommutativeRing$dotCommutativeRing_0, degree, div, mod) {
      this["__superclass_Data.CommutativeRing.CommutativeRing_0"] = __superclass_Data$dotCommutativeRing$dotCommutativeRing_0;
      this.degree = degree;
      this.div = div;
      this.mod = mod;
  };

  /**
 *  | The `EuclideanRing` class is for commutative rings that support division.
 *  |
 *  | Instances must satisfy the following law in addition to the `Ring`
 *  | laws:
 *  |
 *  | - Integral domain: `a /= 0` and `b /= 0` implies `a * b /= 0`
 *  | - Multiplicative Euclidean function: ``a = (a / b) * b + (a `mod` b)``
 *  |   where `degree a > 0` and `degree a <= degree (a * b)`
 */  
  var mod = function (dict) {
      return dict.mod;
  };
  var euclideanRingUnit = new EuclideanRing(function () {
      return Data_CommutativeRing.commutativeRingUnit;
  }, function (v) {
      return 1;
  }, function (v) {
      return function (v1) {
          return Data_Unit.unit;
      };
  }, function (v) {
      return function (v1) {
          return Data_Unit.unit;
      };
  });
  var euclideanRingNumber = new EuclideanRing(function () {
      return Data_CommutativeRing.commutativeRingNumber;
  }, function (v) {
      return 1;
  }, $foreign.numDiv, function (v) {
      return function (v1) {
          return 0.0;
      };
  });
  var euclideanRingInt = new EuclideanRing(function () {
      return Data_CommutativeRing.commutativeRingInt;
  }, $foreign.intDegree, $foreign.intDiv, $foreign.intMod);

  /**
 *  | The `EuclideanRing` class is for commutative rings that support division.
 *  |
 *  | Instances must satisfy the following law in addition to the `Ring`
 *  | laws:
 *  |
 *  | - Integral domain: `a /= 0` and `b /= 0` implies `a * b /= 0`
 *  | - Multiplicative Euclidean function: ``a = (a / b) * b + (a `mod` b)``
 *  |   where `degree a > 0` and `degree a <= degree (a * b)`
 */  
  var div = function (dict) {
      return dict.div;
  };

  /**
 *  | The `EuclideanRing` class is for commutative rings that support division.
 *  |
 *  | Instances must satisfy the following law in addition to the `Ring`
 *  | laws:
 *  |
 *  | - Integral domain: `a /= 0` and `b /= 0` implies `a * b /= 0`
 *  | - Multiplicative Euclidean function: ``a = (a / b) * b + (a `mod` b)``
 *  |   where `degree a > 0` and `degree a <= degree (a * b)`
 */  
  var degree = function (dict) {
      return dict.degree;
  };
  exports["EuclideanRing"] = EuclideanRing;
  exports["degree"] = degree;
  exports["div"] = div;
  exports["mod"] = mod;
  exports["euclideanRingInt"] = euclideanRingInt;
  exports["euclideanRingNumber"] = euclideanRingNumber;
  exports["euclideanRingUnit"] = euclideanRingUnit;
})(PS["Data.EuclideanRing"] = PS["Data.EuclideanRing"] || {});
(function(exports) {
    "use strict";
  var Data_CommutativeRing = PS["Data.CommutativeRing"];
  var Data_EuclideanRing = PS["Data.EuclideanRing"];
  var Data_Ring = PS["Data.Ring"];
  var Data_Semiring = PS["Data.Semiring"];
  var Data_Unit = PS["Data.Unit"];        

  /**
 *  | The `Field` class is for types that are commutative fields.
 *  |
 *  | Instances must satisfy the following law in addition to the
 *  | `EuclideanRing` laws:
 *  |
 *  | - Non-zero multiplicative inverse: ``a `mod` b = 0` for all `a` and `b` ``
 */  
  var Field = function (__superclass_Data$dotEuclideanRing$dotEuclideanRing_0) {
      this["__superclass_Data.EuclideanRing.EuclideanRing_0"] = __superclass_Data$dotEuclideanRing$dotEuclideanRing_0;
  };
  var fieldUnit = new Field(function () {
      return Data_EuclideanRing.euclideanRingUnit;
  });
  var fieldNumber = new Field(function () {
      return Data_EuclideanRing.euclideanRingNumber;
  });
  exports["Field"] = Field;
  exports["fieldNumber"] = fieldNumber;
  exports["fieldUnit"] = fieldUnit;
})(PS["Data.Field"] = PS["Data.Field"] || {});
(function(exports) {
    "use strict";
  var Data_HeytingAlgebra = PS["Data.HeytingAlgebra"];
  var Data_Unit = PS["Data.Unit"];        

  /**
 *  | The `BooleanAlgebra` type class represents types that behave like boolean
 *  | values.
 *  |
 *  | Instances should satisfy the following laws in addition to the
 *  | `HeytingAlgebra` law:
 *  |
 *  | - Excluded middle:
 *  |   - `a || not a = tt`
 */  
  var BooleanAlgebra = function (__superclass_Data$dotHeytingAlgebra$dotHeytingAlgebra_0) {
      this["__superclass_Data.HeytingAlgebra.HeytingAlgebra_0"] = __superclass_Data$dotHeytingAlgebra$dotHeytingAlgebra_0;
  };
  var booleanAlgebraUnit = new BooleanAlgebra(function () {
      return Data_HeytingAlgebra.heytingAlgebraUnit;
  });
  var booleanAlgebraBoolean = new BooleanAlgebra(function () {
      return Data_HeytingAlgebra.heytingAlgebraBoolean;
  });
  exports["BooleanAlgebra"] = BooleanAlgebra;
  exports["booleanAlgebraBoolean"] = booleanAlgebraBoolean;
  exports["booleanAlgebraUnit"] = booleanAlgebraUnit;
})(PS["Data.BooleanAlgebra"] = PS["Data.BooleanAlgebra"] || {});
(function(exports) {
    "use strict";
  var $foreign = PS["Data.Lazy"];
  var Prelude = PS["Prelude"];
  var Control_Comonad = PS["Control.Comonad"];
  var Control_Extend = PS["Control.Extend"];
  var Control_Lazy = PS["Control.Lazy"];
  var Data_HeytingAlgebra = PS["Data.HeytingAlgebra"];
  var Data_Monoid = PS["Data.Monoid"];
  var Data_Semiring = PS["Data.Semiring"];
  var Data_Ring = PS["Data.Ring"];
  var Data_CommutativeRing = PS["Data.CommutativeRing"];
  var Data_EuclideanRing = PS["Data.EuclideanRing"];
  var Control_Semigroupoid = PS["Control.Semigroupoid"];
  var Data_Field = PS["Data.Field"];
  var Data_Eq = PS["Data.Eq"];
  var Data_Ord = PS["Data.Ord"];
  var Data_Bounded = PS["Data.Bounded"];
  var Data_Semigroup = PS["Data.Semigroup"];
  var Control_Apply = PS["Control.Apply"];
  var Data_Functor = PS["Data.Functor"];
  var Data_BooleanAlgebra = PS["Data.BooleanAlgebra"];
  var Control_Applicative = PS["Control.Applicative"];
  var Control_Bind = PS["Control.Bind"];
  var Data_Function = PS["Data.Function"];
  var Control_Monad = PS["Control.Monad"];
  var Data_Show = PS["Data.Show"];
  var Data_Unit = PS["Data.Unit"];        
  var showLazy = function (dictShow) {
      return new Data_Show.Show(function (x) {
          return "(defer \\_ -> " + (Data_Show.show(dictShow)($foreign.force(x)) + ")");
      });
  };
  var semiringLazy = function (dictSemiring) {
      return new Data_Semiring.Semiring(function (a) {
          return function (b) {
              return $foreign.defer(function (v) {
                  return Data_Semiring.add(dictSemiring)($foreign.force(a))($foreign.force(b));
              });
          };
      }, function (a) {
          return function (b) {
              return $foreign.defer(function (v) {
                  return Data_Semiring.mul(dictSemiring)($foreign.force(a))($foreign.force(b));
              });
          };
      }, $foreign.defer(function (v) {
          return Data_Semiring.one(dictSemiring);
      }), $foreign.defer(function (v) {
          return Data_Semiring.zero(dictSemiring);
      }));
  };
  var semigroupLazy = function (dictSemigroup) {
      return new Data_Semigroup.Semigroup(function (a) {
          return function (b) {
              return $foreign.defer(function (v) {
                  return Data_Semigroup.append(dictSemigroup)($foreign.force(a))($foreign.force(b));
              });
          };
      });
  };
  var ringLazy = function (dictRing) {
      return new Data_Ring.Ring(function () {
          return semiringLazy(dictRing["__superclass_Data.Semiring.Semiring_0"]());
      }, function (a) {
          return function (b) {
              return $foreign.defer(function (v) {
                  return Data_Ring.sub(dictRing)($foreign.force(a))($foreign.force(b));
              });
          };
      });
  };
  var monoidLazy = function (dictMonoid) {
      return new Data_Monoid.Monoid(function () {
          return semigroupLazy(dictMonoid["__superclass_Data.Semigroup.Semigroup_0"]());
      }, $foreign.defer(function (v) {
          return Data_Monoid.mempty(dictMonoid);
      }));
  };
  var lazyLazy = new Control_Lazy.Lazy(function (f) {
      return $foreign.defer(function (v) {
          return $foreign.force(f(Data_Unit.unit));
      });
  });
  var functorLazy = new Data_Functor.Functor(function (f) {
      return function (l) {
          return $foreign.defer(function (v) {
              return f($foreign.force(l));
          });
      };
  });
  var extendLazy = new Control_Extend.Extend(function () {
      return functorLazy;
  }, function (f) {
      return function (x) {
          return $foreign.defer(function (v) {
              return f(x);
          });
      };
  });
  var eqLazy = function (dictEq) {
      return new Data_Eq.Eq(function (x) {
          return function (y) {
              return Data_Eq.eq(dictEq)($foreign.force(x))($foreign.force(y));
          };
      });
  };
  var ordLazy = function (dictOrd) {
      return new Data_Ord.Ord(function () {
          return eqLazy(dictOrd["__superclass_Data.Eq.Eq_0"]());
      }, function (x) {
          return function (y) {
              return Data_Ord.compare(dictOrd)($foreign.force(x))($foreign.force(y));
          };
      });
  };
  var comonadLazy = new Control_Comonad.Comonad(function () {
      return extendLazy;
  }, $foreign.force);
  var commutativeRingLazy = function (dictCommutativeRing) {
      return new Data_CommutativeRing.CommutativeRing(function () {
          return ringLazy(dictCommutativeRing["__superclass_Data.Ring.Ring_0"]());
      });
  };
  var euclideanRingLazy = function (dictEuclideanRing) {
      return new Data_EuclideanRing.EuclideanRing(function () {
          return commutativeRingLazy(dictEuclideanRing["__superclass_Data.CommutativeRing.CommutativeRing_0"]());
      }, function ($51) {
          return Data_EuclideanRing.degree(dictEuclideanRing)($foreign.force($51));
      }, function (a) {
          return function (b) {
              return $foreign.defer(function (v) {
                  return Data_EuclideanRing.div(dictEuclideanRing)($foreign.force(a))($foreign.force(b));
              });
          };
      }, function (a) {
          return function (b) {
              return $foreign.defer(function (v) {
                  return Data_EuclideanRing.mod(dictEuclideanRing)($foreign.force(a))($foreign.force(b));
              });
          };
      });
  };
  var fieldLazy = function (dictField) {
      return new Data_Field.Field(function () {
          return euclideanRingLazy(dictField["__superclass_Data.EuclideanRing.EuclideanRing_0"]());
      });
  };
  var boundedLazy = function (dictBounded) {
      return new Data_Bounded.Bounded(function () {
          return ordLazy(dictBounded["__superclass_Data.Ord.Ord_0"]());
      }, $foreign.defer(function (v) {
          return Data_Bounded.bottom(dictBounded);
      }), $foreign.defer(function (v) {
          return Data_Bounded.top(dictBounded);
      }));
  };
  var applyLazy = new Control_Apply.Apply(function () {
      return functorLazy;
  }, function (f) {
      return function (x) {
          return $foreign.defer(function (v) {
              return $foreign.force(f)($foreign.force(x));
          });
      };
  });
  var bindLazy = new Control_Bind.Bind(function () {
      return applyLazy;
  }, function (l) {
      return function (f) {
          return $foreign.defer(function (v) {
              return $foreign.force(f($foreign.force(l)));
          });
      };
  });
  var heytingAlgebraLazy = function (dictHeytingAlgebra) {
      return new Data_HeytingAlgebra.HeytingAlgebra(function (a) {
          return function (b) {
              return Control_Apply.apply(applyLazy)(Data_Functor.map(functorLazy)(Data_HeytingAlgebra.conj(dictHeytingAlgebra))(a))(b);
          };
      }, function (a) {
          return function (b) {
              return Control_Apply.apply(applyLazy)(Data_Functor.map(functorLazy)(Data_HeytingAlgebra.disj(dictHeytingAlgebra))(a))(b);
          };
      }, $foreign.defer(function (v) {
          return Data_HeytingAlgebra.ff(dictHeytingAlgebra);
      }), function (a) {
          return function (b) {
              return Control_Apply.apply(applyLazy)(Data_Functor.map(functorLazy)(Data_HeytingAlgebra.implies(dictHeytingAlgebra))(a))(b);
          };
      }, function (a) {
          return Data_Functor.map(functorLazy)(Data_HeytingAlgebra.not(dictHeytingAlgebra))(a);
      }, $foreign.defer(function (v) {
          return Data_HeytingAlgebra.tt(dictHeytingAlgebra);
      }));
  };
  var booleanAlgebraLazy = function (dictBooleanAlgebra) {
      return new Data_BooleanAlgebra.BooleanAlgebra(function () {
          return heytingAlgebraLazy(dictBooleanAlgebra["__superclass_Data.HeytingAlgebra.HeytingAlgebra_0"]());
      });
  };
  var applicativeLazy = new Control_Applicative.Applicative(function () {
      return applyLazy;
  }, function (a) {
      return $foreign.defer(function (v) {
          return a;
      });
  });
  var monadLazy = new Control_Monad.Monad(function () {
      return applicativeLazy;
  }, function () {
      return bindLazy;
  });
  exports["semiringLazy"] = semiringLazy;
  exports["ringLazy"] = ringLazy;
  exports["commutativeRingLazy"] = commutativeRingLazy;
  exports["euclideanRingLazy"] = euclideanRingLazy;
  exports["fieldLazy"] = fieldLazy;
  exports["eqLazy"] = eqLazy;
  exports["ordLazy"] = ordLazy;
  exports["boundedLazy"] = boundedLazy;
  exports["semigroupLazy"] = semigroupLazy;
  exports["monoidLazy"] = monoidLazy;
  exports["heytingAlgebraLazy"] = heytingAlgebraLazy;
  exports["booleanAlgebraLazy"] = booleanAlgebraLazy;
  exports["functorLazy"] = functorLazy;
  exports["applyLazy"] = applyLazy;
  exports["applicativeLazy"] = applicativeLazy;
  exports["bindLazy"] = bindLazy;
  exports["monadLazy"] = monadLazy;
  exports["extendLazy"] = extendLazy;
  exports["comonadLazy"] = comonadLazy;
  exports["showLazy"] = showLazy;
  exports["lazyLazy"] = lazyLazy;
  exports["defer"] = $foreign.defer;
  exports["force"] = $foreign.force;
})(PS["Data.Lazy"] = PS["Data.Lazy"] || {});
(function(exports) {
    "use strict";

  // jshint maxparams: 3

  exports.traverseArrayImpl = function () {
    function Cont(fn) {
      this.fn = fn;
    }

    var emptyList = {};

    var ConsCell = function (head, tail) {
      this.head = head;
      this.tail = tail;
    };

    function consList(x) {
      return function (xs) {
        return new ConsCell(x, xs);
      };
    }

    function listToArray(list) {
      var arr = [];
      while (list !== emptyList) {
        arr.push(list.head);
        list = list.tail;
      }
      return arr;
    }

    return function (apply) {
      return function (map) {
        return function (pure) {
          return function (f) {
            var buildFrom = function (x, ys) {
              return apply(map(consList)(f(x)))(ys);
            };

            var go = function (acc, currentLen, xs) {
              if (currentLen === 0) {
                return acc;
              } else {
                var last = xs[currentLen - 1];
                return new Cont(function () {
                  return go(buildFrom(last, acc), currentLen - 1, xs);
                });
              }
            };

            return function (array) {
              var result = go(pure(emptyList), array.length, array);
              while (result instanceof Cont) {
                result = result.fn();
              }

              return map(listToArray)(result);
            };
          };
        };
      };
    };
  }();
})(PS["Data.Traversable"] = PS["Data.Traversable"] || {});
(function(exports) {
    "use strict";
  var $foreign = PS["Data.Traversable"];
  var Prelude = PS["Prelude"];
  var Data_Foldable = PS["Data.Foldable"];
  var Data_Maybe = PS["Data.Maybe"];
  var Data_Maybe_First = PS["Data.Maybe.First"];
  var Data_Maybe_Last = PS["Data.Maybe.Last"];
  var Data_Monoid_Additive = PS["Data.Monoid.Additive"];
  var Data_Monoid_Conj = PS["Data.Monoid.Conj"];
  var Data_Monoid_Disj = PS["Data.Monoid.Disj"];
  var Data_Monoid_Dual = PS["Data.Monoid.Dual"];
  var Data_Monoid_Multiplicative = PS["Data.Monoid.Multiplicative"];
  var Control_Apply = PS["Control.Apply"];
  var Data_Functor = PS["Data.Functor"];
  var Control_Applicative = PS["Control.Applicative"];
  var Control_Category = PS["Control.Category"];        
  var StateL = function (x) {
      return x;
  };
  var StateR = function (x) {
      return x;
  };

  /**
 *  | `Traversable` represents data structures which can be _traversed_,
 *  | accumulating results and effects in some `Applicative` functor.
 *  |
 *  | - `traverse` runs an action for every element in a data structure,
 *  |   and accumulates the results.
 *  | - `sequence` runs the actions _contained_ in a data structure,
 *  |   and accumulates the results.
 *  |
 *  | The `traverse` and `sequence` functions should be compatible in the
 *  | following sense:
 *  |
 *  | - `traverse f xs = sequence (f <$> xs)`
 *  | - `sequence = traverse id`
 *  |
 *  | `Traversable` instances should also be compatible with the corresponding
 *  | `Foldable` instances, in the following sense:
 *  |
 *  | - `foldMap f = runConst <<< traverse (Const <<< f)`
 *  |
 *  | Default implementations are provided by the following functions:
 *  |
 *  | - `traverseDefault`
 *  | - `sequenceDefault`
 */  
  var Traversable = function (__superclass_Data$dotFoldable$dotFoldable_1, __superclass_Data$dotFunctor$dotFunctor_0, sequence, traverse) {
      this["__superclass_Data.Foldable.Foldable_1"] = __superclass_Data$dotFoldable$dotFoldable_1;
      this["__superclass_Data.Functor.Functor_0"] = __superclass_Data$dotFunctor$dotFunctor_0;
      this.sequence = sequence;
      this.traverse = traverse;
  };

  /**
 *  | `Traversable` represents data structures which can be _traversed_,
 *  | accumulating results and effects in some `Applicative` functor.
 *  |
 *  | - `traverse` runs an action for every element in a data structure,
 *  |   and accumulates the results.
 *  | - `sequence` runs the actions _contained_ in a data structure,
 *  |   and accumulates the results.
 *  |
 *  | The `traverse` and `sequence` functions should be compatible in the
 *  | following sense:
 *  |
 *  | - `traverse f xs = sequence (f <$> xs)`
 *  | - `sequence = traverse id`
 *  |
 *  | `Traversable` instances should also be compatible with the corresponding
 *  | `Foldable` instances, in the following sense:
 *  |
 *  | - `foldMap f = runConst <<< traverse (Const <<< f)`
 *  |
 *  | Default implementations are provided by the following functions:
 *  |
 *  | - `traverseDefault`
 *  | - `sequenceDefault`
 */  
  var traverse = function (dict) {
      return dict.traverse;
  };
  var traversableMultiplicative = new Traversable(function () {
      return Data_Foldable.foldableMultiplicative;
  }, function () {
      return Data_Monoid_Multiplicative.functorMultiplicative;
  }, function (dictApplicative) {
      return function (v) {
          return Data_Functor.map((dictApplicative["__superclass_Control.Apply.Apply_0"]())["__superclass_Data.Functor.Functor_0"]())(Data_Monoid_Multiplicative.Multiplicative)(v);
      };
  }, function (dictApplicative) {
      return function (f) {
          return function (v) {
              return Data_Functor.map((dictApplicative["__superclass_Control.Apply.Apply_0"]())["__superclass_Data.Functor.Functor_0"]())(Data_Monoid_Multiplicative.Multiplicative)(f(v));
          };
      };
  });
  var traversableMaybe = new Traversable(function () {
      return Data_Foldable.foldableMaybe;
  }, function () {
      return Data_Maybe.functorMaybe;
  }, function (dictApplicative) {
      return function (v) {
          if (v instanceof Data_Maybe.Nothing) {
              return Control_Applicative.pure(dictApplicative)(Data_Maybe.Nothing.value);
          };
          if (v instanceof Data_Maybe.Just) {
              return Data_Functor.map((dictApplicative["__superclass_Control.Apply.Apply_0"]())["__superclass_Data.Functor.Functor_0"]())(Data_Maybe.Just.create)(v.value0);
          };
          throw new Error("Failed pattern match at Data.Traversable line 85, column 3 - line 85, column 35: " + [ v.constructor.name ]);
      };
  }, function (dictApplicative) {
      return function (v) {
          return function (v1) {
              if (v1 instanceof Data_Maybe.Nothing) {
                  return Control_Applicative.pure(dictApplicative)(Data_Maybe.Nothing.value);
              };
              if (v1 instanceof Data_Maybe.Just) {
                  return Data_Functor.map((dictApplicative["__superclass_Control.Apply.Apply_0"]())["__superclass_Data.Functor.Functor_0"]())(Data_Maybe.Just.create)(v(v1.value0));
              };
              throw new Error("Failed pattern match at Data.Traversable line 83, column 3 - line 83, column 37: " + [ v.constructor.name, v1.constructor.name ]);
          };
      };
  });
  var traversableDual = new Traversable(function () {
      return Data_Foldable.foldableDual;
  }, function () {
      return Data_Monoid_Dual.functorDual;
  }, function (dictApplicative) {
      return function (v) {
          return Data_Functor.map((dictApplicative["__superclass_Control.Apply.Apply_0"]())["__superclass_Data.Functor.Functor_0"]())(Data_Monoid_Dual.Dual)(v);
      };
  }, function (dictApplicative) {
      return function (f) {
          return function (v) {
              return Data_Functor.map((dictApplicative["__superclass_Control.Apply.Apply_0"]())["__superclass_Data.Functor.Functor_0"]())(Data_Monoid_Dual.Dual)(f(v));
          };
      };
  });
  var traversableDisj = new Traversable(function () {
      return Data_Foldable.foldableDisj;
  }, function () {
      return Data_Monoid_Disj.functorDisj;
  }, function (dictApplicative) {
      return function (v) {
          return Data_Functor.map((dictApplicative["__superclass_Control.Apply.Apply_0"]())["__superclass_Data.Functor.Functor_0"]())(Data_Monoid_Disj.Disj)(v);
      };
  }, function (dictApplicative) {
      return function (f) {
          return function (v) {
              return Data_Functor.map((dictApplicative["__superclass_Control.Apply.Apply_0"]())["__superclass_Data.Functor.Functor_0"]())(Data_Monoid_Disj.Disj)(f(v));
          };
      };
  });
  var traversableConj = new Traversable(function () {
      return Data_Foldable.foldableConj;
  }, function () {
      return Data_Monoid_Conj.functorConj;
  }, function (dictApplicative) {
      return function (v) {
          return Data_Functor.map((dictApplicative["__superclass_Control.Apply.Apply_0"]())["__superclass_Data.Functor.Functor_0"]())(Data_Monoid_Conj.Conj)(v);
      };
  }, function (dictApplicative) {
      return function (f) {
          return function (v) {
              return Data_Functor.map((dictApplicative["__superclass_Control.Apply.Apply_0"]())["__superclass_Data.Functor.Functor_0"]())(Data_Monoid_Conj.Conj)(f(v));
          };
      };
  });
  var traversableAdditive = new Traversable(function () {
      return Data_Foldable.foldableAdditive;
  }, function () {
      return Data_Monoid_Additive.functorAdditive;
  }, function (dictApplicative) {
      return function (v) {
          return Data_Functor.map((dictApplicative["__superclass_Control.Apply.Apply_0"]())["__superclass_Data.Functor.Functor_0"]())(Data_Monoid_Additive.Additive)(v);
      };
  }, function (dictApplicative) {
      return function (f) {
          return function (v) {
              return Data_Functor.map((dictApplicative["__superclass_Control.Apply.Apply_0"]())["__superclass_Data.Functor.Functor_0"]())(Data_Monoid_Additive.Additive)(f(v));
          };
      };
  });
  var stateR = function (v) {
      return v;
  };
  var stateL = function (v) {
      return v;
  };

  /**
 *  | A default implementation of `sequence` using `traverse`.
 */  
  var sequenceDefault = function (dictTraversable) {
      return function (dictApplicative) {
          return function (tma) {
              return traverse(dictTraversable)(dictApplicative)(Control_Category.id(Control_Category.categoryFn))(tma);
          };
      };
  };
  var traversableArray = new Traversable(function () {
      return Data_Foldable.foldableArray;
  }, function () {
      return Data_Functor.functorArray;
  }, function (dictApplicative) {
      return sequenceDefault(traversableArray)(dictApplicative);
  }, function (dictApplicative) {
      return $foreign.traverseArrayImpl(Control_Apply.apply(dictApplicative["__superclass_Control.Apply.Apply_0"]()))(Data_Functor.map((dictApplicative["__superclass_Control.Apply.Apply_0"]())["__superclass_Data.Functor.Functor_0"]()))(Control_Applicative.pure(dictApplicative));
  });

  /**
 *  | `Traversable` represents data structures which can be _traversed_,
 *  | accumulating results and effects in some `Applicative` functor.
 *  |
 *  | - `traverse` runs an action for every element in a data structure,
 *  |   and accumulates the results.
 *  | - `sequence` runs the actions _contained_ in a data structure,
 *  |   and accumulates the results.
 *  |
 *  | The `traverse` and `sequence` functions should be compatible in the
 *  | following sense:
 *  |
 *  | - `traverse f xs = sequence (f <$> xs)`
 *  | - `sequence = traverse id`
 *  |
 *  | `Traversable` instances should also be compatible with the corresponding
 *  | `Foldable` instances, in the following sense:
 *  |
 *  | - `foldMap f = runConst <<< traverse (Const <<< f)`
 *  |
 *  | Default implementations are provided by the following functions:
 *  |
 *  | - `traverseDefault`
 *  | - `sequenceDefault`
 */  
  var sequence = function (dict) {
      return dict.sequence;
  };
  var traversableFirst = new Traversable(function () {
      return Data_Foldable.foldableFirst;
  }, function () {
      return Data_Maybe_First.functorFirst;
  }, function (dictApplicative) {
      return function (v) {
          return Data_Functor.map((dictApplicative["__superclass_Control.Apply.Apply_0"]())["__superclass_Data.Functor.Functor_0"]())(Data_Maybe_First.First)(sequence(traversableMaybe)(dictApplicative)(v));
      };
  }, function (dictApplicative) {
      return function (f) {
          return function (v) {
              return Data_Functor.map((dictApplicative["__superclass_Control.Apply.Apply_0"]())["__superclass_Data.Functor.Functor_0"]())(Data_Maybe_First.First)(traverse(traversableMaybe)(dictApplicative)(f)(v));
          };
      };
  });
  var traversableLast = new Traversable(function () {
      return Data_Foldable.foldableLast;
  }, function () {
      return Data_Maybe_Last.functorLast;
  }, function (dictApplicative) {
      return function (v) {
          return Data_Functor.map((dictApplicative["__superclass_Control.Apply.Apply_0"]())["__superclass_Data.Functor.Functor_0"]())(Data_Maybe_Last.Last)(sequence(traversableMaybe)(dictApplicative)(v));
      };
  }, function (dictApplicative) {
      return function (f) {
          return function (v) {
              return Data_Functor.map((dictApplicative["__superclass_Control.Apply.Apply_0"]())["__superclass_Data.Functor.Functor_0"]())(Data_Maybe_Last.Last)(traverse(traversableMaybe)(dictApplicative)(f)(v));
          };
      };
  });

  /**
 *  | A default implementation of `traverse` using `sequence` and `map`.
 */  
  var traverseDefault = function (dictTraversable) {
      return function (dictApplicative) {
          return function (f) {
              return function (ta) {
                  return sequence(dictTraversable)(dictApplicative)(Data_Functor.map(dictTraversable["__superclass_Data.Functor.Functor_0"]())(f)(ta));
              };
          };
      };
  };
  var functorStateR = new Data_Functor.Functor(function (f) {
      return function (k) {
          return function (s) {
              var $75 = stateR(k)(s);
              return {
                  accum: $75.accum, 
                  value: f($75.value)
              };
          };
      };
  });
  var functorStateL = new Data_Functor.Functor(function (f) {
      return function (k) {
          return function (s) {
              var $78 = stateL(k)(s);
              return {
                  accum: $78.accum, 
                  value: f($78.value)
              };
          };
      };
  });

  /**
 *  | A version of `traverse` with its arguments flipped.
 *  |
 *  |
 *  | This can be useful when running an action written using do notation
 *  | for every element in a data structure:
 *  |
 *  | For example:
 *  |
 *  | ```purescript
 *  | for [1, 2, 3] \n -> do
 *  |   print n
 *  |   return (n * n)
 *  | ```
 */  
  var $$for = function (dictApplicative) {
      return function (dictTraversable) {
          return function (x) {
              return function (f) {
                  return traverse(dictTraversable)(dictApplicative)(f)(x);
              };
          };
      };
  };
  var applyStateR = new Control_Apply.Apply(function () {
      return functorStateR;
  }, function (f) {
      return function (x) {
          return function (s) {
              var $81 = stateR(x)(s);
              var $82 = stateR(f)($81.accum);
              return {
                  accum: $82.accum, 
                  value: $82.value($81.value)
              };
          };
      };
  });
  var applyStateL = new Control_Apply.Apply(function () {
      return functorStateL;
  }, function (f) {
      return function (x) {
          return function (s) {
              var $87 = stateL(f)(s);
              var $88 = stateL(x)($87.accum);
              return {
                  accum: $88.accum, 
                  value: $87.value($88.value)
              };
          };
      };
  });
  var applicativeStateR = new Control_Applicative.Applicative(function () {
      return applyStateR;
  }, function (a) {
      return function (s) {
          return {
              accum: s, 
              value: a
          };
      };
  });

  /**
 *  | Fold a data structure from the right, keeping all intermediate results
 *  | instead of only the final result.
 *  |
 *  | Unlike `scanr`, `mapAccumR` allows the type of accumulator to differ
 *  | from the element type of the final data structure.
 */  
  var mapAccumR = function (dictTraversable) {
      return function (f) {
          return function (s0) {
              return function (xs) {
                  return stateR(traverse(dictTraversable)(applicativeStateR)(function (a) {
                      return function (s) {
                          return f(s)(a);
                      };
                  })(xs))(s0);
              };
          };
      };
  };

  /**
 *  | Fold a data structure from the right, keeping all intermediate results
 *  | instead of only the final result. Note that the initial value does not
 *  | appear in the result (unlike Haskell's `Prelude.scanr`).
 *  |
 *  | ```purescript
 *  | scanr (+) 0  [1,2,3] = [1,3,6]
 *  | scanr (flip (-)) 10 [1,2,3] = [4,5,7]
 *  | ```
 */  
  var scanr = function (dictTraversable) {
      return function (f) {
          return function (b0) {
              return function (xs) {
                  return (mapAccumR(dictTraversable)(function (b) {
                      return function (a) {
                          var b$prime = f(a)(b);
                          return {
                              accum: b$prime, 
                              value: b$prime
                          };
                      };
                  })(b0)(xs)).value;
              };
          };
      };
  };
  var applicativeStateL = new Control_Applicative.Applicative(function () {
      return applyStateL;
  }, function (a) {
      return function (s) {
          return {
              accum: s, 
              value: a
          };
      };
  });

  /**
 *  | Fold a data structure from the left, keeping all intermediate results
 *  | instead of only the final result.
 *  |
 *  | Unlike `scanl`, `mapAccumL` allows the type of accumulator to differ
 *  | from the element type of the final data structure.
 */  
  var mapAccumL = function (dictTraversable) {
      return function (f) {
          return function (s0) {
              return function (xs) {
                  return stateL(traverse(dictTraversable)(applicativeStateL)(function (a) {
                      return function (s) {
                          return f(s)(a);
                      };
                  })(xs))(s0);
              };
          };
      };
  };

  /**
 *  | Fold a data structure from the left, keeping all intermediate results
 *  | instead of only the final result. Note that the initial value does not
 *  | appear in the result (unlike Haskell's `Prelude.scanl`).
 *  |
 *  | ```purescript
 *  | scanl (+) 0  [1,2,3] = [1,3,6]
 *  | scanl (-) 10 [1,2,3] = [9,7,4]
 *  | ```
 */  
  var scanl = function (dictTraversable) {
      return function (f) {
          return function (b0) {
              return function (xs) {
                  return (mapAccumL(dictTraversable)(function (b) {
                      return function (a) {
                          var b$prime = f(b)(a);
                          return {
                              accum: b$prime, 
                              value: b$prime
                          };
                      };
                  })(b0)(xs)).value;
              };
          };
      };
  };
  exports["Traversable"] = Traversable;
  exports["for"] = $$for;
  exports["mapAccumL"] = mapAccumL;
  exports["mapAccumR"] = mapAccumR;
  exports["scanl"] = scanl;
  exports["scanr"] = scanr;
  exports["sequence"] = sequence;
  exports["sequenceDefault"] = sequenceDefault;
  exports["traverse"] = traverse;
  exports["traverseDefault"] = traverseDefault;
  exports["traversableArray"] = traversableArray;
  exports["traversableMaybe"] = traversableMaybe;
  exports["traversableFirst"] = traversableFirst;
  exports["traversableLast"] = traversableLast;
  exports["traversableAdditive"] = traversableAdditive;
  exports["traversableDual"] = traversableDual;
  exports["traversableConj"] = traversableConj;
  exports["traversableDisj"] = traversableDisj;
  exports["traversableMultiplicative"] = traversableMultiplicative;
})(PS["Data.Traversable"] = PS["Data.Traversable"] || {});
(function(exports) {
  
  /**
 *  | The _cofree comonad_ for a `Functor`.
 */  
  "use strict";
  var Prelude = PS["Prelude"];
  var Control_Alternative = PS["Control.Alternative"];
  var Control_Comonad = PS["Control.Comonad"];
  var Control_Extend = PS["Control.Extend"];
  var Data_Foldable = PS["Data.Foldable"];
  var Data_Lazy = PS["Data.Lazy"];
  var Data_Traversable = PS["Data.Traversable"];
  var Data_Functor = PS["Data.Functor"];
  var Data_Function = PS["Data.Function"];
  var Data_Semigroup = PS["Data.Semigroup"];
  var Control_Category = PS["Control.Category"];
  var Control_Apply = PS["Control.Apply"];
  var Control_Applicative = PS["Control.Applicative"];
  var Control_Plus = PS["Control.Plus"];
  var Control_Bind = PS["Control.Bind"];
  var Control_Alt = PS["Control.Alt"];
  var Control_Monad = PS["Control.Monad"];
  var Control_Semigroupoid = PS["Control.Semigroupoid"];        

  /**
 *  | The `Cofree` `Comonad` for a functor.
 *  |
 *  | A value of type `Cofree f a` consists of an `f`-branching
 *  | tree, annotated with labels of type `a`.
 *  |
 *  | The `Comonad` instance supports _redecoration_, recomputing
 *  | labels from the local context.
 */  
  var Cofree = (function () {
      function Cofree(value0, value1) {
          this.value0 = value0;
          this.value1 = value1;
      };
      Cofree.create = function (value0) {
          return function (value1) {
              return new Cofree(value0, value1);
          };
      };
      return Cofree;
  })();
  var unfoldCofree = function (dictFunctor) {
      return function (s) {
          return function (e) {
              return function (n) {
                  return new Cofree(e(s), Data_Lazy.defer(function (v) {
                      return Data_Functor.map(dictFunctor)(function (s1) {
                          return unfoldCofree(dictFunctor)(s1)(e)(n);
                      })(n(s));
                  }));
              };
          };
      };
  };

  /**
 *  | Returns the "subtrees" of a tree.
 */  
  var tail = function (v) {
      return Data_Lazy.force(v.value1);
  };

  /**
 *  | Create a value of type `Cofree f a` from a label and a
 *  | functor-full of "subtrees".
 */  
  var mkCofree = function (a) {
      return function (t) {
          return new Cofree(a, Data_Lazy.defer(function (v) {
              return t;
          }));
      };
  };

  /**
 *  | Returns the label for a tree.
 */  
  var head = function (v) {
      return v.value0;
  };
  var hoistCofree = function (dictFunctor) {
      return function (nat) {
          return function (cf) {
              return mkCofree(head(cf))(nat(Data_Functor.map(dictFunctor)(hoistCofree(dictFunctor)(nat))(tail(cf))));
          };
      };
  };
  var foldableCofree = function (dictFoldable) {
      return new Data_Foldable.Foldable(function (dictMonoid) {
          return function (f) {
              var go = function (fa) {
                  return Data_Semigroup.append(dictMonoid["__superclass_Data.Semigroup.Semigroup_0"]())(f(head(fa)))(Data_Foldable.foldMap(dictFoldable)(dictMonoid)(go)(tail(fa)));
              };
              return go;
          };
      }, function (f) {
          var go = function (b) {
              return function (fa) {
                  return Data_Foldable.foldl(dictFoldable)(go)(f(b)(head(fa)))(tail(fa));
              };
          };
          return go;
      }, function (f) {
          var go = function (fa) {
              return function (b) {
                  return f(head(fa))(Data_Foldable.foldr(dictFoldable)(go)(b)(tail(fa)));
              };
          };
          return Data_Function.flip(go);
      });
  };
  var _tail = function (v) {
      return v.value1;
  };
  var _lift = function (dictFunctor) {
      return function ($31) {
          return Data_Functor.map(Data_Lazy.functorLazy)(Data_Functor.map(dictFunctor)($31));
      };
  };
  var functorCofree = function (dictFunctor) {
      return new Data_Functor.Functor(function (f) {
          var loop = function (fa) {
              return new Cofree(f(head(fa)), _lift(dictFunctor)(loop)(_tail(fa)));
          };
          return loop;
      });
  };
  var applyCofree = function (dictApply) {
      return new Control_Apply.Apply(function () {
          return functorCofree(dictApply["__superclass_Data.Functor.Functor_0"]());
      }, function (f) {
          return function (x) {
              var t = Control_Apply.apply(dictApply)(Data_Functor.map(dictApply["__superclass_Data.Functor.Functor_0"]())(Control_Apply.apply(applyCofree(dictApply)))(tail(f)))(tail(x));
              var h = head(f)(head(x));
              return mkCofree(h)(t);
          };
      });
  };
  var applicativeCofree = function (dictAlternative) {
      return new Control_Applicative.Applicative(function () {
          return applyCofree((dictAlternative["__superclass_Control.Applicative.Applicative_0"]())["__superclass_Control.Apply.Apply_0"]());
      }, function (a) {
          return mkCofree(a)(Control_Plus.empty(dictAlternative["__superclass_Control.Plus.Plus_1"]()));
      });
  };
  var bindCofree = function (dictAlternative) {
      return new Control_Bind.Bind(function () {
          return applyCofree((dictAlternative["__superclass_Control.Applicative.Applicative_0"]())["__superclass_Control.Apply.Apply_0"]());
      }, function (fa) {
          return function (f) {
              var loop = function (fa1) {
                  var fh = f(head(fa1));
                  return mkCofree(head(fh))(Control_Alt.alt((dictAlternative["__superclass_Control.Plus.Plus_1"]())["__superclass_Control.Alt.Alt_0"]())(tail(fh))(Data_Functor.map(((dictAlternative["__superclass_Control.Plus.Plus_1"]())["__superclass_Control.Alt.Alt_0"]())["__superclass_Data.Functor.Functor_0"]())(loop)(tail(fa1))));
              };
              return loop(fa);
          };
      });
  };
  var monadCofree = function (dictAlternative) {
      return new Control_Monad.Monad(function () {
          return applicativeCofree(dictAlternative);
      }, function () {
          return bindCofree(dictAlternative);
      });
  };
  var extendCofree = function (dictFunctor) {
      return new Control_Extend.Extend(function () {
          return functorCofree(dictFunctor);
      }, function (f) {
          var loop = function (fa) {
              return new Cofree(f(fa), _lift(dictFunctor)(loop)(_tail(fa)));
          };
          return loop;
      });
  };
  var comonadCofree = function (dictFunctor) {
      return new Control_Comonad.Comonad(function () {
          return extendCofree(dictFunctor);
      }, head);
  };
  var traversableCofree = function (dictTraversable) {
      return new Data_Traversable.Traversable(function () {
          return foldableCofree(dictTraversable["__superclass_Data.Foldable.Foldable_1"]());
      }, function () {
          return functorCofree(dictTraversable["__superclass_Data.Functor.Functor_0"]());
      }, function (dictApplicative) {
          return Data_Traversable.traverse(traversableCofree(dictTraversable))(dictApplicative)(Control_Category.id(Control_Category.categoryFn));
      }, function (dictApplicative) {
          return function (f) {
              var loop = function (ta) {
                  return Control_Apply.apply(dictApplicative["__superclass_Control.Apply.Apply_0"]())(Data_Functor.map((dictApplicative["__superclass_Control.Apply.Apply_0"]())["__superclass_Data.Functor.Functor_0"]())(mkCofree)(f(head(ta))))(Data_Traversable.traverse(dictTraversable)(dictApplicative)(loop)(tail(ta)));
              };
              return loop;
          };
      });
  };
  exports["head"] = head;
  exports["hoistCofree"] = hoistCofree;
  exports["mkCofree"] = mkCofree;
  exports["tail"] = tail;
  exports["unfoldCofree"] = unfoldCofree;
  exports["functorCofree"] = functorCofree;
  exports["foldableCofree"] = foldableCofree;
  exports["traversableCofree"] = traversableCofree;
  exports["extendCofree"] = extendCofree;
  exports["comonadCofree"] = comonadCofree;
  exports["applyCofree"] = applyCofree;
  exports["applicativeCofree"] = applicativeCofree;
  exports["bindCofree"] = bindCofree;
  exports["monadCofree"] = monadCofree;
})(PS["Control.Comonad.Cofree"] = PS["Control.Comonad.Cofree"] || {});
(function(exports) {
  
  /**
 *  | This module defines the `ComonadTrans` type class of _comonad transformers_.
 */  
  "use strict";
  var Control_Comonad = PS["Control.Comonad"];        

  /**
 *  | The `ComonadTrans` type class represents _comonad transformers_.
 *  |
 *  | A comonad transformer is a type constructor of kind `(* -> *) -> * -> *`, which
 *  | takes a `Comonad` as its first argument, and returns another `Comonad`.
 *  |
 *  | This allows us to extend a comonad to provide additional context. By iterating this
 *  | process, we create comonad transformer _stacks_, which contain all of the contextual information
 *  | required for a particular computation.
 *  |
 *  | The laws state that `lower` is a `Comonad` morphism.
 *  |
 *  | Laws:
 *  |
 *  | - `extract (lower a) = extract a`
 *  | - `lower (extend w (f <<< lower)) = extend (lower w) f`
 */  
  var ComonadTrans = function (lower) {
      this.lower = lower;
  };

  /**
 *  | The `ComonadTrans` type class represents _comonad transformers_.
 *  |
 *  | A comonad transformer is a type constructor of kind `(* -> *) -> * -> *`, which
 *  | takes a `Comonad` as its first argument, and returns another `Comonad`.
 *  |
 *  | This allows us to extend a comonad to provide additional context. By iterating this
 *  | process, we create comonad transformer _stacks_, which contain all of the contextual information
 *  | required for a particular computation.
 *  |
 *  | The laws state that `lower` is a `Comonad` morphism.
 *  |
 *  | Laws:
 *  |
 *  | - `extract (lower a) = extract a`
 *  | - `lower (extend w (f <<< lower)) = extend (lower w) f`
 */  
  var lower = function (dict) {
      return dict.lower;
  };
  exports["ComonadTrans"] = ComonadTrans;
  exports["lower"] = lower;
})(PS["Control.Comonad.Trans.Class"] = PS["Control.Comonad.Trans.Class"] || {});
(function(exports) {
    "use strict";
  var Prelude = PS["Prelude"];
  var Control_Apply = PS["Control.Apply"];
  var Data_Monoid = PS["Data.Monoid"];
  var Data_Monoid_Conj = PS["Data.Monoid.Conj"];
  var Data_Monoid_Disj = PS["Data.Monoid.Disj"];
  var Data_Monoid_Dual = PS["Data.Monoid.Dual"];
  var Data_Monoid_Endo = PS["Data.Monoid.Endo"];
  var Data_Newtype = PS["Data.Newtype"];
  var Control_Semigroupoid = PS["Control.Semigroupoid"];
  var Control_Applicative = PS["Control.Applicative"];
  var Data_Unit = PS["Data.Unit"];
  var Control_Category = PS["Control.Category"];
  var Data_Semigroup = PS["Data.Semigroup"];
  var Data_Function = PS["Data.Function"];        

  /**
 *  | `Bifoldable` represents data structures with two type arguments which can be
 *  | folded.
 *  |
 *  | A fold for such a structure requires two step functions, one for each type
 *  | argument. Type class instances should choose the appropriate step function based
 *  | on the type of the element encountered at each point of the fold.
 *  |
 *  | Default implementations are provided by the following functions:
 *  |
 *  | - `bifoldrDefault`
 *  | - `bifoldlDefault`
 *  | - `bifoldMapDefaultR`
 *  | - `bifoldMapDefaultL`
 *  |
 *  | Note: some combinations of the default implementations are unsafe to
 *  | use together - causing a non-terminating mutually recursive cycle.
 *  | These combinations are documented per function.
 */  
  var Bifoldable = function (bifoldMap, bifoldl, bifoldr) {
      this.bifoldMap = bifoldMap;
      this.bifoldl = bifoldl;
      this.bifoldr = bifoldr;
  };

  /**
 *  | `Bifoldable` represents data structures with two type arguments which can be
 *  | folded.
 *  |
 *  | A fold for such a structure requires two step functions, one for each type
 *  | argument. Type class instances should choose the appropriate step function based
 *  | on the type of the element encountered at each point of the fold.
 *  |
 *  | Default implementations are provided by the following functions:
 *  |
 *  | - `bifoldrDefault`
 *  | - `bifoldlDefault`
 *  | - `bifoldMapDefaultR`
 *  | - `bifoldMapDefaultL`
 *  |
 *  | Note: some combinations of the default implementations are unsafe to
 *  | use together - causing a non-terminating mutually recursive cycle.
 *  | These combinations are documented per function.
 */  
  var bifoldr = function (dict) {
      return dict.bifoldr;
  };

  /**
 *  | Traverse a data structure, accumulating effects using an `Applicative` functor,
 *  | ignoring the final result.
 */  
  var bitraverse_ = function (dictBifoldable) {
      return function (dictApplicative) {
          return function (f) {
              return function (g) {
                  return bifoldr(dictBifoldable)(function ($18) {
                      return Control_Apply.applySecond(dictApplicative["__superclass_Control.Apply.Apply_0"]())(f($18));
                  })(function ($19) {
                      return Control_Apply.applySecond(dictApplicative["__superclass_Control.Apply.Apply_0"]())(g($19));
                  })(Control_Applicative.pure(dictApplicative)(Data_Unit.unit));
              };
          };
      };
  };

  /**
 *  | A version of `bitraverse_` with the data structure as the first argument.
 */  
  var bifor_ = function (dictBifoldable) {
      return function (dictApplicative) {
          return function (t) {
              return function (f) {
                  return function (g) {
                      return bitraverse_(dictBifoldable)(dictApplicative)(f)(g)(t);
                  };
              };
          };
      };
  };

  /**
 *  | Collapse a data structure, collecting effects using an `Applicative` functor,
 *  | ignoring the final result.
 */  
  var bisequence_ = function (dictBifoldable) {
      return function (dictApplicative) {
          return bitraverse_(dictBifoldable)(dictApplicative)(Control_Category.id(Control_Category.categoryFn))(Control_Category.id(Control_Category.categoryFn));
      };
  };

  /**
 *  | `Bifoldable` represents data structures with two type arguments which can be
 *  | folded.
 *  |
 *  | A fold for such a structure requires two step functions, one for each type
 *  | argument. Type class instances should choose the appropriate step function based
 *  | on the type of the element encountered at each point of the fold.
 *  |
 *  | Default implementations are provided by the following functions:
 *  |
 *  | - `bifoldrDefault`
 *  | - `bifoldlDefault`
 *  | - `bifoldMapDefaultR`
 *  | - `bifoldMapDefaultL`
 *  |
 *  | Note: some combinations of the default implementations are unsafe to
 *  | use together - causing a non-terminating mutually recursive cycle.
 *  | These combinations are documented per function.
 */  
  var bifoldl = function (dict) {
      return dict.bifoldl;
  };

  /**
 *  | A default implementation of `bifoldMap` using `bifoldr`.
 *  |
 *  | Note: when defining a `Bifoldable` instance, this function is unsafe to
 *  | use in combination with `bifoldrDefault`.
 */  
  var bifoldMapDefaultR = function (dictBifoldable) {
      return function (dictMonoid) {
          return function (f) {
              return function (g) {
                  return function (p) {
                      return bifoldr(dictBifoldable)(function ($20) {
                          return Data_Semigroup.append(dictMonoid["__superclass_Data.Semigroup.Semigroup_0"]())(f($20));
                      })(function ($21) {
                          return Data_Semigroup.append(dictMonoid["__superclass_Data.Semigroup.Semigroup_0"]())(g($21));
                      })(Data_Monoid.mempty(dictMonoid))(p);
                  };
              };
          };
      };
  };

  /**
 *  | A default implementation of `bifoldMap` using `bifoldl`.
 *  |
 *  | Note: when defining a `Bifoldable` instance, this function is unsafe to
 *  | use in combination with `bifoldlDefault`.
 */  
  var bifoldMapDefaultL = function (dictBifoldable) {
      return function (dictMonoid) {
          return function (f) {
              return function (g) {
                  return function (p) {
                      return bifoldl(dictBifoldable)(function (m) {
                          return function (a) {
                              return Data_Semigroup.append(dictMonoid["__superclass_Data.Semigroup.Semigroup_0"]())(m)(f(a));
                          };
                      })(function (m) {
                          return function (b) {
                              return Data_Semigroup.append(dictMonoid["__superclass_Data.Semigroup.Semigroup_0"]())(m)(g(b));
                          };
                      })(Data_Monoid.mempty(dictMonoid))(p);
                  };
              };
          };
      };
  };

  /**
 *  | `Bifoldable` represents data structures with two type arguments which can be
 *  | folded.
 *  |
 *  | A fold for such a structure requires two step functions, one for each type
 *  | argument. Type class instances should choose the appropriate step function based
 *  | on the type of the element encountered at each point of the fold.
 *  |
 *  | Default implementations are provided by the following functions:
 *  |
 *  | - `bifoldrDefault`
 *  | - `bifoldlDefault`
 *  | - `bifoldMapDefaultR`
 *  | - `bifoldMapDefaultL`
 *  |
 *  | Note: some combinations of the default implementations are unsafe to
 *  | use together - causing a non-terminating mutually recursive cycle.
 *  | These combinations are documented per function.
 */  
  var bifoldMap = function (dict) {
      return dict.bifoldMap;
  };

  /**
 *  | A default implementation of `bifoldl` using `bifoldMap`.
 *  |
 *  | Note: when defining a `Bifoldable` instance, this function is unsafe to
 *  | use in combination with `bifoldMapDefaultL`.
 */  
  var bifoldlDefault = function (dictBifoldable) {
      return function (f) {
          return function (g) {
              return function (z) {
                  return function (p) {
                      return Data_Newtype.unwrap(Data_Monoid_Endo.newtypeEndo)(Data_Newtype.unwrap(Data_Monoid_Dual.newtypeDual)(bifoldMap(dictBifoldable)(Data_Monoid_Dual.monoidDual(Data_Monoid_Endo.monoidEndo))(function ($22) {
                          return Data_Monoid_Dual.Dual(Data_Monoid_Endo.Endo(Data_Function.flip(f)($22)));
                      })(function ($23) {
                          return Data_Monoid_Dual.Dual(Data_Monoid_Endo.Endo(Data_Function.flip(g)($23)));
                      })(p)))(z);
                  };
              };
          };
      };
  };

  /**
 *  | A default implementation of `bifoldr` using `bifoldMap`.
 *  |
 *  | Note: when defining a `Bifoldable` instance, this function is unsafe to
 *  | use in combination with `bifoldMapDefaultR`.
 */  
  var bifoldrDefault = function (dictBifoldable) {
      return function (f) {
          return function (g) {
              return function (z) {
                  return function (p) {
                      return Data_Newtype.unwrap(Data_Monoid_Endo.newtypeEndo)(bifoldMap(dictBifoldable)(Data_Monoid_Endo.monoidEndo)(function ($24) {
                          return Data_Monoid_Endo.Endo(f($24));
                      })(function ($25) {
                          return Data_Monoid_Endo.Endo(g($25));
                      })(p))(z);
                  };
              };
          };
      };
  };

  /**
 *  | Fold a data structure, accumulating values in a monoidal type.
 */  
  var bifold = function (dictBifoldable) {
      return function (dictMonoid) {
          return bifoldMap(dictBifoldable)(dictMonoid)(Control_Category.id(Control_Category.categoryFn))(Control_Category.id(Control_Category.categoryFn));
      };
  };

  /**
 *  | Test whether a predicate holds at any position in a data structure.
 */  
  var biany = function (dictBifoldable) {
      return function (dictBooleanAlgebra) {
          return function (p) {
              return function (q) {
                  return function ($26) {
                      return Data_Newtype.unwrap(Data_Monoid_Disj.newtypeDisj)(bifoldMap(dictBifoldable)(Data_Monoid_Disj.monoidDisj(dictBooleanAlgebra["__superclass_Data.HeytingAlgebra.HeytingAlgebra_0"]()))(function ($27) {
                          return Data_Monoid_Disj.Disj(p($27));
                      })(function ($28) {
                          return Data_Monoid_Disj.Disj(q($28));
                      })($26));
                  };
              };
          };
      };
  };

  /**
 *  | Test whether a predicate holds at all positions in a data structure.
 */  
  var biall = function (dictBifoldable) {
      return function (dictBooleanAlgebra) {
          return function (p) {
              return function (q) {
                  return function ($29) {
                      return Data_Newtype.unwrap(Data_Monoid_Conj.newtypeConj)(bifoldMap(dictBifoldable)(Data_Monoid_Conj.monoidConj(dictBooleanAlgebra["__superclass_Data.HeytingAlgebra.HeytingAlgebra_0"]()))(function ($30) {
                          return Data_Monoid_Conj.Conj(p($30));
                      })(function ($31) {
                          return Data_Monoid_Conj.Conj(q($31));
                      })($29));
                  };
              };
          };
      };
  };
  exports["Bifoldable"] = Bifoldable;
  exports["biall"] = biall;
  exports["biany"] = biany;
  exports["bifold"] = bifold;
  exports["bifoldMap"] = bifoldMap;
  exports["bifoldMapDefaultL"] = bifoldMapDefaultL;
  exports["bifoldMapDefaultR"] = bifoldMapDefaultR;
  exports["bifoldl"] = bifoldl;
  exports["bifoldlDefault"] = bifoldlDefault;
  exports["bifoldr"] = bifoldr;
  exports["bifoldrDefault"] = bifoldrDefault;
  exports["bifor_"] = bifor_;
  exports["bisequence_"] = bisequence_;
  exports["bitraverse_"] = bitraverse_;
})(PS["Data.Bifoldable"] = PS["Data.Bifoldable"] || {});
(function(exports) {
    "use strict";
  var Prelude = PS["Prelude"];
  var Data_Bifoldable = PS["Data.Bifoldable"];
  var Data_Bifunctor = PS["Data.Bifunctor"];
  var Control_Category = PS["Control.Category"];        

  /**
 *  | `Bitraversable` represents data structures with two type arguments which can be
 *  | traversed.
 *  |
 *  | A traversal for such a structure requires two functions, one for each type
 *  | argument. Type class instances should choose the appropriate function based
 *  | on the type of the element encountered at each point of the traversal.
 *  |
 *  | Default implementations are provided by the following functions:
 *  |
 *  | - `bitraverseDefault`
 *  | - `bisequenceDefault`
 */  
  var Bitraversable = function (__superclass_Data$dotBifoldable$dotBifoldable_1, __superclass_Data$dotBifunctor$dotBifunctor_0, bisequence, bitraverse) {
      this["__superclass_Data.Bifoldable.Bifoldable_1"] = __superclass_Data$dotBifoldable$dotBifoldable_1;
      this["__superclass_Data.Bifunctor.Bifunctor_0"] = __superclass_Data$dotBifunctor$dotBifunctor_0;
      this.bisequence = bisequence;
      this.bitraverse = bitraverse;
  };

  /**
 *  | `Bitraversable` represents data structures with two type arguments which can be
 *  | traversed.
 *  |
 *  | A traversal for such a structure requires two functions, one for each type
 *  | argument. Type class instances should choose the appropriate function based
 *  | on the type of the element encountered at each point of the traversal.
 *  |
 *  | Default implementations are provided by the following functions:
 *  |
 *  | - `bitraverseDefault`
 *  | - `bisequenceDefault`
 */  
  var bitraverse = function (dict) {
      return dict.bitraverse;
  };

  /**
 *  | A default implementation of `bisequence` using `bitraverse`.
 */  
  var bisequenceDefault = function (dictBitraversable) {
      return function (dictApplicative) {
          return function (t) {
              return bitraverse(dictBitraversable)(dictApplicative)(Control_Category.id(Control_Category.categoryFn))(Control_Category.id(Control_Category.categoryFn))(t);
          };
      };
  };

  /**
 *  | `Bitraversable` represents data structures with two type arguments which can be
 *  | traversed.
 *  |
 *  | A traversal for such a structure requires two functions, one for each type
 *  | argument. Type class instances should choose the appropriate function based
 *  | on the type of the element encountered at each point of the traversal.
 *  |
 *  | Default implementations are provided by the following functions:
 *  |
 *  | - `bitraverseDefault`
 *  | - `bisequenceDefault`
 */  
  var bisequence = function (dict) {
      return dict.bisequence;
  };

  /**
 *  | A default implementation of `bitraverse` using `bisequence` and `bimap`.
 */  
  var bitraverseDefault = function (dictBitraversable) {
      return function (dictApplicative) {
          return function (f) {
              return function (g) {
                  return function (t) {
                      return bisequence(dictBitraversable)(dictApplicative)(Data_Bifunctor.bimap(dictBitraversable["__superclass_Data.Bifunctor.Bifunctor_0"]())(f)(g)(t));
                  };
              };
          };
      };
  };

  /**
 *  | Traverse a data structure, accumulating effects and results using an `Applicative` functor.
 */  
  var bifor = function (dictBitraversable) {
      return function (dictApplicative) {
          return function (t) {
              return function (f) {
                  return function (g) {
                      return bitraverse(dictBitraversable)(dictApplicative)(f)(g)(t);
                  };
              };
          };
      };
  };
  exports["Bitraversable"] = Bitraversable;
  exports["bifor"] = bifor;
  exports["bisequence"] = bisequence;
  exports["bisequenceDefault"] = bisequenceDefault;
  exports["bitraverse"] = bitraverse;
  exports["bitraverseDefault"] = bitraverseDefault;
})(PS["Data.Bitraversable"] = PS["Data.Bitraversable"] || {});
(function(exports) {
  
  /**
 *  | A data type and functions for working with ordered pairs.
 */  
  "use strict";
  var Prelude = PS["Prelude"];
  var Control_Biapplicative = PS["Control.Biapplicative"];
  var Control_Biapply = PS["Control.Biapply"];
  var Control_Comonad = PS["Control.Comonad"];
  var Control_Extend = PS["Control.Extend"];
  var Control_Lazy = PS["Control.Lazy"];
  var Data_Bifoldable = PS["Data.Bifoldable"];
  var Data_Bifunctor = PS["Data.Bifunctor"];
  var Data_Bitraversable = PS["Data.Bitraversable"];
  var Data_Foldable = PS["Data.Foldable"];
  var Data_Functor_Invariant = PS["Data.Functor.Invariant"];
  var Data_HeytingAlgebra = PS["Data.HeytingAlgebra"];
  var Data_Maybe = PS["Data.Maybe"];
  var Data_Maybe_First = PS["Data.Maybe.First"];
  var Data_Monoid = PS["Data.Monoid"];
  var Data_Newtype = PS["Data.Newtype"];
  var Data_Traversable = PS["Data.Traversable"];
  var Data_Show = PS["Data.Show"];
  var Data_Semigroup = PS["Data.Semigroup"];
  var Data_Eq = PS["Data.Eq"];
  var Data_Ord = PS["Data.Ord"];
  var Data_Ordering = PS["Data.Ordering"];
  var Data_Bounded = PS["Data.Bounded"];
  var Control_Semigroupoid = PS["Control.Semigroupoid"];
  var Data_Semiring = PS["Data.Semiring"];
  var Data_Ring = PS["Data.Ring"];
  var Data_CommutativeRing = PS["Data.CommutativeRing"];
  var Data_BooleanAlgebra = PS["Data.BooleanAlgebra"];
  var Data_Functor = PS["Data.Functor"];
  var Control_Apply = PS["Control.Apply"];
  var Control_Applicative = PS["Control.Applicative"];
  var Control_Bind = PS["Control.Bind"];
  var Control_Monad = PS["Control.Monad"];
  var Data_Function = PS["Data.Function"];
  var Data_Unit = PS["Data.Unit"];        

  /**
 *  | A simple product type for wrapping a pair of component values.
 */  
  var Tuple = (function () {
      function Tuple(value0, value1) {
          this.value0 = value0;
          this.value1 = value1;
      };
      Tuple.create = function (value0) {
          return function (value1) {
              return new Tuple(value0, value1);
          };
      };
      return Tuple;
  })();

  /**
 *  | Turn a function of two arguments into a function that expects a tuple.
 */  
  var uncurry = function (f) {
      return function (v) {
          return f(v.value0)(v.value1);
      };
  };

  /**
 *  | Exchange the first and second components of a tuple.
 */  
  var swap = function (v) {
      return new Tuple(v.value1, v.value0);
  };

  /**
 *  | Returns the second component of a tuple.
 */  
  var snd = function (v) {
      return v.value1;
  };

  /**
 *  | Allows `Tuple`s to be rendered as a string with `show` whenever there are
 *  | `Show` instances for both component types.
 */  
  var showTuple = function (dictShow) {
      return function (dictShow1) {
          return new Data_Show.Show(function (v) {
              return "(Tuple " + (Data_Show.show(dictShow)(v.value0) + (" " + (Data_Show.show(dictShow1)(v.value1) + ")")));
          });
      };
  };
  var semiringTuple = function (dictSemiring) {
      return function (dictSemiring1) {
          return new Data_Semiring.Semiring(function (v) {
              return function (v1) {
                  return new Tuple(Data_Semiring.add(dictSemiring)(v.value0)(v1.value0), Data_Semiring.add(dictSemiring1)(v.value1)(v1.value1));
              };
          }, function (v) {
              return function (v1) {
                  return new Tuple(Data_Semiring.mul(dictSemiring)(v.value0)(v1.value0), Data_Semiring.mul(dictSemiring1)(v.value1)(v1.value1));
              };
          }, new Tuple(Data_Semiring.one(dictSemiring), Data_Semiring.one(dictSemiring1)), new Tuple(Data_Semiring.zero(dictSemiring), Data_Semiring.zero(dictSemiring1)));
      };
  };
  var semigroupoidTuple = new Control_Semigroupoid.Semigroupoid(function (v) {
      return function (v1) {
          return new Tuple(v1.value0, v.value1);
      };
  });

  /**
 *  | The `Semigroup` instance enables use of the associative operator `<>` on
 *  | `Tuple`s whenever there are `Semigroup` instances for the component
 *  | types. The `<>` operator is applied pairwise, so:
 *  | ```purescript
 *  | (Tuple a1 b1) <> (Tuple a2 b2) = Tuple (a1 <> a2) (b1 <> b2)
 *  | ```
 */  
  var semigroupTuple = function (dictSemigroup) {
      return function (dictSemigroup1) {
          return new Data_Semigroup.Semigroup(function (v) {
              return function (v1) {
                  return new Tuple(Data_Semigroup.append(dictSemigroup)(v.value0)(v1.value0), Data_Semigroup.append(dictSemigroup1)(v.value1)(v1.value1));
              };
          });
      };
  };
  var ringTuple = function (dictRing) {
      return function (dictRing1) {
          return new Data_Ring.Ring(function () {
              return semiringTuple(dictRing["__superclass_Data.Semiring.Semiring_0"]())(dictRing1["__superclass_Data.Semiring.Semiring_0"]());
          }, function (v) {
              return function (v1) {
                  return new Tuple(Data_Ring.sub(dictRing)(v.value0)(v1.value0), Data_Ring.sub(dictRing1)(v.value1)(v1.value1));
              };
          });
      };
  };
  var monoidTuple = function (dictMonoid) {
      return function (dictMonoid1) {
          return new Data_Monoid.Monoid(function () {
              return semigroupTuple(dictMonoid["__superclass_Data.Semigroup.Semigroup_0"]())(dictMonoid1["__superclass_Data.Semigroup.Semigroup_0"]());
          }, new Tuple(Data_Monoid.mempty(dictMonoid), Data_Monoid.mempty(dictMonoid1)));
      };
  };

  /**
 *  | Lookup a value in a data structure of `Tuple`s, generalizing association lists.
 */  
  var lookup = function (dictFoldable) {
      return function (dictEq) {
          return function (a) {
              return function ($255) {
                  return Data_Newtype.unwrap(Data_Maybe_First.newtypeFirst)(Data_Foldable.foldMap(dictFoldable)(Data_Maybe_First.monoidFirst)(function (v) {
                      var $135 = Data_Eq.eq(dictEq)(a)(v.value0);
                      if ($135) {
                          return new Data_Maybe.Just(v.value1);
                      };
                      if (!$135) {
                          return Data_Maybe.Nothing.value;
                      };
                      throw new Error("Failed pattern match at Data.Tuple line 170, column 55 - line 170, column 90: " + [ $135.constructor.name ]);
                  })($255));
              };
          };
      };
  };
  var heytingAlgebraTuple = function (dictHeytingAlgebra) {
      return function (dictHeytingAlgebra1) {
          return new Data_HeytingAlgebra.HeytingAlgebra(function (v) {
              return function (v1) {
                  return new Tuple(Data_HeytingAlgebra.conj(dictHeytingAlgebra)(v.value0)(v1.value0), Data_HeytingAlgebra.conj(dictHeytingAlgebra1)(v.value1)(v1.value1));
              };
          }, function (v) {
              return function (v1) {
                  return new Tuple(Data_HeytingAlgebra.disj(dictHeytingAlgebra)(v.value0)(v1.value0), Data_HeytingAlgebra.disj(dictHeytingAlgebra1)(v.value1)(v1.value1));
              };
          }, new Tuple(Data_HeytingAlgebra.ff(dictHeytingAlgebra), Data_HeytingAlgebra.ff(dictHeytingAlgebra1)), function (v) {
              return function (v1) {
                  return new Tuple(Data_HeytingAlgebra.implies(dictHeytingAlgebra)(v.value0)(v1.value0), Data_HeytingAlgebra.implies(dictHeytingAlgebra1)(v.value1)(v1.value1));
              };
          }, function (v) {
              return new Tuple(Data_HeytingAlgebra.not(dictHeytingAlgebra)(v.value0), Data_HeytingAlgebra.not(dictHeytingAlgebra1)(v.value1));
          }, new Tuple(Data_HeytingAlgebra.tt(dictHeytingAlgebra), Data_HeytingAlgebra.tt(dictHeytingAlgebra1)));
      };
  };

  /**
 *  | The `Functor` instance allows functions to transform the contents of a
 *  | `Tuple` with the `<$>` operator, applying the function to the second
 *  | component, so:
 *  | ```purescript
 *  | f <$> (Tuple x y) = Tuple x (f y)
 *  | ````
 */  
  var functorTuple = new Data_Functor.Functor(function (f) {
      return function (v) {
          return new Tuple(v.value0, f(v.value1));
      };
  });
  var invariantTuple = new Data_Functor_Invariant.Invariant(Data_Functor_Invariant.imapF(functorTuple));

  /**
 *  | Returns the first component of a tuple.
 */  
  var fst = function (v) {
      return v.value0;
  };
  var lazyTuple = function (dictLazy) {
      return function (dictLazy1) {
          return new Control_Lazy.Lazy(function (f) {
              return new Tuple(Control_Lazy.defer(dictLazy)(function (v) {
                  return fst(f(Data_Unit.unit));
              }), Control_Lazy.defer(dictLazy1)(function (v) {
                  return snd(f(Data_Unit.unit));
              }));
          });
      };
  };
  var foldableTuple = new Data_Foldable.Foldable(function (dictMonoid) {
      return function (f) {
          return function (v) {
              return f(v.value1);
          };
      };
  }, function (f) {
      return function (z) {
          return function (v) {
              return f(z)(v.value1);
          };
      };
  }, function (f) {
      return function (z) {
          return function (v) {
              return f(v.value1)(z);
          };
      };
  });
  var traversableTuple = new Data_Traversable.Traversable(function () {
      return foldableTuple;
  }, function () {
      return functorTuple;
  }, function (dictApplicative) {
      return function (v) {
          return Data_Functor.map((dictApplicative["__superclass_Control.Apply.Apply_0"]())["__superclass_Data.Functor.Functor_0"]())(Tuple.create(v.value0))(v.value1);
      };
  }, function (dictApplicative) {
      return function (f) {
          return function (v) {
              return Data_Functor.map((dictApplicative["__superclass_Control.Apply.Apply_0"]())["__superclass_Data.Functor.Functor_0"]())(Tuple.create(v.value0))(f(v.value1));
          };
      };
  });
  var extendTuple = new Control_Extend.Extend(function () {
      return functorTuple;
  }, function (f) {
      return function (v) {
          return new Tuple(v.value0, f(v));
      };
  });

  /**
 *  | Allows `Tuple`s to be checked for equality with `==` and `/=` whenever
 *  | there are `Eq` instances for both component types.
 */  
  var eqTuple = function (dictEq) {
      return function (dictEq1) {
          return new Data_Eq.Eq(function (x) {
              return function (y) {
                  return Data_Eq.eq(dictEq)(x.value0)(y.value0) && Data_Eq.eq(dictEq1)(x.value1)(y.value1);
              };
          });
      };
  };

  /**
 *  | Allows `Tuple`s to be compared with `compare`, `>`, `>=`, `<` and `<=`
 *  | whenever there are `Ord` instances for both component types. To obtain
 *  | the result, the `fst`s are `compare`d, and if they are `EQ`ual, the
 *  | `snd`s are `compare`d.
 */  
  var ordTuple = function (dictOrd) {
      return function (dictOrd1) {
          return new Data_Ord.Ord(function () {
              return eqTuple(dictOrd["__superclass_Data.Eq.Eq_0"]())(dictOrd1["__superclass_Data.Eq.Eq_0"]());
          }, function (x) {
              return function (y) {
                  var $201 = Data_Ord.compare(dictOrd)(x.value0)(y.value0);
                  if ($201 instanceof Data_Ordering.LT) {
                      return Data_Ordering.LT.value;
                  };
                  if ($201 instanceof Data_Ordering.GT) {
                      return Data_Ordering.GT.value;
                  };
                  return Data_Ord.compare(dictOrd1)(x.value1)(y.value1);
              };
          });
      };
  };

  /**
 *  | Turn a function that expects a tuple into a function of two arguments.
 */  
  var curry = function (f) {
      return function (a) {
          return function (b) {
              return f(new Tuple(a, b));
          };
      };
  };
  var comonadTuple = new Control_Comonad.Comonad(function () {
      return extendTuple;
  }, snd);
  var commutativeRingTuple = function (dictCommutativeRing) {
      return function (dictCommutativeRing1) {
          return new Data_CommutativeRing.CommutativeRing(function () {
              return ringTuple(dictCommutativeRing["__superclass_Data.Ring.Ring_0"]())(dictCommutativeRing1["__superclass_Data.Ring.Ring_0"]());
          });
      };
  };
  var boundedTuple = function (dictBounded) {
      return function (dictBounded1) {
          return new Data_Bounded.Bounded(function () {
              return ordTuple(dictBounded["__superclass_Data.Ord.Ord_0"]())(dictBounded1["__superclass_Data.Ord.Ord_0"]());
          }, new Tuple(Data_Bounded.bottom(dictBounded), Data_Bounded.bottom(dictBounded1)), new Tuple(Data_Bounded.top(dictBounded), Data_Bounded.top(dictBounded1)));
      };
  };
  var booleanAlgebraTuple = function (dictBooleanAlgebra) {
      return function (dictBooleanAlgebra1) {
          return new Data_BooleanAlgebra.BooleanAlgebra(function () {
              return heytingAlgebraTuple(dictBooleanAlgebra["__superclass_Data.HeytingAlgebra.HeytingAlgebra_0"]())(dictBooleanAlgebra1["__superclass_Data.HeytingAlgebra.HeytingAlgebra_0"]());
          });
      };
  };
  var bifunctorTuple = new Data_Bifunctor.Bifunctor(function (f) {
      return function (g) {
          return function (v) {
              return new Tuple(f(v.value0), g(v.value1));
          };
      };
  });
  var bifoldableTuple = new Data_Bifoldable.Bifoldable(function (dictMonoid) {
      return function (f) {
          return function (g) {
              return function (v) {
                  return Data_Semigroup.append(dictMonoid["__superclass_Data.Semigroup.Semigroup_0"]())(f(v.value0))(g(v.value1));
              };
          };
      };
  }, function (f) {
      return function (g) {
          return function (z) {
              return function (v) {
                  return g(f(z)(v.value0))(v.value1);
              };
          };
      };
  }, function (f) {
      return function (g) {
          return function (z) {
              return function (v) {
                  return f(v.value0)(g(v.value1)(z));
              };
          };
      };
  });
  var bitraversableTuple = new Data_Bitraversable.Bitraversable(function () {
      return bifoldableTuple;
  }, function () {
      return bifunctorTuple;
  }, function (dictApplicative) {
      return function (v) {
          return Control_Apply.apply(dictApplicative["__superclass_Control.Apply.Apply_0"]())(Data_Functor.map((dictApplicative["__superclass_Control.Apply.Apply_0"]())["__superclass_Data.Functor.Functor_0"]())(Tuple.create)(v.value0))(v.value1);
      };
  }, function (dictApplicative) {
      return function (f) {
          return function (g) {
              return function (v) {
                  return Control_Apply.apply(dictApplicative["__superclass_Control.Apply.Apply_0"]())(Data_Functor.map((dictApplicative["__superclass_Control.Apply.Apply_0"]())["__superclass_Data.Functor.Functor_0"]())(Tuple.create)(f(v.value0)))(g(v.value1));
              };
          };
      };
  });
  var biapplyTuple = new Control_Biapply.Biapply(function () {
      return bifunctorTuple;
  }, function (v) {
      return function (v1) {
          return new Tuple(v.value0(v1.value0), v.value1(v1.value1));
      };
  });
  var biapplicativeTuple = new Control_Biapplicative.Biapplicative(function () {
      return biapplyTuple;
  }, Tuple.create);

  /**
 *  | The `Functor` instance allows functions to transform the contents of a
 *  | `Tuple` with the `<*>` operator whenever there is a `Semigroup` instance
 *  | for the `fst` component, so:
 *  | ```purescript
 *  | (Tuple a1 f) <*> (Tuple a2 x) == Tuple (a1 <> a2) (f x)
 *  | ```
 */  
  var applyTuple = function (dictSemigroup) {
      return new Control_Apply.Apply(function () {
          return functorTuple;
      }, function (v) {
          return function (v1) {
              return new Tuple(Data_Semigroup.append(dictSemigroup)(v.value0)(v1.value0), v.value1(v1.value1));
          };
      });
  };
  var bindTuple = function (dictSemigroup) {
      return new Control_Bind.Bind(function () {
          return applyTuple(dictSemigroup);
      }, function (v) {
          return function (f) {
              var $250 = f(v.value1);
              return new Tuple(Data_Semigroup.append(dictSemigroup)(v.value0)($250.value0), $250.value1);
          };
      });
  };
  var applicativeTuple = function (dictMonoid) {
      return new Control_Applicative.Applicative(function () {
          return applyTuple(dictMonoid["__superclass_Data.Semigroup.Semigroup_0"]());
      }, Tuple.create(Data_Monoid.mempty(dictMonoid)));
  };
  var monadTuple = function (dictMonoid) {
      return new Control_Monad.Monad(function () {
          return applicativeTuple(dictMonoid);
      }, function () {
          return bindTuple(dictMonoid["__superclass_Data.Semigroup.Semigroup_0"]());
      });
  };
  exports["Tuple"] = Tuple;
  exports["curry"] = curry;
  exports["fst"] = fst;
  exports["lookup"] = lookup;
  exports["snd"] = snd;
  exports["swap"] = swap;
  exports["uncurry"] = uncurry;
  exports["showTuple"] = showTuple;
  exports["eqTuple"] = eqTuple;
  exports["ordTuple"] = ordTuple;
  exports["boundedTuple"] = boundedTuple;
  exports["semigroupoidTuple"] = semigroupoidTuple;
  exports["semigroupTuple"] = semigroupTuple;
  exports["monoidTuple"] = monoidTuple;
  exports["semiringTuple"] = semiringTuple;
  exports["ringTuple"] = ringTuple;
  exports["commutativeRingTuple"] = commutativeRingTuple;
  exports["heytingAlgebraTuple"] = heytingAlgebraTuple;
  exports["booleanAlgebraTuple"] = booleanAlgebraTuple;
  exports["functorTuple"] = functorTuple;
  exports["invariantTuple"] = invariantTuple;
  exports["bifunctorTuple"] = bifunctorTuple;
  exports["applyTuple"] = applyTuple;
  exports["biapplyTuple"] = biapplyTuple;
  exports["applicativeTuple"] = applicativeTuple;
  exports["biapplicativeTuple"] = biapplicativeTuple;
  exports["bindTuple"] = bindTuple;
  exports["monadTuple"] = monadTuple;
  exports["extendTuple"] = extendTuple;
  exports["comonadTuple"] = comonadTuple;
  exports["lazyTuple"] = lazyTuple;
  exports["foldableTuple"] = foldableTuple;
  exports["bifoldableTuple"] = bifoldableTuple;
  exports["traversableTuple"] = traversableTuple;
  exports["bitraversableTuple"] = bitraversableTuple;
})(PS["Data.Tuple"] = PS["Data.Tuple"] || {});
(function(exports) {
  
  /**
 *  | This module defines the environment comonad transformer, `EnvT`.
 */  
  "use strict";
  var Prelude = PS["Prelude"];
  var Control_Comonad = PS["Control.Comonad"];
  var Control_Comonad_Trans_Class = PS["Control.Comonad.Trans.Class"];
  var Control_Extend = PS["Control.Extend"];
  var Data_Tuple = PS["Data.Tuple"];
  var Data_Newtype = PS["Data.Newtype"];
  var Data_Functor = PS["Data.Functor"];
  var Data_Function = PS["Data.Function"];
  var Control_Semigroupoid = PS["Control.Semigroupoid"];        

  /**
 *  | The environment comonad transformer.
 *  |
 *  | This comonad transformer extends the context of a value in the base comonad with a _global environment_ of
 *  | type `e`.
 *  |
 *  | The `ComonadEnv` type class describes the operations supported by this comonad.
 */  
  var EnvT = function (x) {
      return x;
  };

  /**
 *  | Change the environment type in an `EnvT` context.
 */  
  var withEnvT = function (f) {
      return function (v) {
          return EnvT(new Data_Tuple.Tuple(f(v.value0), v.value1));
      };
  };

  /**
 *  | Unwrap a value in the `EnvT` comonad.
 */  
  var runEnvT = function (v) {
      return v;
  };
  var newtypeEnvT = new Data_Newtype.Newtype(function (n) {
      return n;
  }, EnvT);

  /**
 *  | Change the underlying comonad and data type in an `EnvT` context.
 */  
  var mapEnvT = function (f) {
      return function (v) {
          return EnvT(new Data_Tuple.Tuple(v.value0, f(v.value1)));
      };
  };
  var functorEnvT = function (dictFunctor) {
      return new Data_Functor.Functor(function (f) {
          return function (v) {
              return EnvT(new Data_Tuple.Tuple(v.value0, Data_Functor.map(dictFunctor)(f)(v.value1)));
          };
      });
  };
  var extendEnvT = function (dictExtend) {
      return new Control_Extend.Extend(function () {
          return functorEnvT(dictExtend["__superclass_Data.Functor.Functor_0"]());
      }, function (f) {
          return function (v) {
              return EnvT(new Data_Tuple.Tuple(v.value0, Data_Functor.map(dictExtend["__superclass_Data.Functor.Functor_0"]())(f)(Control_Extend.extend(dictExtend)(function ($37) {
                  return EnvT(Data_Tuple.Tuple.create(v.value0)($37));
              })(v.value1))));
          };
      });
  };
  var comonadTransEnvT = new Control_Comonad_Trans_Class.ComonadTrans(function (dictComonad) {
      return function (v) {
          return v.value1;
      };
  });
  var comonadEnvT = function (dictComonad) {
      return new Control_Comonad.Comonad(function () {
          return extendEnvT(dictComonad["__superclass_Control.Extend.Extend_0"]());
      }, function (v) {
          return Control_Comonad.extract(dictComonad)(v.value1);
      });
  };
  exports["EnvT"] = EnvT;
  exports["mapEnvT"] = mapEnvT;
  exports["runEnvT"] = runEnvT;
  exports["withEnvT"] = withEnvT;
  exports["newtypeEnvT"] = newtypeEnvT;
  exports["functorEnvT"] = functorEnvT;
  exports["extendEnvT"] = extendEnvT;
  exports["comonadEnvT"] = comonadEnvT;
  exports["comonadTransEnvT"] = comonadTransEnvT;
})(PS["Control.Comonad.Env.Trans"] = PS["Control.Comonad.Env.Trans"] || {});
(function(exports) {
  
  /**
 *  | This module defines the `ComonadEnv` type class and its instances.
 */  
  "use strict";
  var Control_Comonad = PS["Control.Comonad"];
  var Control_Comonad_Env_Trans = PS["Control.Comonad.Env.Trans"];
  var Data_Tuple = PS["Data.Tuple"];        

  /**
 *  | The `ComonadEnv` type class represents those comonads which support a
 *  | global environment that can be provided via the `ask` function.
 *  |
 *  | An implementation is provided for `EnvT`.
 */  
  var ComonadAsk = function (__superclass_Control$dotComonad$dotComonad_0, ask) {
      this["__superclass_Control.Comonad.Comonad_0"] = __superclass_Control$dotComonad$dotComonad_0;
      this.ask = ask;
  };

  /**
 *  | The `ComonadEnv` type class extends `ComonadAsk` with a function
 *  | `local f x` that allows the value of the local context to be modified for
 *  | the duration of the execution of action `x`.
 *  |
 *  | An implementation is provided for `EnvT`.
 *  |
 *  | Laws:
 *  |
 *  | - `ask (local f x) = f (ask x)`
 *  | - `extract (local _ x) = extract a`
 *  | - `extend g (local f x) = extend (g <<< local f) x`
 */  
  var ComonadEnv = function (__superclass_Control$dotComonad$dotEnv$dotClass$dotComonadAsk_0, local) {
      this["__superclass_Control.Comonad.Env.Class.ComonadAsk_0"] = __superclass_Control$dotComonad$dotEnv$dotClass$dotComonadAsk_0;
      this.local = local;
  };

  /**
 *  | The `ComonadEnv` type class extends `ComonadAsk` with a function
 *  | `local f x` that allows the value of the local context to be modified for
 *  | the duration of the execution of action `x`.
 *  |
 *  | An implementation is provided for `EnvT`.
 *  |
 *  | Laws:
 *  |
 *  | - `ask (local f x) = f (ask x)`
 *  | - `extract (local _ x) = extract a`
 *  | - `extend g (local f x) = extend (g <<< local f) x`
 */  
  var local = function (dict) {
      return dict.local;
  };
  var comonadAskTuple = new ComonadAsk(function () {
      return Data_Tuple.comonadTuple;
  }, Data_Tuple.fst);
  var comonadEnvTuple = new ComonadEnv(function () {
      return comonadAskTuple;
  }, function (f) {
      return function (v) {
          return new Data_Tuple.Tuple(f(v.value0), v.value1);
      };
  });
  var comonadAskEnvT = function (dictComonad) {
      return new ComonadAsk(function () {
          return Control_Comonad_Env_Trans.comonadEnvT(dictComonad);
      }, function (v) {
          return Data_Tuple.fst(v);
      });
  };
  var comonadEnvEnvT = function (dictComonad) {
      return new ComonadEnv(function () {
          return comonadAskEnvT(dictComonad);
      }, function (f) {
          return function (v) {
              return new Data_Tuple.Tuple(f(v.value0), v.value1);
          };
      });
  };

  /**
 *  | The `ComonadEnv` type class represents those comonads which support a
 *  | global environment that can be provided via the `ask` function.
 *  |
 *  | An implementation is provided for `EnvT`.
 */  
  var ask = function (dict) {
      return dict.ask;
  };

  /**
 *  | Get a value which depends on the environment.
 */  
  var asks = function (dictComonadEnv) {
      return function (f) {
          return function (x) {
              return f(ask(dictComonadEnv["__superclass_Control.Comonad.Env.Class.ComonadAsk_0"]())(x));
          };
      };
  };
  exports["ComonadAsk"] = ComonadAsk;
  exports["ComonadEnv"] = ComonadEnv;
  exports["ask"] = ask;
  exports["asks"] = asks;
  exports["local"] = local;
  exports["comonadAskTuple"] = comonadAskTuple;
  exports["comonadEnvTuple"] = comonadEnvTuple;
  exports["comonadAskEnvT"] = comonadAskEnvT;
  exports["comonadEnvEnvT"] = comonadEnvEnvT;
})(PS["Control.Comonad.Env.Class"] = PS["Control.Comonad.Env.Class"] || {});
(function(exports) {
    "use strict";
  var Prelude = PS["Prelude"];
  var Control_Alt = PS["Control.Alt"];
  var Control_Comonad = PS["Control.Comonad"];
  var Control_Extend = PS["Control.Extend"];
  var Data_Foldable = PS["Data.Foldable"];
  var Data_Functor_Invariant = PS["Data.Functor.Invariant"];
  var Data_Monoid = PS["Data.Monoid"];
  var Data_Newtype = PS["Data.Newtype"];
  var Data_Traversable = PS["Data.Traversable"];
  var Data_Eq = PS["Data.Eq"];
  var Data_Ord = PS["Data.Ord"];
  var Data_Bounded = PS["Data.Bounded"];
  var Data_HeytingAlgebra = PS["Data.HeytingAlgebra"];
  var Data_BooleanAlgebra = PS["Data.BooleanAlgebra"];
  var Data_Semigroup = PS["Data.Semigroup"];
  var Data_Semiring = PS["Data.Semiring"];
  var Data_EuclideanRing = PS["Data.EuclideanRing"];
  var Data_Ring = PS["Data.Ring"];
  var Data_CommutativeRing = PS["Data.CommutativeRing"];
  var Data_Field = PS["Data.Field"];
  var Data_Show = PS["Data.Show"];
  var Data_Functor = PS["Data.Functor"];
  var Control_Apply = PS["Control.Apply"];
  var Control_Applicative = PS["Control.Applicative"];
  var Control_Bind = PS["Control.Bind"];
  var Control_Monad = PS["Control.Monad"];        
  var Identity = function (x) {
      return x;
  };
  var showIdentity = function (dictShow) {
      return new Data_Show.Show(function (v) {
          return "(Identity " + (Data_Show.show(dictShow)(v) + ")");
      });
  };
  var semiringIdentity = function (dictSemiring) {
      return dictSemiring;
  };
  var semigroupIdenity = function (dictSemigroup) {
      return dictSemigroup;
  };
  var ringIdentity = function (dictRing) {
      return dictRing;
  };
  var ordIdentity = function (dictOrd) {
      return dictOrd;
  };
  var newtypeIdentity = new Data_Newtype.Newtype(function (n) {
      return n;
  }, Identity);
  var monoidIdentity = function (dictMonoid) {
      return dictMonoid;
  };
  var heytingAlgebraIdentity = function (dictHeytingAlgebra) {
      return dictHeytingAlgebra;
  };
  var functorIdentity = new Data_Functor.Functor(function (f) {
      return function (v) {
          return f(v);
      };
  });
  var invariantIdentity = new Data_Functor_Invariant.Invariant(Data_Functor_Invariant.imapF(functorIdentity));
  var foldableIdentity = new Data_Foldable.Foldable(function (dictMonoid) {
      return function (f) {
          return function (v) {
              return f(v);
          };
      };
  }, function (f) {
      return function (z) {
          return function (v) {
              return f(z)(v);
          };
      };
  }, function (f) {
      return function (z) {
          return function (v) {
              return f(v)(z);
          };
      };
  });
  var traversableIdentity = new Data_Traversable.Traversable(function () {
      return foldableIdentity;
  }, function () {
      return functorIdentity;
  }, function (dictApplicative) {
      return function (v) {
          return Data_Functor.map((dictApplicative["__superclass_Control.Apply.Apply_0"]())["__superclass_Data.Functor.Functor_0"]())(Identity)(v);
      };
  }, function (dictApplicative) {
      return function (f) {
          return function (v) {
              return Data_Functor.map((dictApplicative["__superclass_Control.Apply.Apply_0"]())["__superclass_Data.Functor.Functor_0"]())(Identity)(f(v));
          };
      };
  });
  var fieldIdentity = function (dictField) {
      return dictField;
  };
  var extendIdentity = new Control_Extend.Extend(function () {
      return functorIdentity;
  }, function (f) {
      return function (m) {
          return f(m);
      };
  });
  var euclideanRingIdentity = function (dictEuclideanRing) {
      return dictEuclideanRing;
  };
  var eqIdentity = function (dictEq) {
      return dictEq;
  };
  var comonadIdentity = new Control_Comonad.Comonad(function () {
      return extendIdentity;
  }, function (v) {
      return v;
  });
  var commutativeRingIdentity = function (dictCommutativeRing) {
      return dictCommutativeRing;
  };
  var boundedIdentity = function (dictBounded) {
      return dictBounded;
  };
  var booleanAlgebraIdentity = function (dictBooleanAlgebra) {
      return dictBooleanAlgebra;
  };
  var applyIdentity = new Control_Apply.Apply(function () {
      return functorIdentity;
  }, function (v) {
      return function (v1) {
          return v(v1);
      };
  });
  var bindIdentity = new Control_Bind.Bind(function () {
      return applyIdentity;
  }, function (v) {
      return function (f) {
          return f(v);
      };
  });
  var applicativeIdentity = new Control_Applicative.Applicative(function () {
      return applyIdentity;
  }, Identity);
  var monadIdentity = new Control_Monad.Monad(function () {
      return applicativeIdentity;
  }, function () {
      return bindIdentity;
  });
  var altIdentity = new Control_Alt.Alt(function () {
      return functorIdentity;
  }, function (x) {
      return function (v) {
          return x;
      };
  });
  exports["Identity"] = Identity;
  exports["newtypeIdentity"] = newtypeIdentity;
  exports["eqIdentity"] = eqIdentity;
  exports["ordIdentity"] = ordIdentity;
  exports["boundedIdentity"] = boundedIdentity;
  exports["heytingAlgebraIdentity"] = heytingAlgebraIdentity;
  exports["booleanAlgebraIdentity"] = booleanAlgebraIdentity;
  exports["semigroupIdenity"] = semigroupIdenity;
  exports["monoidIdentity"] = monoidIdentity;
  exports["semiringIdentity"] = semiringIdentity;
  exports["euclideanRingIdentity"] = euclideanRingIdentity;
  exports["ringIdentity"] = ringIdentity;
  exports["commutativeRingIdentity"] = commutativeRingIdentity;
  exports["fieldIdentity"] = fieldIdentity;
  exports["showIdentity"] = showIdentity;
  exports["functorIdentity"] = functorIdentity;
  exports["invariantIdentity"] = invariantIdentity;
  exports["altIdentity"] = altIdentity;
  exports["applyIdentity"] = applyIdentity;
  exports["applicativeIdentity"] = applicativeIdentity;
  exports["bindIdentity"] = bindIdentity;
  exports["monadIdentity"] = monadIdentity;
  exports["extendIdentity"] = extendIdentity;
  exports["comonadIdentity"] = comonadIdentity;
  exports["foldableIdentity"] = foldableIdentity;
  exports["traversableIdentity"] = traversableIdentity;
})(PS["Data.Identity"] = PS["Data.Identity"] || {});
(function(exports) {
  
  /**
 *  | This module defines the `Env` comonad.
 */  
  "use strict";
  var Prelude = PS["Prelude"];
  var Control_Comonad_Env_Class = PS["Control.Comonad.Env.Class"];
  var Control_Comonad_Env_Trans = PS["Control.Comonad.Env.Trans"];
  var Data_Identity = PS["Data.Identity"];
  var Data_Newtype = PS["Data.Newtype"];
  var Data_Tuple = PS["Data.Tuple"];
  var Data_Functor = PS["Data.Functor"];
  var Data_Function = PS["Data.Function"];        

  /**
 *  | Change the environment type in an `Env` computation.
 */  
  var withEnv = Control_Comonad_Env_Trans.withEnvT;

  /**
 *  | Unwrap a value in the `Env` comonad.
 */  
  var runEnv = function (v) {
      return Data_Functor.map(Data_Tuple.functorTuple)(Data_Newtype.unwrap(Data_Identity.newtypeIdentity))(v);
  };

  /**
 *  | Change the data type in an `Env` computation.
 */  
  var mapEnv = Data_Functor.map(Control_Comonad_Env_Trans.functorEnvT(Data_Identity.functorIdentity));

  /**
 *  | Create a value in context in the `Env` comonad.
 */  
  var env = function (e) {
      return function (a) {
          return Control_Comonad_Env_Trans.EnvT(Data_Tuple.Tuple.create(e)(a));
      };
  };
  exports["env"] = env;
  exports["mapEnv"] = mapEnv;
  exports["runEnv"] = runEnv;
  exports["withEnv"] = withEnv;
})(PS["Control.Comonad.Env"] = PS["Control.Comonad.Env"] || {});
(function(exports) {
  
  /**
 *  | This module defines the store comonad transformer, `StoreT`.
 */  
  "use strict";
  var Prelude = PS["Prelude"];
  var Control_Comonad = PS["Control.Comonad"];
  var Control_Comonad_Trans_Class = PS["Control.Comonad.Trans.Class"];
  var Control_Extend = PS["Control.Extend"];
  var Data_Tuple = PS["Data.Tuple"];
  var Data_Newtype = PS["Data.Newtype"];
  var Data_Functor = PS["Data.Functor"];
  var Data_Function = PS["Data.Function"];
  var Control_Semigroupoid = PS["Control.Semigroupoid"];        

  /**
 *  | The store comonad transformer.
 *  |
 *  | This comonad transformer extends the context of a value in the base comonad so that the value
 *  | depends on a position of type `s`.
 *  |
 *  | The `ComonadStore` type class describes the operations supported by this comonad.
 */  
  var StoreT = function (x) {
      return x;
  };

  /**
 *  | Unwrap a value in the `StoreT` comonad.
 */  
  var runStoreT = function (v) {
      return v;
  };
  var newtypeStoreT = new Data_Newtype.Newtype(function (n) {
      return n;
  }, StoreT);
  var functorStoreT = function (dictFunctor) {
      return new Data_Functor.Functor(function (f) {
          return function (v) {
              return StoreT(new Data_Tuple.Tuple(Data_Functor.map(dictFunctor)(function (h) {
                  return function ($28) {
                      return f(h($28));
                  };
              })(v.value0), v.value1));
          };
      });
  };
  var extendStoreT = function (dictExtend) {
      return new Control_Extend.Extend(function () {
          return functorStoreT(dictExtend["__superclass_Data.Functor.Functor_0"]());
      }, function (f) {
          return function (v) {
              return StoreT(new Data_Tuple.Tuple(Control_Extend.extend(dictExtend)(function (w$prime) {
                  return function (s$prime) {
                      return f(StoreT(new Data_Tuple.Tuple(w$prime, s$prime)));
                  };
              })(v.value0), v.value1));
          };
      });
  };
  var comonadTransStoreT = new Control_Comonad_Trans_Class.ComonadTrans(function (dictComonad) {
      return function (v) {
          return Data_Functor.map((dictComonad["__superclass_Control.Extend.Extend_0"]())["__superclass_Data.Functor.Functor_0"]())(function (v1) {
              return v1(v.value1);
          })(v.value0);
      };
  });
  var comonadStoreT = function (dictComonad) {
      return new Control_Comonad.Comonad(function () {
          return extendStoreT(dictComonad["__superclass_Control.Extend.Extend_0"]());
      }, function (v) {
          return Control_Comonad.extract(dictComonad)(v.value0)(v.value1);
      });
  };
  exports["StoreT"] = StoreT;
  exports["runStoreT"] = runStoreT;
  exports["newtypeStoreT"] = newtypeStoreT;
  exports["functorStoreT"] = functorStoreT;
  exports["extendStoreT"] = extendStoreT;
  exports["comonadStoreT"] = comonadStoreT;
  exports["comonadTransStoreT"] = comonadTransStoreT;
})(PS["Control.Comonad.Store.Trans"] = PS["Control.Comonad.Store.Trans"] || {});
(function(exports) {
  
  /**
 *  | This module defines the `ComonadStore` type class and its instances.
 */  
  "use strict";
  var Prelude = PS["Prelude"];
  var Control_Comonad = PS["Control.Comonad"];
  var Control_Comonad_Store_Trans = PS["Control.Comonad.Store.Trans"];
  var Control_Extend = PS["Control.Extend"];
  var Data_Tuple = PS["Data.Tuple"];
  var Data_Function = PS["Data.Function"];
  var Control_Semigroupoid = PS["Control.Semigroupoid"];
  var Data_Functor = PS["Data.Functor"];        

  /**
 *  | The `ComonadStore` type class represents those monads which support local position information via
 *  | `pos` and `peek`.
 *  |
 *  | - `pos` reads the current position.
 *  | - `peek` reads the value at the specified position in the specified context.
 *  |
 *  | An implementation is provided for `StoreT`.
 *  |
 *  | Laws:
 *  |
 *  | - `pos (extend _ x) = pos x`
 *  | - `peek (pos x) x = extract x`
 *  |
 *  | For example:
 *  |
 *  | ```purescript
 *  | blur :: forall w. (ComonadStore Number w) -> w Number -> w Number
 *  | blur = extend \r -> (peeks (\n -> n - 1) r + peeks (\n -> n + 1) r) / 2)
 *  | ```
 */  
  var ComonadStore = function (__superclass_Control$dotComonad$dotComonad_0, peek, pos) {
      this["__superclass_Control.Comonad.Comonad_0"] = __superclass_Control$dotComonad$dotComonad_0;
      this.peek = peek;
      this.pos = pos;
  };

  /**
 *  | The `ComonadStore` type class represents those monads which support local position information via
 *  | `pos` and `peek`.
 *  |
 *  | - `pos` reads the current position.
 *  | - `peek` reads the value at the specified position in the specified context.
 *  |
 *  | An implementation is provided for `StoreT`.
 *  |
 *  | Laws:
 *  |
 *  | - `pos (extend _ x) = pos x`
 *  | - `peek (pos x) x = extract x`
 *  |
 *  | For example:
 *  |
 *  | ```purescript
 *  | blur :: forall w. (ComonadStore Number w) -> w Number -> w Number
 *  | blur = extend \r -> (peeks (\n -> n - 1) r + peeks (\n -> n + 1) r) / 2)
 *  | ```
 */  
  var pos = function (dict) {
      return dict.pos;
  };

  /**
 *  | The `ComonadStore` type class represents those monads which support local position information via
 *  | `pos` and `peek`.
 *  |
 *  | - `pos` reads the current position.
 *  | - `peek` reads the value at the specified position in the specified context.
 *  |
 *  | An implementation is provided for `StoreT`.
 *  |
 *  | Laws:
 *  |
 *  | - `pos (extend _ x) = pos x`
 *  | - `peek (pos x) x = extract x`
 *  |
 *  | For example:
 *  |
 *  | ```purescript
 *  | blur :: forall w. (ComonadStore Number w) -> w Number -> w Number
 *  | blur = extend \r -> (peeks (\n -> n - 1) r + peeks (\n -> n + 1) r) / 2)
 *  | ```
 */  
  var peek = function (dict) {
      return dict.peek;
  };

  /**
 *  | Extract a value from a position which depends on the current position.
 */  
  var peeks = function (dictComonadStore) {
      return function (f) {
          return function (x) {
              return peek(dictComonadStore)(f(pos(dictComonadStore)(x)))(x);
          };
      };
  };

  /**
 *  | Reposition the focus at the specified position, which depends on the current position.
 */  
  var seeks = function (dictComonadStore) {
      return function (f) {
          return function ($15) {
              return peeks(dictComonadStore)(f)(Control_Extend.duplicate((dictComonadStore["__superclass_Control.Comonad.Comonad_0"]())["__superclass_Control.Extend.Extend_0"]())($15));
          };
      };
  };

  /**
 *  | Reposition the focus at the specified position.
 */  
  var seek = function (dictComonadStore) {
      return function (s) {
          return function ($16) {
              return peek(dictComonadStore)(s)(Control_Extend.duplicate((dictComonadStore["__superclass_Control.Comonad.Comonad_0"]())["__superclass_Control.Extend.Extend_0"]())($16));
          };
      };
  };

  /**
 *  | Extract a collection of values from positions which depend on the current position.
 */  
  var experiment = function (dictComonadStore) {
      return function (dictFunctor) {
          return function (f) {
              return function (x) {
                  return Data_Functor.map(dictFunctor)(Data_Function.flip(peek(dictComonadStore))(x))(f(pos(dictComonadStore)(x)));
              };
          };
      };
  };
  var comonadStoreStoreT = function (dictComonad) {
      return new ComonadStore(function () {
          return Control_Comonad_Store_Trans.comonadStoreT(dictComonad);
      }, function (s) {
          return function (v) {
              return Control_Comonad.extract(dictComonad)(v.value0)(s);
          };
      }, function (v) {
          return v.value1;
      });
  };
  exports["ComonadStore"] = ComonadStore;
  exports["experiment"] = experiment;
  exports["peek"] = peek;
  exports["peeks"] = peeks;
  exports["pos"] = pos;
  exports["seek"] = seek;
  exports["seeks"] = seeks;
  exports["comonadStoreStoreT"] = comonadStoreStoreT;
})(PS["Control.Comonad.Store.Class"] = PS["Control.Comonad.Store.Class"] || {});
(function(exports) {
  
  /**
 *  | This module defines the `Store` comonad.
 */  
  "use strict";
  var Prelude = PS["Prelude"];
  var Control_Comonad_Store_Class = PS["Control.Comonad.Store.Class"];
  var Control_Comonad_Store_Trans = PS["Control.Comonad.Store.Trans"];
  var Data_Identity = PS["Data.Identity"];
  var Data_Newtype = PS["Data.Newtype"];
  var Data_Tuple = PS["Data.Tuple"];
  var Data_Function = PS["Data.Function"];
  var Data_Functor = PS["Data.Functor"];        

  /**
 *  | Create a value in context in the `Store` comonad.
 */  
  var store = function (f) {
      return function (x) {
          return Control_Comonad_Store_Trans.StoreT(new Data_Tuple.Tuple(f, x));
      };
  };

  /**
 *  | Unwrap a value in the `Store` comonad.
 */  
  var runStore = function (v) {
      return Data_Tuple.swap(Data_Functor.map(Data_Tuple.functorTuple)(Data_Newtype.unwrap(Data_Identity.newtypeIdentity))(Data_Tuple.swap(v)));
  };
  exports["runStore"] = runStore;
  exports["store"] = store;
})(PS["Control.Comonad.Store"] = PS["Control.Comonad.Store"] || {});
(function(exports) {
  
  /**
 *  | This module defines the cowriter comonad transformer, `TracedT`.
 */  
  "use strict";
  var Prelude = PS["Prelude"];
  var Control_Comonad = PS["Control.Comonad"];
  var Control_Comonad_Trans_Class = PS["Control.Comonad.Trans.Class"];
  var Control_Extend = PS["Control.Extend"];
  var Data_Monoid = PS["Data.Monoid"];
  var Data_Newtype = PS["Data.Newtype"];
  var Data_Functor = PS["Data.Functor"];
  var Data_Function = PS["Data.Function"];
  var Data_Semigroup = PS["Data.Semigroup"];        

  /**
 *  | The cowriter comonad transformer.
 *  |
 *  | This comonad transformer extends the context of a value in the base comonad so that the value
 *  | depends on a monoidal position of type `t`.
 *  |
 *  | The `ComonadTraced` type class describes the operations supported by this comonad.
 */  
  var TracedT = function (x) {
      return x;
  };

  /**
 *  | Unwrap a value in the `TracedT` comonad.
 */  
  var runTracedT = function (v) {
      return v;
  };
  var newtypeTracedT = new Data_Newtype.Newtype(function (n) {
      return n;
  }, TracedT);
  var functorTracedT = function (dictFunctor) {
      return new Data_Functor.Functor(function (f) {
          return function (v) {
              return Data_Functor.map(dictFunctor)(function (g) {
                  return function (t) {
                      return f(g(t));
                  };
              })(v);
          };
      });
  };
  var extendTracedT = function (dictExtend) {
      return function (dictSemigroup) {
          return new Control_Extend.Extend(function () {
              return functorTracedT(dictExtend["__superclass_Data.Functor.Functor_0"]());
          }, function (f) {
              return function (v) {
                  return Control_Extend.extend(dictExtend)(function (w1) {
                      return function (t) {
                          return f(Data_Functor.map(dictExtend["__superclass_Data.Functor.Functor_0"]())(function (h) {
                              return function (t$prime) {
                                  return h(Data_Semigroup.append(dictSemigroup)(t)(t$prime));
                              };
                          })(w1));
                      };
                  })(v);
              };
          });
      };
  };
  var comonadTransTracedT = function (dictMonoid) {
      return new Control_Comonad_Trans_Class.ComonadTrans(function (dictComonad) {
          return function (v) {
              return Data_Functor.map((dictComonad["__superclass_Control.Extend.Extend_0"]())["__superclass_Data.Functor.Functor_0"]())(function (f) {
                  return f(Data_Monoid.mempty(dictMonoid));
              })(v);
          };
      });
  };
  var comonadTracedT = function (dictComonad) {
      return function (dictMonoid) {
          return new Control_Comonad.Comonad(function () {
              return extendTracedT(dictComonad["__superclass_Control.Extend.Extend_0"]())(dictMonoid["__superclass_Data.Semigroup.Semigroup_0"]());
          }, function (v) {
              return Control_Comonad.extract(dictComonad)(v)(Data_Monoid.mempty(dictMonoid));
          });
      };
  };
  exports["TracedT"] = TracedT;
  exports["runTracedT"] = runTracedT;
  exports["newtypeTracedT"] = newtypeTracedT;
  exports["functorTracedT"] = functorTracedT;
  exports["extendTracedT"] = extendTracedT;
  exports["comonadTracedT"] = comonadTracedT;
  exports["comonadTransTracedT"] = comonadTransTracedT;
})(PS["Control.Comonad.Traced.Trans"] = PS["Control.Comonad.Traced.Trans"] || {});
(function(exports) {
  
  /**
 *  | This module defines the `ComonadTraced` type class and its instances.
 */  
  "use strict";
  var Prelude = PS["Prelude"];
  var Control_Comonad = PS["Control.Comonad"];
  var Control_Comonad_Traced_Trans = PS["Control.Comonad.Traced.Trans"];
  var Data_Monoid = PS["Data.Monoid"];
  var Data_Tuple = PS["Data.Tuple"];
  var Data_Function = PS["Data.Function"];
  var Data_Functor = PS["Data.Functor"];
  var Control_Semigroupoid = PS["Control.Semigroupoid"];        

  /**
 *  | The `ComonadTraced` type class represents those monads which support relative (monoidal)
 *  | position information via `track`.
 *  |
 *  | - `track` extracts a value at the specified relative position.
 *  |
 *  | An implementation is provided for `TracedT`.
 *  |
 *  | Laws:
 *  |
 *  | - `track mempty = extract`
 *  | - `track s <<= track t x = track (s <> t) x`
 *  |
 *  | For example:
 *  |
 *  | ```purescript
 *  | blur :: forall w. (ComonadTraced (Additive Number) w) -> w Number -> w Number
 *  | blur = extend \r -> (track (Additive (-1)) r + track (Additive 1) r) / 2
 *  | ```
 */  
  var ComonadTraced = function (__superclass_Control$dotComonad$dotComonad_0, track) {
      this["__superclass_Control.Comonad.Comonad_0"] = __superclass_Control$dotComonad$dotComonad_0;
      this.track = track;
  };

  /**
 *  | The `ComonadTraced` type class represents those monads which support relative (monoidal)
 *  | position information via `track`.
 *  |
 *  | - `track` extracts a value at the specified relative position.
 *  |
 *  | An implementation is provided for `TracedT`.
 *  |
 *  | Laws:
 *  |
 *  | - `track mempty = extract`
 *  | - `track s <<= track t x = track (s <> t) x`
 *  |
 *  | For example:
 *  |
 *  | ```purescript
 *  | blur :: forall w. (ComonadTraced (Additive Number) w) -> w Number -> w Number
 *  | blur = extend \r -> (track (Additive (-1)) r + track (Additive 1) r) / 2
 *  | ```
 */  
  var track = function (dict) {
      return dict.track;
  };

  /**
 *  | Extracts a value at a relative position which depends on the current value.
 */  
  var tracks = function (dictComonadTraced) {
      return function (f) {
          return function (w) {
              return track(dictComonadTraced)(f(Control_Comonad.extract(dictComonadTraced["__superclass_Control.Comonad.Comonad_0"]())(w)))(w);
          };
      };
  };

  /**
 *  | Get a value which depends on the current position.
 */  
  var listens = function (dictFunctor) {
      return function (f) {
          return function (v) {
              return Data_Functor.map(dictFunctor)(function (g) {
                  return function (t) {
                      return new Data_Tuple.Tuple(g(t), f(t));
                  };
              })(v);
          };
      };
  };

  /**
 *  | Get the current position.
 */  
  var listen = function (dictFunctor) {
      return function (v) {
          return Data_Functor.map(dictFunctor)(function (f) {
              return function (t) {
                  return new Data_Tuple.Tuple(f(t), t);
              };
          })(v);
      };
  };
  var comonadTracedTracedT = function (dictComonad) {
      return function (dictMonoid) {
          return new ComonadTraced(function () {
              return Control_Comonad_Traced_Trans.comonadTracedT(dictComonad)(dictMonoid);
          }, function (t) {
              return function (v) {
                  return Control_Comonad.extract(dictComonad)(v)(t);
              };
          });
      };
  };

  /**
 *  | Apply a function to the current position.
 */  
  var censor = function (dictFunctor) {
      return function (f) {
          return function (v) {
              return Data_Functor.map(dictFunctor)(function (v1) {
                  return function ($18) {
                      return v1(f($18));
                  };
              })(v);
          };
      };
  };
  exports["ComonadTraced"] = ComonadTraced;
  exports["censor"] = censor;
  exports["listen"] = listen;
  exports["listens"] = listens;
  exports["track"] = track;
  exports["tracks"] = tracks;
  exports["comonadTracedTracedT"] = comonadTracedTracedT;
})(PS["Control.Comonad.Traced.Class"] = PS["Control.Comonad.Traced.Class"] || {});
(function(exports) {
  
  /**
 *  | This module defines the `Traced` comonad.
 */  
  "use strict";
  var Prelude = PS["Prelude"];
  var Control_Comonad_Traced_Class = PS["Control.Comonad.Traced.Class"];
  var Control_Comonad_Traced_Trans = PS["Control.Comonad.Traced.Trans"];
  var Data_Identity = PS["Data.Identity"];
  var Data_Newtype = PS["Data.Newtype"];
  var Control_Semigroupoid = PS["Control.Semigroupoid"];        

  /**
 *  | Create a value in context in the `Traced` comonad.
 */  
  var traced = function ($2) {
      return Control_Comonad_Traced_Trans.TracedT(Data_Identity.Identity($2));
  };

  /**
 *  | Unwrap a value in the `Traced` comonad.
 */  
  var runTraced = function (v) {
      return Data_Newtype.unwrap(Data_Identity.newtypeIdentity)(v);
  };
  exports["runTraced"] = runTraced;
  exports["traced"] = traced;
})(PS["Control.Comonad.Traced"] = PS["Control.Comonad.Traced"] || {});
(function(exports) {
  
  /**
 *  | This module defines the `MonadCont` type class and its instances.
 */  
  "use strict";
  var Prelude = PS["Prelude"];        

  /**
 *  | The `MonadCont` type class represents those monads which support the
 *  | `callCC`, or _call-with-current-continuation_ operation.
 *  |
 *  | This action makes the current continuation available to the caller.
 *  |
 *  | For example:
 *  |
 *  | ```purescript
 *  | delay :: forall eff. Number -> ContT Unit (Eff (timeout :: Timeout | eff)) Unit
 *  | delay n = callCC \cont ->
 *  |   lift $ setTimeout n (runContT (cont unit) (\_ -> return unit))
 *  | ```
 *  | An implementation is provided for `ContT`, and for other monad transformers
 *  | defined in this library.
 */  
  var MonadCont = function (__superclass_Control$dotMonad$dotMonad_0, callCC) {
      this["__superclass_Control.Monad.Monad_0"] = __superclass_Control$dotMonad$dotMonad_0;
      this.callCC = callCC;
  };

  /**
 *  | The `MonadCont` type class represents those monads which support the
 *  | `callCC`, or _call-with-current-continuation_ operation.
 *  |
 *  | This action makes the current continuation available to the caller.
 *  |
 *  | For example:
 *  |
 *  | ```purescript
 *  | delay :: forall eff. Number -> ContT Unit (Eff (timeout :: Timeout | eff)) Unit
 *  | delay n = callCC \cont ->
 *  |   lift $ setTimeout n (runContT (cont unit) (\_ -> return unit))
 *  | ```
 *  | An implementation is provided for `ContT`, and for other monad transformers
 *  | defined in this library.
 */  
  var callCC = function (dict) {
      return dict.callCC;
  };
  exports["MonadCont"] = MonadCont;
  exports["callCC"] = callCC;
})(PS["Control.Monad.Cont.Class"] = PS["Control.Monad.Cont.Class"] || {});
(function(exports) {
    "use strict";

  exports.pureE = function (a) {
    return function () {
      return a;
    };
  };

  exports.bindE = function (a) {
    return function (f) {
      return function () {
        return f(a())();
      };
    };
  };

  exports.runPure = function (f) {
    return f();
  };

  exports.untilE = function (f) {
    return function () {
      while (!f());
      return {};
    };
  };

  exports.whileE = function (f) {
    return function (a) {
      return function () {
        while (f()) {
          a();
        }
        return {};
      };
    };
  };

  exports.forE = function (lo) {
    return function (hi) {
      return function (f) {
        return function () {
          for (var i = lo; i < hi; i++) {
            f(i)();
          }
        };
      };
    };
  };

  exports.foreachE = function (as) {
    return function (f) {
      return function () {
        for (var i = 0, l = as.length; i < l; i++) {
          f(as[i])();
        }
      };
    };
  };
})(PS["Control.Monad.Eff"] = PS["Control.Monad.Eff"] || {});
(function(exports) {
    "use strict";
  var $foreign = PS["Control.Monad.Eff"];
  var Control_Applicative = PS["Control.Applicative"];
  var Control_Apply = PS["Control.Apply"];
  var Control_Bind = PS["Control.Bind"];
  var Control_Monad = PS["Control.Monad"];
  var Data_Functor = PS["Data.Functor"];
  var Data_Unit = PS["Data.Unit"];        
  var monadEff = new Control_Monad.Monad(function () {
      return applicativeEff;
  }, function () {
      return bindEff;
  });
  var bindEff = new Control_Bind.Bind(function () {
      return applyEff;
  }, $foreign.bindE);
  var applyEff = new Control_Apply.Apply(function () {
      return functorEff;
  }, Control_Monad.ap(monadEff));
  var applicativeEff = new Control_Applicative.Applicative(function () {
      return applyEff;
  }, $foreign.pureE);
  var functorEff = new Data_Functor.Functor(Control_Applicative.liftA1(applicativeEff));
  exports["functorEff"] = functorEff;
  exports["applyEff"] = applyEff;
  exports["applicativeEff"] = applicativeEff;
  exports["bindEff"] = bindEff;
  exports["monadEff"] = monadEff;
  exports["forE"] = $foreign.forE;
  exports["foreachE"] = $foreign.foreachE;
  exports["runPure"] = $foreign.runPure;
  exports["untilE"] = $foreign.untilE;
  exports["whileE"] = $foreign.whileE;
})(PS["Control.Monad.Eff"] = PS["Control.Monad.Eff"] || {});
(function(exports) {
    "use strict";
  var Control_Category = PS["Control.Category"];
  var Control_Monad = PS["Control.Monad"];
  var Control_Monad_Eff = PS["Control.Monad.Eff"];        

  /**
 *  | The `MonadEff` class captures those monads which support native effects.
 *  |
 *  | Instances are provided for `Eff` itself, and the standard monad
 *  | transformers.
 *  |
 *  | `liftEff` can be used in any appropriate monad transformer stack to lift an
 *  | action of type `Eff eff a` into the monad.
 *  |
 *  | Note that `MonadEff` is parameterized by the row of effects, so type
 *  | inference can be tricky. It is generally recommended to either work with a
 *  | polymorphic row of effects, or a concrete, closed row of effects such as
 *  | `(trace :: Trace)`.
 */  
  var MonadEff = function (__superclass_Control$dotMonad$dotMonad_0, liftEff) {
      this["__superclass_Control.Monad.Monad_0"] = __superclass_Control$dotMonad$dotMonad_0;
      this.liftEff = liftEff;
  };
  var monadEffEff = new MonadEff(function () {
      return Control_Monad_Eff.monadEff;
  }, Control_Category.id(Control_Category.categoryFn));

  /**
 *  | The `MonadEff` class captures those monads which support native effects.
 *  |
 *  | Instances are provided for `Eff` itself, and the standard monad
 *  | transformers.
 *  |
 *  | `liftEff` can be used in any appropriate monad transformer stack to lift an
 *  | action of type `Eff eff a` into the monad.
 *  |
 *  | Note that `MonadEff` is parameterized by the row of effects, so type
 *  | inference can be tricky. It is generally recommended to either work with a
 *  | polymorphic row of effects, or a concrete, closed row of effects such as
 *  | `(trace :: Trace)`.
 */  
  var liftEff = function (dict) {
      return dict.liftEff;
  };
  exports["MonadEff"] = MonadEff;
  exports["liftEff"] = liftEff;
  exports["monadEffEff"] = monadEffEff;
})(PS["Control.Monad.Eff.Class"] = PS["Control.Monad.Eff.Class"] || {});
(function(exports) {
  
  /**
 *  | This module defines the `MonadReader` type class and its instances.
 */  
  "use strict";
  var Prelude = PS["Prelude"];
  var Control_Category = PS["Control.Category"];
  var Control_Semigroupoid = PS["Control.Semigroupoid"];
  var Control_Monad = PS["Control.Monad"];
  var Data_Functor = PS["Data.Functor"];        

  /**
 *  | The `MonadAsk` type class represents those monads which support a global
 *  | context that can be provided via the `ask` function.
 *  |
 *  | An implementation is provided for `ReaderT`, and for other monad
 *  | transformers defined in this library.
 *  |
 *  | Law:
 *  |
 *  | - `do { ask ; ask } = ask`
 */  
  var MonadAsk = function (__superclass_Control$dotMonad$dotMonad_0, ask) {
      this["__superclass_Control.Monad.Monad_0"] = __superclass_Control$dotMonad$dotMonad_0;
      this.ask = ask;
  };

  /**
 *  | An extension of the `MonadAsk` class that introduces a function `local f x`
 *  | that allows the value of the local context to be modified for the duration
 *  | of the execution of action `x`.
 *  |
 *  | An implementation is provided for `ReaderT`, and for other monad
 *  | transformers defined in this library.
 *  |
 *  | Laws in addition to the `MonadAsk` law:
 *  |
 *  | - `local f ask = f <$> ask`
 *  | - `local _ (pure a) = pure a`
 *  | - `local f (do { a <- x ; y }) = do { a <- local f x ; local f y }`
 */  
  var MonadReader = function (__superclass_Control$dotMonad$dotReader$dotClass$dotMonadAsk_0, local) {
      this["__superclass_Control.Monad.Reader.Class.MonadAsk_0"] = __superclass_Control$dotMonad$dotReader$dotClass$dotMonadAsk_0;
      this.local = local;
  };
  var monadAskFun = new MonadAsk(function () {
      return Control_Monad.monadFn;
  }, Control_Category.id(Control_Category.categoryFn));
  var monadReaderFun = new MonadReader(function () {
      return monadAskFun;
  }, Control_Semigroupoid.composeFlipped(Control_Semigroupoid.semigroupoidFn));

  /**
 *  | An extension of the `MonadAsk` class that introduces a function `local f x`
 *  | that allows the value of the local context to be modified for the duration
 *  | of the execution of action `x`.
 *  |
 *  | An implementation is provided for `ReaderT`, and for other monad
 *  | transformers defined in this library.
 *  |
 *  | Laws in addition to the `MonadAsk` law:
 *  |
 *  | - `local f ask = f <$> ask`
 *  | - `local _ (pure a) = pure a`
 *  | - `local f (do { a <- x ; y }) = do { a <- local f x ; local f y }`
 */  
  var local = function (dict) {
      return dict.local;
  };

  /**
 *  | The `MonadAsk` type class represents those monads which support a global
 *  | context that can be provided via the `ask` function.
 *  |
 *  | An implementation is provided for `ReaderT`, and for other monad
 *  | transformers defined in this library.
 *  |
 *  | Law:
 *  |
 *  | - `do { ask ; ask } = ask`
 */  
  var ask = function (dict) {
      return dict.ask;
  };

  /**
 *  | Projects a value from the global context in a `MonadAsk`.
 */  
  var asks = function (dictMonadAsk) {
      return function (f) {
          return Data_Functor.map((((dictMonadAsk["__superclass_Control.Monad.Monad_0"]())["__superclass_Control.Bind.Bind_1"]())["__superclass_Control.Apply.Apply_0"]())["__superclass_Data.Functor.Functor_0"]())(f)(ask(dictMonadAsk));
      };
  };
  exports["MonadAsk"] = MonadAsk;
  exports["MonadReader"] = MonadReader;
  exports["ask"] = ask;
  exports["asks"] = asks;
  exports["local"] = local;
  exports["monadAskFun"] = monadAskFun;
  exports["monadReaderFun"] = monadReaderFun;
})(PS["Control.Monad.Reader.Class"] = PS["Control.Monad.Reader.Class"] || {});
(function(exports) {
  
  /**
 *  | This module defines the `MonadState` type class and its instances.
 */  
  "use strict";
  var Prelude = PS["Prelude"];
  var Data_Tuple = PS["Data.Tuple"];
  var Data_Unit = PS["Data.Unit"];        

  /**
 *  | The `MonadState s` type class represents those monads which support a single piece of mutable
 *  | state of type `s`.
 *  |
 *  | - `state f` updates the state using the function `f`.
 *  |
 *  | An implementation is provided for `StateT`, and for other monad transformers
 *  | defined in this library.
 *  |
 *  | Laws:
 *  |
 *  | - `do { get ; get } = get`
 *  | - `do { put x ; put y } = put y`
 *  | - `do { put x ; get } = put x $> x`
 *  | - `do { s <- get ; put s } = pure unit`
 *  |
 */  
  var MonadState = function (__superclass_Control$dotMonad$dotMonad_0, state) {
      this["__superclass_Control.Monad.Monad_0"] = __superclass_Control$dotMonad$dotMonad_0;
      this.state = state;
  };

  /**
 *  | The `MonadState s` type class represents those monads which support a single piece of mutable
 *  | state of type `s`.
 *  |
 *  | - `state f` updates the state using the function `f`.
 *  |
 *  | An implementation is provided for `StateT`, and for other monad transformers
 *  | defined in this library.
 *  |
 *  | Laws:
 *  |
 *  | - `do { get ; get } = get`
 *  | - `do { put x ; put y } = put y`
 *  | - `do { put x ; get } = put x $> x`
 *  | - `do { s <- get ; put s } = pure unit`
 *  |
 */  
  var state = function (dict) {
      return dict.state;
  };

  /**
 *  | Set the state.
 */  
  var put = function (dictMonadState) {
      return function (s) {
          return state(dictMonadState)(function (v) {
              return new Data_Tuple.Tuple(Data_Unit.unit, s);
          });
      };
  };

  /**
 *  | Modify the state by applying a function to the current state.
 */  
  var modify = function (dictMonadState) {
      return function (f) {
          return state(dictMonadState)(function (s) {
              return new Data_Tuple.Tuple(Data_Unit.unit, f(s));
          });
      };
  };

  /**
 *  | Get a value which depends on the current state.
 */  
  var gets = function (dictMonadState) {
      return function (f) {
          return state(dictMonadState)(function (s) {
              return new Data_Tuple.Tuple(f(s), s);
          });
      };
  };

  /**
 *  | Get the current state.
 */  
  var get = function (dictMonadState) {
      return state(dictMonadState)(function (s) {
          return new Data_Tuple.Tuple(s, s);
      });
  };
  exports["MonadState"] = MonadState;
  exports["get"] = get;
  exports["gets"] = gets;
  exports["modify"] = modify;
  exports["put"] = put;
  exports["state"] = state;
})(PS["Control.Monad.State.Class"] = PS["Control.Monad.State.Class"] || {});
(function(exports) {
  
  /**
 *  | This module defines the `MonadTrans` type class of _monad transformers_.
 */  
  "use strict";
  var Prelude = PS["Prelude"];        

  /**
 *  | The `MonadTrans` type class represents _monad transformers_.
 *  |
 *  | A monad transformer is a type constructor of kind `(* -> *) -> * -> *`, which
 *  | takes a `Monad` as its first argument, and returns another `Monad`.
 *  |
 *  | This allows us to add additional effects to an existing monad. By iterating this
 *  | process, we create monad transformer _stacks_, which contain all of the effects
 *  | required for a particular computation.
 *  |
 *  | The laws state that `lift` is a `Monad` morphism.
 *  |
 *  | Laws:
 *  |
 *  | - `lift (pure a) = pure a`
 *  | - `lift (do { x <- m ; y }) = do { x <- lift m ; lift y }`
 */  
  var MonadTrans = function (lift) {
      this.lift = lift;
  };

  /**
 *  | The `MonadTrans` type class represents _monad transformers_.
 *  |
 *  | A monad transformer is a type constructor of kind `(* -> *) -> * -> *`, which
 *  | takes a `Monad` as its first argument, and returns another `Monad`.
 *  |
 *  | This allows us to add additional effects to an existing monad. By iterating this
 *  | process, we create monad transformer _stacks_, which contain all of the effects
 *  | required for a particular computation.
 *  |
 *  | The laws state that `lift` is a `Monad` morphism.
 *  |
 *  | Laws:
 *  |
 *  | - `lift (pure a) = pure a`
 *  | - `lift (do { x <- m ; y }) = do { x <- lift m ; lift y }`
 */  
  var lift = function (dict) {
      return dict.lift;
  };
  exports["MonadTrans"] = MonadTrans;
  exports["lift"] = lift;
})(PS["Control.Monad.Trans.Class"] = PS["Control.Monad.Trans.Class"] || {});
(function(exports) {
  
  /**
 *  | This module defines the CPS monad transformer.
 */  
  "use strict";
  var Prelude = PS["Prelude"];
  var Control_Monad_Cont_Class = PS["Control.Monad.Cont.Class"];
  var Control_Monad_Eff_Class = PS["Control.Monad.Eff.Class"];
  var Control_Monad_Reader_Class = PS["Control.Monad.Reader.Class"];
  var Control_Monad_State_Class = PS["Control.Monad.State.Class"];
  var Control_Monad_Trans_Class = PS["Control.Monad.Trans.Class"];
  var Data_Newtype = PS["Data.Newtype"];
  var Data_Functor = PS["Data.Functor"];
  var Data_Function = PS["Data.Function"];
  var Control_Apply = PS["Control.Apply"];
  var Control_Applicative = PS["Control.Applicative"];
  var Control_Bind = PS["Control.Bind"];
  var Control_Monad = PS["Control.Monad"];
  var Control_Semigroupoid = PS["Control.Semigroupoid"];        

  /**
 *  | The CPS monad transformer.
 *  |
 *  | This monad transformer extends the base monad with the operation `callCC`.
 */  
  var ContT = function (x) {
      return x;
  };

  /**
 *  | Modify the continuation in a `ContT` monad action
 */  
  var withContT = function (f) {
      return function (v) {
          return function (k) {
              return v(f(k));
          };
      };
  };

  /**
 *  | Run a computation in the `ContT` monad, by providing a continuation.
 */  
  var runContT = function (v) {
      return function (k) {
          return v(k);
      };
  };
  var newtypeContT = new Data_Newtype.Newtype(function (n) {
      return n;
  }, ContT);
  var monadTransContT = new Control_Monad_Trans_Class.MonadTrans(function (dictMonad) {
      return function (m) {
          return function (k) {
              return Control_Bind.bind(dictMonad["__superclass_Control.Bind.Bind_1"]())(m)(k);
          };
      };
  });

  /**
 *  | Modify the underlying action in a `ContT` monad action.
 */  
  var mapContT = function (f) {
      return function (v) {
          return function (k) {
              return f(v(k));
          };
      };
  };
  var functorContT = function (dictFunctor) {
      return new Data_Functor.Functor(function (f) {
          return function (v) {
              return function (k) {
                  return v(function (a) {
                      return k(f(a));
                  });
              };
          };
      });
  };
  var applyContT = function (dictApply) {
      return new Control_Apply.Apply(function () {
          return functorContT(dictApply["__superclass_Data.Functor.Functor_0"]());
      }, function (v) {
          return function (v1) {
              return function (k) {
                  return v(function (g) {
                      return v1(function (a) {
                          return k(g(a));
                      });
                  });
              };
          };
      });
  };
  var bindContT = function (dictBind) {
      return new Control_Bind.Bind(function () {
          return applyContT(dictBind["__superclass_Control.Apply.Apply_0"]());
      }, function (v) {
          return function (k) {
              return function (k$prime) {
                  return v(function (a) {
                      var $36 = k(a);
                      return $36(k$prime);
                  });
              };
          };
      });
  };
  var applicativeContT = function (dictApplicative) {
      return new Control_Applicative.Applicative(function () {
          return applyContT(dictApplicative["__superclass_Control.Apply.Apply_0"]());
      }, function (a) {
          return function (k) {
              return k(a);
          };
      });
  };
  var monadContT = function (dictMonad) {
      return new Control_Monad.Monad(function () {
          return applicativeContT(dictMonad["__superclass_Control.Applicative.Applicative_0"]());
      }, function () {
          return bindContT(dictMonad["__superclass_Control.Bind.Bind_1"]());
      });
  };
  var monadAskContT = function (dictMonadAsk) {
      return new Control_Monad_Reader_Class.MonadAsk(function () {
          return monadContT(dictMonadAsk["__superclass_Control.Monad.Monad_0"]());
      }, Control_Monad_Trans_Class.lift(monadTransContT)(dictMonadAsk["__superclass_Control.Monad.Monad_0"]())(Control_Monad_Reader_Class.ask(dictMonadAsk)));
  };
  var monadReaderContT = function (dictMonadReader) {
      return new Control_Monad_Reader_Class.MonadReader(function () {
          return monadAskContT(dictMonadReader["__superclass_Control.Monad.Reader.Class.MonadAsk_0"]());
      }, function (f) {
          return function (v) {
              return function (k) {
                  return Control_Bind.bind(((dictMonadReader["__superclass_Control.Monad.Reader.Class.MonadAsk_0"]())["__superclass_Control.Monad.Monad_0"]())["__superclass_Control.Bind.Bind_1"]())(Control_Monad_Reader_Class.ask(dictMonadReader["__superclass_Control.Monad.Reader.Class.MonadAsk_0"]()))(function (v1) {
                      return Control_Monad_Reader_Class.local(dictMonadReader)(f)(v(function ($42) {
                          return Control_Monad_Reader_Class.local(dictMonadReader)(Data_Function["const"](v1))(k($42));
                      }));
                  });
              };
          };
      });
  };
  var monadContContT = function (dictMonad) {
      return new Control_Monad_Cont_Class.MonadCont(function () {
          return monadContT(dictMonad);
      }, function (f) {
          return function (k) {
              var $41 = f(function (a) {
                  return function (v) {
                      return k(a);
                  };
              });
              return $41(k);
          };
      });
  };
  var monadEffContT = function (dictMonadEff) {
      return new Control_Monad_Eff_Class.MonadEff(function () {
          return monadContT(dictMonadEff["__superclass_Control.Monad.Monad_0"]());
      }, function ($43) {
          return Control_Monad_Trans_Class.lift(monadTransContT)(dictMonadEff["__superclass_Control.Monad.Monad_0"]())(Control_Monad_Eff_Class.liftEff(dictMonadEff)($43));
      });
  };
  var monadStateContT = function (dictMonadState) {
      return new Control_Monad_State_Class.MonadState(function () {
          return monadContT(dictMonadState["__superclass_Control.Monad.Monad_0"]());
      }, function ($44) {
          return Control_Monad_Trans_Class.lift(monadTransContT)(dictMonadState["__superclass_Control.Monad.Monad_0"]())(Control_Monad_State_Class.state(dictMonadState)($44));
      });
  };
  exports["ContT"] = ContT;
  exports["mapContT"] = mapContT;
  exports["runContT"] = runContT;
  exports["withContT"] = withContT;
  exports["newtypeContT"] = newtypeContT;
  exports["monadContContT"] = monadContContT;
  exports["functorContT"] = functorContT;
  exports["applyContT"] = applyContT;
  exports["applicativeContT"] = applicativeContT;
  exports["bindContT"] = bindContT;
  exports["monadContT"] = monadContT;
  exports["monadTransContT"] = monadTransContT;
  exports["monadEffContT"] = monadEffContT;
  exports["monadAskContT"] = monadAskContT;
  exports["monadReaderContT"] = monadReaderContT;
  exports["monadStateContT"] = monadStateContT;
})(PS["Control.Monad.Cont.Trans"] = PS["Control.Monad.Cont.Trans"] || {});
(function(exports) {
  
  /**
 *  | This module defines the `Cont`inuation monad.
 */  
  "use strict";
  var Prelude = PS["Prelude"];
  var Control_Monad_Cont_Class = PS["Control.Monad.Cont.Class"];
  var Control_Monad_Cont_Trans = PS["Control.Monad.Cont.Trans"];
  var Data_Identity = PS["Data.Identity"];
  var Data_Newtype = PS["Data.Newtype"];
  var Control_Semigroupoid = PS["Control.Semigroupoid"];        

  /**
 *  | Transform the continuation passed into the continuation-passing function.
 */  
  var withCont = function (f) {
      return Control_Monad_Cont_Trans.withContT(function ($0) {
          return function ($1) {
              return Data_Identity.Identity(f(function ($2) {
                  return Data_Newtype.unwrap(Data_Identity.newtypeIdentity)($0($2));
              })($1));
          };
      });
  };

  /**
 *  | Runs a computation in the `Cont` monad.
 */  
  var runCont = function (cc) {
      return function (k) {
          return Data_Newtype.unwrap(Data_Identity.newtypeIdentity)(Control_Monad_Cont_Trans.runContT(cc)(function ($3) {
              return Data_Identity.Identity(k($3));
          }));
      };
  };

  /**
 *  | Transform the result of a continuation-passing function.
 */  
  var mapCont = function (f) {
      return Control_Monad_Cont_Trans.mapContT(function ($4) {
          return Data_Identity.Identity(f(Data_Newtype.unwrap(Data_Identity.newtypeIdentity)($4)));
      });
  };

  /**
 *  | Creates a computation in the `Cont` monad.
 */  
  var cont = function (f) {
      return function (c) {
          return f(function ($5) {
              return Data_Newtype.unwrap(Data_Identity.newtypeIdentity)(c($5));
          });
      };
  };
  exports["cont"] = cont;
  exports["runCont"] = runCont;
})(PS["Control.Monad.Cont"] = PS["Control.Monad.Cont"] || {});
(function(exports) {
    "use strict";

  exports.log = function (s) {
    return function () {
      console.log(s);
      return {};
    };
  };

  exports.warn = function (s) {
    return function () {
      console.warn(s);
      return {};
    };
  };

  exports.error = function (s) {
    return function () {
      console.error(s);
      return {};
    };
  };

  exports.info = function (s) {
    return function () {
      console.info(s);
      return {};
    };
  };
})(PS["Control.Monad.Eff.Console"] = PS["Control.Monad.Eff.Console"] || {});
(function(exports) {
    "use strict";
  var $foreign = PS["Control.Monad.Eff.Console"];
  var Control_Monad_Eff = PS["Control.Monad.Eff"];
  var Data_Show = PS["Data.Show"];
  var Data_Unit = PS["Data.Unit"];        

  /**
 *  | Write an warning value to the console, using its `Show` instance to produce
 *  | a `String`.
 */  
  var warnShow = function (dictShow) {
      return function (a) {
          return $foreign.warn(Data_Show.show(dictShow)(a));
      };
  };

  /**
 *  | Write a value to the console, using its `Show` instance to produce a
 *  | `String`.
 */  
  var logShow = function (dictShow) {
      return function (a) {
          return $foreign.log(Data_Show.show(dictShow)(a));
      };
  };

  /**
 *  | Write an info value to the console, using its `Show` instance to produce a
 *  | `String`.
 */  
  var infoShow = function (dictShow) {
      return function (a) {
          return $foreign.info(Data_Show.show(dictShow)(a));
      };
  };

  /**
 *  | Write an error value to the console, using its `Show` instance to produce a
 *  | `String`.
 */  
  var errorShow = function (dictShow) {
      return function (a) {
          return $foreign.error(Data_Show.show(dictShow)(a));
      };
  };
  exports["errorShow"] = errorShow;
  exports["infoShow"] = infoShow;
  exports["logShow"] = logShow;
  exports["warnShow"] = warnShow;
  exports["error"] = $foreign.error;
  exports["info"] = $foreign.info;
  exports["log"] = $foreign.log;
  exports["warn"] = $foreign.warn;
})(PS["Control.Monad.Eff.Console"] = PS["Control.Monad.Eff.Console"] || {});
(function(exports) {
    "use strict";

  exports.showErrorImpl = function (err) {
    return err.stack || err.toString();
  };

  exports.error = function (msg) {
    return new Error(msg);
  };

  exports.message = function (e) {
    return e.message;
  };

  exports.stackImpl = function (just) {
    return function (nothing) {
      return function (e) {
        return e.stack ? just(e.stack) : nothing;
      };
    };
  };

  exports.throwException = function (e) {
    return function () {
      throw e;
    };
  };

  exports.catchException = function (c) {
    return function (t) {
      return function () {
        try {
          return t();
        } catch (e) {
          if (e instanceof Error || Object.prototype.toString.call(e) === "[object Error]") {
            return c(e)();
          } else {
            return c(new Error(e.toString()))();
          }
        }
      };
    };
  };
})(PS["Control.Monad.Eff.Exception"] = PS["Control.Monad.Eff.Exception"] || {});
(function(exports) {
    "use strict";
  var Prelude = PS["Prelude"];
  var Control_Alt = PS["Control.Alt"];
  var Control_Extend = PS["Control.Extend"];
  var Data_Bifoldable = PS["Data.Bifoldable"];
  var Data_Bifunctor = PS["Data.Bifunctor"];
  var Data_Bitraversable = PS["Data.Bitraversable"];
  var Data_Foldable = PS["Data.Foldable"];
  var Data_Functor_Invariant = PS["Data.Functor.Invariant"];
  var Data_Monoid = PS["Data.Monoid"];
  var Data_Traversable = PS["Data.Traversable"];
  var Data_Functor = PS["Data.Functor"];
  var Control_Apply = PS["Control.Apply"];
  var Control_Applicative = PS["Control.Applicative"];
  var Control_Bind = PS["Control.Bind"];
  var Control_Monad = PS["Control.Monad"];
  var Data_Show = PS["Data.Show"];
  var Data_Semigroup = PS["Data.Semigroup"];
  var Data_Eq = PS["Data.Eq"];
  var Data_Ord = PS["Data.Ord"];
  var Data_Ordering = PS["Data.Ordering"];
  var Data_Bounded = PS["Data.Bounded"];
  var Data_Semiring = PS["Data.Semiring"];
  var Data_Function = PS["Data.Function"];        

  /**
 *  | The `Either` type is used to represent a choice between two types of value.
 *  |
 *  | A common use case for `Either` is error handling, where `Left` is used to
 *  | carry an error value and `Right` is used to carry a success value.
 */  
  var Left = (function () {
      function Left(value0) {
          this.value0 = value0;
      };
      Left.create = function (value0) {
          return new Left(value0);
      };
      return Left;
  })();

  /**
 *  | The `Either` type is used to represent a choice between two types of value.
 *  |
 *  | A common use case for `Either` is error handling, where `Left` is used to
 *  | carry an error value and `Right` is used to carry a success value.
 */  
  var Right = (function () {
      function Right(value0) {
          this.value0 = value0;
      };
      Right.create = function (value0) {
          return new Right(value0);
      };
      return Right;
  })();

  /**
 *  | The `Show` instance allows `Either` values to be rendered as a string with
 *  | `show` whenever there is an `Show` instance for both type the `Either` can
 *  | contain.
 */  
  var showEither = function (dictShow) {
      return function (dictShow1) {
          return new Data_Show.Show(function (v) {
              if (v instanceof Left) {
                  return "(Left " + (Data_Show.show(dictShow)(v.value0) + ")");
              };
              if (v instanceof Right) {
                  return "(Right " + (Data_Show.show(dictShow1)(v.value0) + ")");
              };
              throw new Error("Failed pattern match at Data.Either line 159, column 3 - line 160, column 3: " + [ v.constructor.name ]);
          });
      };
  };

  /**
 *  | The `Functor` instance allows functions to transform the contents of a
 *  | `Right` with the `<$>` operator:
 *  |
 *  | ``` purescript
 *  | f <$> Right x == Right (f x)
 *  | ```
 *  |
 *  | `Left` values are untouched:
 *  |
 *  | ``` purescript
 *  | f <$> Left y == Left y
 *  | ```
 */  
  var functorEither = new Data_Functor.Functor(function (v) {
      return function (v1) {
          if (v1 instanceof Left) {
              return new Left(v1.value0);
          };
          if (v1 instanceof Right) {
              return new Right(v(v1.value0));
          };
          throw new Error("Failed pattern match at Data.Either line 35, column 3 - line 35, column 26: " + [ v.constructor.name, v1.constructor.name ]);
      };
  });
  var invariantEither = new Data_Functor_Invariant.Invariant(Data_Functor_Invariant.imapF(functorEither));

  /**
 *  | A partial function that extracts the value from the `Right` data constructor.
 *  | Passing a `Left` to `fromRight` will throw an error at runtime.
 */  
  var fromRight = function (dictPartial) {
      return function (v) {
          var __unused = function (dictPartial1) {
              return function ($dollar60) {
                  return $dollar60;
              };
          };
          return __unused(dictPartial)((function () {
              if (v instanceof Right) {
                  return v.value0;
              };
              throw new Error("Failed pattern match at Data.Either line 243, column 1 - line 243, column 23: " + [ v.constructor.name ]);
          })());
      };
  };

  /**
 *  | A partial function that extracts the value from the `Left` data constructor.
 *  | Passing a `Right` to `fromLeft` will throw an error at runtime.
 */  
  var fromLeft = function (dictPartial) {
      return function (v) {
          var __unused = function (dictPartial1) {
              return function ($dollar64) {
                  return $dollar64;
              };
          };
          return __unused(dictPartial)((function () {
              if (v instanceof Left) {
                  return v.value0;
              };
              throw new Error("Failed pattern match at Data.Either line 238, column 1 - line 238, column 22: " + [ v.constructor.name ]);
          })());
      };
  };
  var foldableEither = new Data_Foldable.Foldable(function (dictMonoid) {
      return function (f) {
          return function (v) {
              if (v instanceof Left) {
                  return Data_Monoid.mempty(dictMonoid);
              };
              if (v instanceof Right) {
                  return f(v.value0);
              };
              throw new Error("Failed pattern match at Data.Either line 183, column 3 - line 183, column 31: " + [ f.constructor.name, v.constructor.name ]);
          };
      };
  }, function (v) {
      return function (z) {
          return function (v1) {
              if (v1 instanceof Left) {
                  return z;
              };
              if (v1 instanceof Right) {
                  return v(z)(v1.value0);
              };
              throw new Error("Failed pattern match at Data.Either line 181, column 3 - line 181, column 26: " + [ v.constructor.name, z.constructor.name, v1.constructor.name ]);
          };
      };
  }, function (v) {
      return function (z) {
          return function (v1) {
              if (v1 instanceof Left) {
                  return z;
              };
              if (v1 instanceof Right) {
                  return v(v1.value0)(z);
              };
              throw new Error("Failed pattern match at Data.Either line 179, column 3 - line 179, column 26: " + [ v.constructor.name, z.constructor.name, v1.constructor.name ]);
          };
      };
  });
  var traversableEither = new Data_Traversable.Traversable(function () {
      return foldableEither;
  }, function () {
      return functorEither;
  }, function (dictApplicative) {
      return function (v) {
          if (v instanceof Left) {
              return Control_Applicative.pure(dictApplicative)(new Left(v.value0));
          };
          if (v instanceof Right) {
              return Data_Functor.map((dictApplicative["__superclass_Control.Apply.Apply_0"]())["__superclass_Data.Functor.Functor_0"]())(Right.create)(v.value0);
          };
          throw new Error("Failed pattern match at Data.Either line 197, column 3 - line 197, column 36: " + [ v.constructor.name ]);
      };
  }, function (dictApplicative) {
      return function (v) {
          return function (v1) {
              if (v1 instanceof Left) {
                  return Control_Applicative.pure(dictApplicative)(new Left(v1.value0));
              };
              if (v1 instanceof Right) {
                  return Data_Functor.map((dictApplicative["__superclass_Control.Apply.Apply_0"]())["__superclass_Data.Functor.Functor_0"]())(Right.create)(v(v1.value0));
              };
              throw new Error("Failed pattern match at Data.Either line 195, column 3 - line 195, column 39: " + [ v.constructor.name, v1.constructor.name ]);
          };
      };
  });

  /**
 *  | The `Extend` instance allows sequencing of `Either` values and functions
 *  | that accept an `Either` and return a non-`Either` result using the
 *  | `<<=` operator.
 *  |
 *  | ``` purescript
 *  | f <<= Left x = Left x
 *  | f <<= Right x = Right (f x)
 *  | ```
 */  
  var extendEither = new Control_Extend.Extend(function () {
      return functorEither;
  }, function (v) {
      return function (v1) {
          if (v1 instanceof Left) {
              return new Left(v1.value0);
          };
          return new Right(v(v1));
      };
  });

  /**
 *  | The `Eq` instance allows `Either` values to be checked for equality with
 *  | `==` and inequality with `/=` whenever there is an `Eq` instance for both
 *  | types the `Either` can contain.
 */  
  var eqEither = function (dictEq) {
      return function (dictEq1) {
          return new Data_Eq.Eq(function (x) {
              return function (y) {
                  if (x instanceof Left && y instanceof Left) {
                      return Data_Eq.eq(dictEq)(x.value0)(y.value0);
                  };
                  if (x instanceof Right && y instanceof Right) {
                      return Data_Eq.eq(dictEq1)(x.value0)(y.value0);
                  };
                  return false;
              };
          });
      };
  };

  /**
 *  | The `Ord` instance allows `Either` values to be compared with
 *  | `compare`, `>`, `>=`, `<` and `<=` whenever there is an `Ord` instance for
 *  | both types the `Either` can contain.
 *  |
 *  | Any `Left` value is considered to be less than a `Right` value.
 */  
  var ordEither = function (dictOrd) {
      return function (dictOrd1) {
          return new Data_Ord.Ord(function () {
              return eqEither(dictOrd["__superclass_Data.Eq.Eq_0"]())(dictOrd1["__superclass_Data.Eq.Eq_0"]());
          }, function (x) {
              return function (y) {
                  if (x instanceof Left && y instanceof Left) {
                      return Data_Ord.compare(dictOrd)(x.value0)(y.value0);
                  };
                  if (x instanceof Left) {
                      return Data_Ordering.LT.value;
                  };
                  if (y instanceof Left) {
                      return Data_Ordering.GT.value;
                  };
                  if (x instanceof Right && y instanceof Right) {
                      return Data_Ord.compare(dictOrd1)(x.value0)(y.value0);
                  };
                  throw new Error("Failed pattern match at Data.Either line 172, column 1 - line 172, column 64: " + [ x.constructor.name, y.constructor.name ]);
              };
          });
      };
  };

  /**
 *  | Takes two functions and an `Either` value, if the value is a `Left` the
 *  | inner value is applied to the first function, if the value is a `Right`
 *  | the inner value is applied to the second function.
 *  |
 *  | ``` purescript
 *  | either f g (Left x) == f x
 *  | either f g (Right y) == g y
 *  | ```
 */  
  var either = function (v) {
      return function (v1) {
          return function (v2) {
              if (v2 instanceof Left) {
                  return v(v2.value0);
              };
              if (v2 instanceof Right) {
                  return v1(v2.value0);
              };
              throw new Error("Failed pattern match at Data.Either line 224, column 1 - line 224, column 26: " + [ v.constructor.name, v1.constructor.name, v2.constructor.name ]);
          };
      };
  };

  /**
 *  | Returns `true` when the `Either` value was constructed with `Left`.
 */  
  var isLeft = either(Data_Function["const"](true))(Data_Function["const"](false));

  /**
 *  | Returns `true` when the `Either` value was constructed with `Right`.
 */  
  var isRight = either(Data_Function["const"](false))(Data_Function["const"](true));
  var boundedEither = function (dictBounded) {
      return function (dictBounded1) {
          return new Data_Bounded.Bounded(function () {
              return ordEither(dictBounded["__superclass_Data.Ord.Ord_0"]())(dictBounded1["__superclass_Data.Ord.Ord_0"]());
          }, new Left(Data_Bounded.bottom(dictBounded)), new Right(Data_Bounded.top(dictBounded1)));
      };
  };
  var bifunctorEither = new Data_Bifunctor.Bifunctor(function (v) {
      return function (v1) {
          return function (v2) {
              if (v2 instanceof Left) {
                  return new Left(v(v2.value0));
              };
              if (v2 instanceof Right) {
                  return new Right(v1(v2.value0));
              };
              throw new Error("Failed pattern match at Data.Either line 42, column 3 - line 42, column 34: " + [ v.constructor.name, v1.constructor.name, v2.constructor.name ]);
          };
      };
  });
  var bifoldableEither = new Data_Bifoldable.Bifoldable(function (dictMonoid) {
      return function (v) {
          return function (v1) {
              return function (v2) {
                  if (v2 instanceof Left) {
                      return v(v2.value0);
                  };
                  if (v2 instanceof Right) {
                      return v1(v2.value0);
                  };
                  throw new Error("Failed pattern match at Data.Either line 191, column 3 - line 191, column 31: " + [ v.constructor.name, v1.constructor.name, v2.constructor.name ]);
              };
          };
      };
  }, function (v) {
      return function (v1) {
          return function (z) {
              return function (v2) {
                  if (v2 instanceof Left) {
                      return v(z)(v2.value0);
                  };
                  if (v2 instanceof Right) {
                      return v1(z)(v2.value0);
                  };
                  throw new Error("Failed pattern match at Data.Either line 189, column 3 - line 189, column 33: " + [ v.constructor.name, v1.constructor.name, z.constructor.name, v2.constructor.name ]);
              };
          };
      };
  }, function (v) {
      return function (v1) {
          return function (z) {
              return function (v2) {
                  if (v2 instanceof Left) {
                      return v(v2.value0)(z);
                  };
                  if (v2 instanceof Right) {
                      return v1(v2.value0)(z);
                  };
                  throw new Error("Failed pattern match at Data.Either line 187, column 3 - line 187, column 33: " + [ v.constructor.name, v1.constructor.name, z.constructor.name, v2.constructor.name ]);
              };
          };
      };
  });
  var bitraversableEither = new Data_Bitraversable.Bitraversable(function () {
      return bifoldableEither;
  }, function () {
      return bifunctorEither;
  }, function (dictApplicative) {
      return function (v) {
          if (v instanceof Left) {
              return Data_Functor.map((dictApplicative["__superclass_Control.Apply.Apply_0"]())["__superclass_Data.Functor.Functor_0"]())(Left.create)(v.value0);
          };
          if (v instanceof Right) {
              return Data_Functor.map((dictApplicative["__superclass_Control.Apply.Apply_0"]())["__superclass_Data.Functor.Functor_0"]())(Right.create)(v.value0);
          };
          throw new Error("Failed pattern match at Data.Either line 203, column 3 - line 203, column 35: " + [ v.constructor.name ]);
      };
  }, function (dictApplicative) {
      return function (v) {
          return function (v1) {
              return function (v2) {
                  if (v2 instanceof Left) {
                      return Data_Functor.map((dictApplicative["__superclass_Control.Apply.Apply_0"]())["__superclass_Data.Functor.Functor_0"]())(Left.create)(v(v2.value0));
                  };
                  if (v2 instanceof Right) {
                      return Data_Functor.map((dictApplicative["__superclass_Control.Apply.Apply_0"]())["__superclass_Data.Functor.Functor_0"]())(Right.create)(v1(v2.value0));
                  };
                  throw new Error("Failed pattern match at Data.Either line 201, column 3 - line 201, column 41: " + [ v.constructor.name, v1.constructor.name, v2.constructor.name ]);
              };
          };
      };
  });

  /**
 *  | The `Apply` instance allows functions contained within a `Right` to
 *  | transform a value contained within a `Right` using the `(<*>)` operator:
 *  |
 *  | ``` purescript
 *  | Right f <*> Right x == Right (f x)
 *  | ```
 *  |
 *  | `Left` values are left untouched:
 *  |
 *  | ``` purescript
 *  | Left f <*> Right x == Left x
 *  | Right f <*> Left y == Left y
 *  | ```
 *  |
 *  | Combining `Functor`'s `<$>` with `Apply`'s `<*>` can be used to transform a
 *  | pure function to take `Either`-typed arguments so `f :: a -> b -> c`
 *  | becomes `f :: Either l a -> Either l b -> Either l c`:
 *  |
 *  | ``` purescript
 *  | f <$> Right x <*> Right y == Right (f x y)
 *  | ```
 *  |
 *  | The `Left`-preserving behaviour of both operators means the result of
 *  | an expression like the above but where any one of the values is `Left`
 *  | means the whole result becomes `Left` also, taking the first `Left` value
 *  | found:
 *  |
 *  | ``` purescript
 *  | f <$> Left x <*> Right y == Left x
 *  | f <$> Right x <*> Left y == Left y
 *  | f <$> Left x <*> Left y == Left x
 *  | ```
 */  
  var applyEither = new Control_Apply.Apply(function () {
      return functorEither;
  }, function (v) {
      return function (v1) {
          if (v instanceof Left) {
              return new Left(v.value0);
          };
          if (v instanceof Right) {
              return Data_Functor.map(functorEither)(v.value0)(v1);
          };
          throw new Error("Failed pattern match at Data.Either line 78, column 3 - line 78, column 28: " + [ v.constructor.name, v1.constructor.name ]);
      };
  });

  /**
 *  | The `Bind` instance allows sequencing of `Either` values and functions that
 *  | return an `Either` by using the `>>=` operator:
 *  |
 *  | ``` purescript
 *  | Left x >>= f = Left x
 *  | Right x >>= f = f x
 *  | ```
 */  
  var bindEither = new Control_Bind.Bind(function () {
      return applyEither;
  }, either(function (e) {
      return function (v) {
          return new Left(e);
      };
  })(function (a) {
      return function (f) {
          return f(a);
      };
  }));
  var semigroupEither = function (dictSemigroup) {
      return new Data_Semigroup.Semigroup(function (x) {
          return function (y) {
              return Control_Apply.apply(applyEither)(Data_Functor.map(functorEither)(Data_Semigroup.append(dictSemigroup))(x))(y);
          };
      });
  };
  var semiringEither = function (dictSemiring) {
      return new Data_Semiring.Semiring(function (x) {
          return function (y) {
              return Control_Apply.apply(applyEither)(Data_Functor.map(functorEither)(Data_Semiring.add(dictSemiring))(x))(y);
          };
      }, function (x) {
          return function (y) {
              return Control_Apply.apply(applyEither)(Data_Functor.map(functorEither)(Data_Semiring.mul(dictSemiring))(x))(y);
          };
      }, new Right(Data_Semiring.one(dictSemiring)), new Right(Data_Semiring.zero(dictSemiring)));
  };

  /**
 *  | The `Applicative` instance enables lifting of values into `Either` with the
 *  | `pure` function:
 *  |
 *  | ``` purescript
 *  | pure x :: Either _ _ == Right x
 *  | ```
 *  |
 *  | Combining `Functor`'s `<$>` with `Apply`'s `<*>` and `Applicative`'s
 *  | `pure` can be used to pass a mixture of `Either` and non-`Either` typed
 *  | values to a function that does not usually expect them, by using `pure`
 *  | for any value that is not already `Either` typed:
 *  |
 *  | ``` purescript
 *  | f <$> Right x <*> pure y == Right (f x y)
 *  | ```
 *  |
 *  | Even though `pure = Right` it is recommended to use `pure` in situations
 *  | like this as it allows the choice of `Applicative` to be changed later
 *  | without having to go through and replace `Right` with a new constructor.
 */  
  var applicativeEither = new Control_Applicative.Applicative(function () {
      return applyEither;
  }, Right.create);

  /**
 *  | The `Monad` instance guarantees that there are both `Applicative` and
 *  | `Bind` instances for `Either`. This also enables the `do` syntactic sugar:
 *  |
 *  | ``` purescript
 *  | do
 *  |   x' <- x
 *  |   y' <- y
 *  |   pure (f x' y')
 *  | ```
 *  |
 *  | Which is equivalent to:
 *  |
 *  | ``` purescript
 *  | x >>= (\x' -> y >>= (\y' -> pure (f x' y')))
 *  | ```
 */  
  var monadEither = new Control_Monad.Monad(function () {
      return applicativeEither;
  }, function () {
      return bindEither;
  });

  /**
 *  | The `Alt` instance allows for a choice to be made between two `Either`
 *  | values with the `<|>` operator, where the first `Right` encountered
 *  | is taken.
 *  |
 *  | ``` purescript
 *  | Right x <|> Right y == Right x
 *  | Left x <|> Right y == Right y
 *  | Left x <|> Left y == Left y
 *  | ```
 */  
  var altEither = new Control_Alt.Alt(function () {
      return functorEither;
  }, function (v) {
      return function (v1) {
          if (v instanceof Left) {
              return v1;
          };
          return v;
      };
  });
  exports["Left"] = Left;
  exports["Right"] = Right;
  exports["either"] = either;
  exports["fromLeft"] = fromLeft;
  exports["fromRight"] = fromRight;
  exports["isLeft"] = isLeft;
  exports["isRight"] = isRight;
  exports["functorEither"] = functorEither;
  exports["invariantEither"] = invariantEither;
  exports["bifunctorEither"] = bifunctorEither;
  exports["applyEither"] = applyEither;
  exports["applicativeEither"] = applicativeEither;
  exports["altEither"] = altEither;
  exports["bindEither"] = bindEither;
  exports["monadEither"] = monadEither;
  exports["extendEither"] = extendEither;
  exports["showEither"] = showEither;
  exports["eqEither"] = eqEither;
  exports["ordEither"] = ordEither;
  exports["boundedEither"] = boundedEither;
  exports["foldableEither"] = foldableEither;
  exports["bifoldableEither"] = bifoldableEither;
  exports["traversableEither"] = traversableEither;
  exports["bitraversableEither"] = bitraversableEither;
  exports["semiringEither"] = semiringEither;
  exports["semigroupEither"] = semigroupEither;
})(PS["Data.Either"] = PS["Data.Either"] || {});
(function(exports) {
  
  /**
 *  | This module defines an effect, actions and handlers for working
 *  | with JavaScript exceptions.
 */  
  "use strict";
  var $foreign = PS["Control.Monad.Eff.Exception"];
  var Prelude = PS["Prelude"];
  var Control_Monad_Eff = PS["Control.Monad.Eff"];
  var Data_Either = PS["Data.Either"];
  var Data_Maybe = PS["Data.Maybe"];
  var Data_Show = PS["Data.Show"];
  var Control_Semigroupoid = PS["Control.Semigroupoid"];
  var Control_Applicative = PS["Control.Applicative"];
  var Data_Functor = PS["Data.Functor"];        

  /**
 *  | Runs an Eff and returns eventual Exceptions as a `Left` value. If the
 *  | computation succeeds the result gets wrapped in a `Right`.
 *  |
 *  | For example:
 *  |
 *  | ```purescript
 *  | -- Notice that there is no EXCEPTION effect
 *  | main :: forall eff. Eff (console :: CONSOLE, fs :: FS | eff) Unit
 *  | main = do
 *  |   result <- try (readTextFile UTF8 "README.md")
 *  |   case result of
 *  |     Right lines ->
 *  |       Console.log ("README: \n" <> lines )
 *  |     Left error ->
 *  |       Console.error ("Couldn't open README.md. Error was: " <> show error)
 *  | ```
 */  
  var $$try = function (action) {
      return $foreign.catchException(function ($0) {
          return Control_Applicative.pure(Control_Monad_Eff.applicativeEff)(Data_Either.Left.create($0));
      })(Data_Functor.map(Control_Monad_Eff.functorEff)(Data_Either.Right.create)(action));
  };

  /**
 *  | A shortcut allowing you to throw an error in one step. Defined as
 *  | `throwException <<< error`.
 */  
  var $$throw = function ($1) {
      return $foreign.throwException($foreign.error($1));
  };

  /**
 *  | Get the stack trace from a JavaScript error
 */  
  var stack = $foreign.stackImpl(Data_Maybe.Just.create)(Data_Maybe.Nothing.value);
  var showError = new Data_Show.Show($foreign.showErrorImpl);
  exports["stack"] = stack;
  exports["throw"] = $$throw;
  exports["try"] = $$try;
  exports["showError"] = showError;
  exports["catchException"] = $foreign.catchException;
  exports["error"] = $foreign.error;
  exports["message"] = $foreign.message;
  exports["throwException"] = $foreign.throwException;
})(PS["Control.Monad.Eff.Exception"] = PS["Control.Monad.Eff.Exception"] || {});
(function(exports) {
    "use strict";

  exports.unsafeCoerceEff = function (f) {
    return f;
  };
})(PS["Control.Monad.Eff.Unsafe"] = PS["Control.Monad.Eff.Unsafe"] || {});
(function(exports) {
    "use strict";
  var $foreign = PS["Control.Monad.Eff.Unsafe"];
  var Control_Monad_Eff = PS["Control.Monad.Eff"];
  var Control_Semigroupoid = PS["Control.Semigroupoid"];        

  /**
 *  | Run an effectful computation.
 *  |
 *  | *Note*: use of this function can result in arbitrary side-effects.
 */  
  var unsafePerformEff = function ($0) {
      return Control_Monad_Eff.runPure($foreign.unsafeCoerceEff($0));
  };
  exports["unsafePerformEff"] = unsafePerformEff;
  exports["unsafeCoerceEff"] = $foreign.unsafeCoerceEff;
})(PS["Control.Monad.Eff.Unsafe"] = PS["Control.Monad.Eff.Unsafe"] || {});
(function(exports) {
    "use strict";
  var Control_Monad_Eff_Exception = PS["Control.Monad.Eff.Exception"];
  var Control_Monad_Eff_Unsafe = PS["Control.Monad.Eff.Unsafe"];
  var Control_Semigroupoid = PS["Control.Semigroupoid"];        

  /**
 *  | Throw an exception in pure code. This function should be used very
 *  | sparingly, as it can cause unexpected crashes at runtime.
 */  
  var unsafeThrowException = function ($0) {
      return Control_Monad_Eff_Unsafe.unsafePerformEff(Control_Monad_Eff_Exception.throwException($0));
  };

  /**
 *  | Defined as `unsafeThrowException <<< error`.
 */  
  var unsafeThrow = function ($1) {
      return unsafeThrowException(Control_Monad_Eff_Exception.error($1));
  };
  exports["unsafeThrow"] = unsafeThrow;
  exports["unsafeThrowException"] = unsafeThrowException;
})(PS["Control.Monad.Eff.Exception.Unsafe"] = PS["Control.Monad.Eff.Exception.Unsafe"] || {});
(function(exports) {
    "use strict";

  exports.random = Math.random;
})(PS["Control.Monad.Eff.Random"] = PS["Control.Monad.Eff.Random"] || {});
(function(exports) {
    "use strict";

  // module Data.Int

  exports.fromNumberImpl = function (just) {
    return function (nothing) {
      return function (n) {
        /* jshint bitwise: false */
        return (n | 0) === n ? just(n) : nothing;
      };
    };
  };

  exports.toNumber = function (n) {
    return n;
  };

  exports.fromStringAsImpl = function (just) {
    return function (nothing) {
      return function (radix) {
        var digits;
        if (radix < 11) {
          digits = "[0-" + (radix - 1).toString() + "]";
        } else if (radix === 11) {
          digits = "[0-9a]";
        } else {
          digits = "[0-9a-" + String.fromCharCode(86 + radix) + "]";
        }
        var pattern = new RegExp("^[\\+\\-]?" + digits + "+$", "i");

        return function (s) {
          /* jshint bitwise: false */
          if (pattern.test(s)) {
            var i = parseInt(s, radix);
            return (i | 0) === i ? just(i) : nothing;
          } else {
            return nothing;
          }
        };
      };
    };
  };

  exports.toStringAs = function (radix) {
    return function (i) {
      return i.toString(radix);
    };
  };
})(PS["Data.Int"] = PS["Data.Int"] || {});
(function(exports) {
    "use strict";

  /**
 *  | An alias for `true`, which can be useful in guard clauses:
 *  |
 *  | ```purescript
 *  | max x y | x >= y    = x
 *  |         | otherwise = y
 *  | ```
 */  
  var otherwise = true;
  exports["otherwise"] = otherwise;
})(PS["Data.Boolean"] = PS["Data.Boolean"] || {});
(function(exports) {
    "use strict";

  // module Data.Int.Bits

  exports.and = function (n1) {
    return function (n2) {
      /* jshint bitwise: false */
      return n1 & n2;
    };
  };

  exports.or = function (n1) {
    return function (n2) {
      /* jshint bitwise: false */
      return n1 | n2;
    };
  };

  exports.xor = function (n1) {
    return function (n2) {
      /* jshint bitwise: false */
      return n1 ^ n2;
    };
  };

  exports.shl = function (n1) {
    return function (n2) {
      /* jshint bitwise: false */
      return n1 << n2;
    };
  };

  exports.shr = function (n1) {
    return function (n2) {
      /* jshint bitwise: false */
      return n1 >> n2;
    };
  };

  exports.zshr = function (n1) {
    return function (n2) {
      /* jshint bitwise: false */
      return n1 >>> n2;
    };
  };

  exports.complement = function (n) {
    /* jshint bitwise: false */
    return ~n;
  };
})(PS["Data.Int.Bits"] = PS["Data.Int.Bits"] || {});
(function(exports) {
  
  /**
 *  | This module defines bitwise operations for the `Int` type.
 */  
  "use strict";
  var $foreign = PS["Data.Int.Bits"];
  exports["and"] = $foreign.and;
  exports["complement"] = $foreign.complement;
  exports["or"] = $foreign.or;
  exports["shl"] = $foreign.shl;
  exports["shr"] = $foreign.shr;
  exports["xor"] = $foreign.xor;
  exports["zshr"] = $foreign.zshr;
})(PS["Data.Int.Bits"] = PS["Data.Int.Bits"] || {});
(function(exports) {
    "use strict";

  // module Math

  exports.abs = Math.abs;

  exports.acos = Math.acos;

  exports.asin = Math.asin;

  exports.atan = Math.atan;

  exports.atan2 = function (y) {
    return function (x) {
      return Math.atan2(y, x);
    };
  };

  exports.ceil = Math.ceil;

  exports.cos = Math.cos;

  exports.exp = Math.exp;

  exports.floor = Math.floor;

  exports.trunc = Math.trunc || function (n) {
    return n < 0 ? Math.ceil(n) : Math.floor(n);
  };

  exports.log = Math.log;

  exports.max = function (n1) {
    return function (n2) {
      return Math.max(n1, n2);
    };
  };

  exports.min = function (n1) {
    return function (n2) {
      return Math.min(n1, n2);
    };
  };

  exports.pow = function (n) {
    return function (p) {
      return Math.pow(n, p);
    };
  };

  exports.remainder = function (n) {
    return function (m) {
      return n % m;
    };
  };

  exports.round = Math.round;

  exports.sin = Math.sin;

  exports.sqrt = Math.sqrt;

  exports.tan = Math.tan;

  exports.e = Math.E;

  exports.ln2 = Math.LN2;

  exports.ln10 = Math.LN10;

  exports.log2e = Math.LOG2E;

  exports.log10e = Math.LOG10E;

  exports.pi = Math.PI;

  exports.sqrt1_2 = Math.SQRT1_2;

  exports.sqrt2 = Math.SQRT2;
})(PS["Math"] = PS["Math"] || {});
(function(exports) {
  
  /**
 *  | Wraps the math functions and constants from Javascript's built-in `Math` object.
 *  | See [Math Reference at MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math).
 */  
  "use strict";
  var $foreign = PS["Math"];
  exports["abs"] = $foreign.abs;
  exports["acos"] = $foreign.acos;
  exports["asin"] = $foreign.asin;
  exports["atan"] = $foreign.atan;
  exports["atan2"] = $foreign.atan2;
  exports["ceil"] = $foreign.ceil;
  exports["cos"] = $foreign.cos;
  exports["e"] = $foreign.e;
  exports["exp"] = $foreign.exp;
  exports["floor"] = $foreign.floor;
  exports["ln10"] = $foreign.ln10;
  exports["ln2"] = $foreign.ln2;
  exports["log"] = $foreign.log;
  exports["log10e"] = $foreign.log10e;
  exports["log2e"] = $foreign.log2e;
  exports["max"] = $foreign.max;
  exports["min"] = $foreign.min;
  exports["pi"] = $foreign.pi;
  exports["pow"] = $foreign.pow;
  exports["remainder"] = $foreign.remainder;
  exports["round"] = $foreign.round;
  exports["sin"] = $foreign.sin;
  exports["sqrt"] = $foreign.sqrt;
  exports["sqrt1_2"] = $foreign.sqrt1_2;
  exports["sqrt2"] = $foreign.sqrt2;
  exports["tan"] = $foreign.tan;
  exports["trunc"] = $foreign.trunc;
})(PS["Math"] = PS["Math"] || {});
(function(exports) {
    "use strict";

  // module Partial.Unsafe

  exports.unsafePartial = function (f) {
    return f();
  };
})(PS["Partial.Unsafe"] = PS["Partial.Unsafe"] || {});
(function(exports) {
    "use strict";

  // module Partial

  exports.crashWith = function () {
    return function (msg) {
      throw new Error(msg);
    };
  };
})(PS["Partial"] = PS["Partial"] || {});
(function(exports) {
  
  /**
 *  | Some partial helper functions.
 */  
  "use strict";
  var $foreign = PS["Partial"];       

  /**
 *  | A partial function which crashes on any input with a default message.
 */  
  var crash = function (dictPartial) {
      return $foreign.crashWith(dictPartial)("Partial.crash: partial function");
  };
  exports["crash"] = crash;
  exports["crashWith"] = $foreign.crashWith;
})(PS["Partial"] = PS["Partial"] || {});
(function(exports) {
  
  /**
 *  | Utilities for working with partial functions.
 */  
  "use strict";
  var $foreign = PS["Partial.Unsafe"];
  var Partial = PS["Partial"];        

  /**
 *  | A function which crashes with the specified error message.
 */  
  var unsafeCrashWith = function (msg) {
      return $foreign.unsafePartial(function (dictPartial) {
          return Partial.crashWith(dictPartial)(msg);
      });
  };
  exports["unsafeCrashWith"] = unsafeCrashWith;
  exports["unsafePartial"] = $foreign.unsafePartial;
})(PS["Partial.Unsafe"] = PS["Partial.Unsafe"] || {});
(function(exports) {
    "use strict";
  var $foreign = PS["Data.Int"];
  var Data_Boolean = PS["Data.Boolean"];
  var Data_BooleanAlgebra = PS["Data.BooleanAlgebra"];
  var Data_Bounded = PS["Data.Bounded"];
  var Data_Eq = PS["Data.Eq"];
  var Data_Function = PS["Data.Function"];
  var Data_Int_Bits = PS["Data.Int.Bits"];
  var Data_Maybe = PS["Data.Maybe"];
  var Data_Ord = PS["Data.Ord"];
  var $$Math = PS["Math"];
  var Partial_Unsafe = PS["Partial.Unsafe"];
  var Data_HeytingAlgebra = PS["Data.HeytingAlgebra"];
  var Control_Semigroupoid = PS["Control.Semigroupoid"];        

  /**
 *  | The number of unique digits (including zero) used to represent integers in
 *  | a specific base.
 */  
  var Radix = function (x) {
      return x;
  };

  /**
 *  | Create a `Radix` from a number between 2 and 36.
 */  
  var radix = function (n) {
      if (n >= 2 && n <= 36) {
          return new Data_Maybe.Just(n);
      };
      if (Data_Boolean.otherwise) {
          return Data_Maybe.Nothing.value;
      };
      throw new Error("Failed pattern match at Data.Int line 124, column 1 - line 125, column 38: " + [ n.constructor.name ]);
  };

  /**
 *  | The negation of `even`.
 *  |
 *  | ``` purescript
 *  | odd 0 == false
 *  | odd 1 == false
 *  | ```
 */  
  var odd = function (x) {
      return (x & 1) !== 0;
  };

  /**
 *  | The base-8 system.
 */  
  var octal = 8;

  /**
 *  | The base-16 system.
 */  
  var hexadecimal = 16;

  /**
 *  | Like `fromString`, but the integer can be specified in a different base.
 *  |
 *  | Example:
 *  | ``` purs
 *  | fromStringAs binary      "100" == Just 4
 *  | fromStringAs hexadecimal "ff"  == Just 255
 *  | ```
 */  
  var fromStringAs = $foreign.fromStringAsImpl(Data_Maybe.Just.create)(Data_Maybe.Nothing.value);

  /**
 *  | Reads an `Int` from a `String` value. The number must parse as an integer
 *  | and fall within the valid range of values for the `Int` type, otherwise
 *  | `Nothing` is returned.
 */  
  var fromString = fromStringAs(10);

  /**
 *  | Creates an `Int` from a `Number` value. The number must already be an
 *  | integer and fall within the valid range of values for the `Int` type
 *  | otherwise `Nothing` is returned.
 */  
  var fromNumber = $foreign.fromNumberImpl(Data_Maybe.Just.create)(Data_Maybe.Nothing.value);

  /**
 *  | Convert an integral `Number` to an `Int`, by clamping to the `Int` range.
 *  | This function will throw an error at runtime if the argument is
 *  | non-integral.
 */  
  var unsafeClamp = function (x) {
      if (x >= $foreign.toNumber(Data_Bounded.top(Data_Bounded.boundedInt))) {
          return Data_Bounded.top(Data_Bounded.boundedInt);
      };
      if (x <= $foreign.toNumber(Data_Bounded.bottom(Data_Bounded.boundedInt))) {
          return Data_Bounded.bottom(Data_Bounded.boundedInt);
      };
      if (Data_Boolean.otherwise) {
          return Partial_Unsafe.unsafePartial(function (dictPartial) {
              return Data_Maybe.fromJust(dictPartial)(fromNumber(x));
          });
      };
      throw new Error("Failed pattern match at Data.Int line 65, column 1 - line 68, column 56: " + [ x.constructor.name ]);
  };

  /**
 *  | Convert a `Number` to an `Int`, by taking the nearest integer to the
 *  | argument. Values outside the `Int` range are clamped.
 */  
  var round = function ($3) {
      return unsafeClamp($$Math.round($3));
  };

  /**
 *  | Convert a `Number` to an `Int`, by taking the closest integer equal to or
 *  | less than the argument. Values outside the `Int` range are clamped.
 */  
  var floor = function ($4) {
      return unsafeClamp($$Math.floor($4));
  };

  /**
 *  | Returns whether an `Int` is an even number.
 *  |
 *  | ``` purescript
 *  | even 0 == true
 *  | even 1 == false
 *  | ```
 */  
  var even = function (x) {
      return (x & 1) === 0;
  };

  /**
 *  | The base-10 system.
 */  
  var decimal = 10;

  /**
 *  | Convert a `Number` to an `Int`, by taking the closest integer equal to or
 *  | greater than the argument. Values outside the `Int` range are clamped.
 */  
  var ceil = function ($5) {
      return unsafeClamp($$Math.ceil($5));
  };

  /**
 *  | The base-2 system.
 */  
  var binary = 2;

  /**
 *  | The base-36 system.
 */  
  var base36 = 36;
  exports["base36"] = base36;
  exports["binary"] = binary;
  exports["ceil"] = ceil;
  exports["decimal"] = decimal;
  exports["even"] = even;
  exports["floor"] = floor;
  exports["fromNumber"] = fromNumber;
  exports["fromString"] = fromString;
  exports["fromStringAs"] = fromStringAs;
  exports["hexadecimal"] = hexadecimal;
  exports["octal"] = octal;
  exports["odd"] = odd;
  exports["radix"] = radix;
  exports["round"] = round;
  exports["toNumber"] = $foreign.toNumber;
  exports["toStringAs"] = $foreign.toStringAs;
})(PS["Data.Int"] = PS["Data.Int"] || {});
(function(exports) {
    "use strict";
  var $foreign = PS["Control.Monad.Eff.Random"];
  var Prelude = PS["Prelude"];
  var Control_Monad_Eff = PS["Control.Monad.Eff"];
  var Data_Int = PS["Data.Int"];
  var Control_Bind = PS["Control.Bind"];
  var Control_Applicative = PS["Control.Applicative"];
  var Data_Semiring = PS["Data.Semiring"];
  var Data_Ring = PS["Data.Ring"];
  var Data_Function = PS["Data.Function"];
  var Data_Functor = PS["Data.Functor"];
  var Data_Ord = PS["Data.Ord"];        

  /**
 *  | Returns a random number between a minimum value (inclusive) and a maximum
 *  | value (exclusive). It is unspecified what happens if `maximum < minimum`.
 *  |
 *  | For example:
 *  | ``` purescript
 *  | randomRange 1.0 2.0 >>= Console.print
 *  | ```
 *  | will print a random number between 1 and 2.
 */  
  var randomRange = function (min) {
      return function (max) {
          return function __do() {
              var v = $foreign.random();
              return v * (max - min) + min;
          };
      };
  };

  /**
 *  | Takes a range specified by `low` (the first argument) and `high` (the
 *  | second), and returns a random integer uniformly distributed in the closed
 *  | interval `[low, high]`. It is unspecified what happens if `low > high`,
 *  | or if either of `low` or `high` is not an integer.
 *  |
 *  | For example:
 *  | ``` purescript
 *  | randomInt 1 10 >>= Console.print
 *  | ```
 *  | will print a random integer between 1 and 10.
 */  
  var randomInt = function (low) {
      return function (high) {
          return function __do() {
              var v = $foreign.random();
              var asNumber = ((Data_Int.toNumber(high) - Data_Int.toNumber(low)) + 1) * v + Data_Int.toNumber(low);
              return Data_Int.floor(asNumber);
          };
      };
  };

  /**
 *  | Returns a random boolean value with an equal chance of being `true` or
 *  | `false`.
 */  
  var randomBool = Data_Functor.map(Control_Monad_Eff.functorEff)(function (v) {
      return v < 0.5;
  })($foreign.random);
  exports["randomBool"] = randomBool;
  exports["randomInt"] = randomInt;
  exports["randomRange"] = randomRange;
  exports["random"] = $foreign.random;
})(PS["Control.Monad.Eff.Random"] = PS["Control.Monad.Eff.Random"] || {});
(function(exports) {
    "use strict";

  exports.newRef = function (val) {
    return function () {
      return { value: val };
    };
  };

  exports.readRef = function (ref) {
    return function () {
      return ref.value;
    };
  };

  exports["modifyRef'"] = function (ref) {
    return function (f) {
      return function () {
        var t = f(ref.value);
        ref.value = t.state;
        return t.value;
      };
    };
  };

  exports.writeRef = function (ref) {
    return function (val) {
      return function () {
        ref.value = val;
        return {};
      };
    };
  };
})(PS["Control.Monad.Eff.Ref"] = PS["Control.Monad.Eff.Ref"] || {});
(function(exports) {
  
  /**
 *  | This module defines an effect and actions for working with
 *  | global mutable variables.
 *  |
 *  | _Note_: The `Control.Monad.ST` provides a _safe_ alternative
 *  | to global mutable variables when mutation is restricted to a
 *  | local scope.
 */  
  "use strict";
  var $foreign = PS["Control.Monad.Eff.Ref"];
  var Prelude = PS["Prelude"];
  var Control_Monad_Eff = PS["Control.Monad.Eff"];
  var Data_Unit = PS["Data.Unit"];        

  /**
 *  | Update the value of a mutable reference by applying a function
 *  | to the current value.
 */  
  var modifyRef = function (ref) {
      return function (f) {
          return $foreign["modifyRef'"](ref)(function (s) {
              return {
                  state: f(s), 
                  value: Data_Unit.unit
              };
          });
      };
  };
  exports["modifyRef"] = modifyRef;
  exports["modifyRef'"] = $foreign["modifyRef'"];
  exports["newRef"] = $foreign.newRef;
  exports["readRef"] = $foreign.readRef;
  exports["writeRef"] = $foreign.writeRef;
})(PS["Control.Monad.Eff.Ref"] = PS["Control.Monad.Eff.Ref"] || {});
(function(exports) {
  
  /**
 *  | Unsafe functions for working with mutable references.
 */  
  "use strict";
  var Control_Monad_Eff = PS["Control.Monad.Eff"];
  var Control_Monad_Eff_Ref = PS["Control.Monad.Eff.Ref"];
  var Control_Monad_Eff_Unsafe = PS["Control.Monad.Eff.Unsafe"];        

  /**
 *  | This handler function unsafely removes the `Ref` effect from an
 *  | effectful action.
 *  |
 *  | This function might be used when it is impossible to prove to the
 *  | typechecker that a particular mutable reference does not escape
 *  | its scope.
 */  
  var unsafeRunRef = Control_Monad_Eff_Unsafe.unsafeCoerceEff;
  exports["unsafeRunRef"] = unsafeRunRef;
})(PS["Control.Monad.Eff.Ref.Unsafe"] = PS["Control.Monad.Eff.Ref.Unsafe"] || {});
(function(exports) {
  
  /**
 *  | This module defines the `MonadError` type class and its instances.
 */  
  "use strict";
  var Prelude = PS["Prelude"];
  var Data_Maybe = PS["Data.Maybe"];
  var Data_Either = PS["Data.Either"];
  var Data_Function = PS["Data.Function"];
  var Data_Unit = PS["Data.Unit"];        

  /**
 *  | The `MonadError` type class represents those monads which support errors via
 *  | `throwError` and `catchError`.
 *  |
 *  | - `throwError e` throws the error `e`
 *  | - `catchError x f` calls the error handler `f` if an error is thrown during the
 *  |   evaluation of `x`.
 *  |
 *  | An implementation is provided for `ErrorT`, and for other monad transformers
 *  | defined in this library.
 *  |
 *  | Laws:
 *  |
 *  | - Left zero: `throwError e >>= f = throwError e`
 *  | - Catch: `catchError (throwError e) f = f e`
 *  | - Pure: `catchError (pure a) f = pure a`
 *  |
 */  
  var MonadError = function (__superclass_Control$dotMonad$dotMonad_0, catchError, throwError) {
      this["__superclass_Control.Monad.Monad_0"] = __superclass_Control$dotMonad$dotMonad_0;
      this.catchError = catchError;
      this.throwError = throwError;
  };

  /**
 *  | The `MonadError` type class represents those monads which support errors via
 *  | `throwError` and `catchError`.
 *  |
 *  | - `throwError e` throws the error `e`
 *  | - `catchError x f` calls the error handler `f` if an error is thrown during the
 *  |   evaluation of `x`.
 *  |
 *  | An implementation is provided for `ErrorT`, and for other monad transformers
 *  | defined in this library.
 *  |
 *  | Laws:
 *  |
 *  | - Left zero: `throwError e >>= f = throwError e`
 *  | - Catch: `catchError (throwError e) f = f e`
 *  | - Pure: `catchError (pure a) f = pure a`
 *  |
 */  
  var throwError = function (dict) {
      return dict.throwError;
  };
  var monadErrorMaybe = new MonadError(function () {
      return Data_Maybe.monadMaybe;
  }, function (v) {
      return function (v1) {
          if (v instanceof Data_Maybe.Nothing) {
              return v1(Data_Unit.unit);
          };
          if (v instanceof Data_Maybe.Just) {
              return new Data_Maybe.Just(v.value0);
          };
          throw new Error("Failed pattern match at Control.Monad.Error.Class line 55, column 3 - line 55, column 33: " + [ v.constructor.name, v1.constructor.name ]);
      };
  }, Data_Function["const"](Data_Maybe.Nothing.value));
  var monadErrorEither = new MonadError(function () {
      return Data_Either.monadEither;
  }, function (v) {
      return function (v1) {
          if (v instanceof Data_Either.Left) {
              return v1(v.value0);
          };
          if (v instanceof Data_Either.Right) {
              return new Data_Either.Right(v.value0);
          };
          throw new Error("Failed pattern match at Control.Monad.Error.Class line 50, column 3 - line 50, column 30: " + [ v.constructor.name, v1.constructor.name ]);
      };
  }, Data_Either.Left.create);

  /**
 *  | The `MonadError` type class represents those monads which support errors via
 *  | `throwError` and `catchError`.
 *  |
 *  | - `throwError e` throws the error `e`
 *  | - `catchError x f` calls the error handler `f` if an error is thrown during the
 *  |   evaluation of `x`.
 *  |
 *  | An implementation is provided for `ErrorT`, and for other monad transformers
 *  | defined in this library.
 *  |
 *  | Laws:
 *  |
 *  | - Left zero: `throwError e >>= f = throwError e`
 *  | - Catch: `catchError (throwError e) f = f e`
 *  | - Pure: `catchError (pure a) f = pure a`
 *  |
 */  
  var catchError = function (dict) {
      return dict.catchError;
  };

  /**
 *  | This function allows you to provide a predicate for selecting the
 *  | exceptions that you're interested in, and handle only those exceptons.
 *  | If the inner computation throws an exception, and the predicate returns
 *  | Nothing, then the whole computation will still fail with that exception.
 */  
  var catchJust = function (dictMonadError) {
      return function (p) {
          return function (act) {
              return function (handler) {
                  var handle = function (e) {
                      var $12 = p(e);
                      if ($12 instanceof Data_Maybe.Nothing) {
                          return throwError(dictMonadError)(e);
                      };
                      if ($12 instanceof Data_Maybe.Just) {
                          return handler($12.value0);
                      };
                      throw new Error("Failed pattern match at Control.Monad.Error.Class line 44, column 5 - line 46, column 26: " + [ $12.constructor.name ]);
                  };
                  return catchError(dictMonadError)(act)(handle);
              };
          };
      };
  };
  exports["MonadError"] = MonadError;
  exports["catchError"] = catchError;
  exports["catchJust"] = catchJust;
  exports["throwError"] = throwError;
  exports["monadErrorEither"] = monadErrorEither;
  exports["monadErrorMaybe"] = monadErrorMaybe;
})(PS["Control.Monad.Error.Class"] = PS["Control.Monad.Error.Class"] || {});
(function(exports) {
    "use strict";

  exports.newSTRef = function (val) {
    return function () {
      return { value: val };
    };
  };

  exports.readSTRef = function (ref) {
    return function () {
      return ref.value;
    };
  };

  exports.modifySTRef = function (ref) {
    return function (f) {
      return function () {
        /* jshint boss: true */
        return ref.value = f(ref.value);
      };
    };
  };

  exports.writeSTRef = function (ref) {
    return function (a) {
      return function () {
        /* jshint boss: true */
        return ref.value = a;
      };
    };
  };

  exports.runST = function (f) {
    return f;
  };
})(PS["Control.Monad.ST"] = PS["Control.Monad.ST"] || {});
(function(exports) {
    "use strict";
  var $foreign = PS["Control.Monad.ST"];
  var Control_Monad_Eff = PS["Control.Monad.Eff"];        

  /**
 *  | A convenience function which combines `runST` with `runPure`, which can be
 *  | used when the only required effect is `ST`.
 *  |
 *  | Note: since this function has a rank-2 type, it may cause problems to apply
 *  | this function using the `$` operator. The recommended approach is to use
 *  | parentheses instead.
 */  
  var pureST = function (st) {
      return Control_Monad_Eff.runPure($foreign.runST(st));
  };
  exports["pureST"] = pureST;
  exports["modifySTRef"] = $foreign.modifySTRef;
  exports["newSTRef"] = $foreign.newSTRef;
  exports["readSTRef"] = $foreign.readSTRef;
  exports["runST"] = $foreign.runST;
  exports["writeSTRef"] = $foreign.writeSTRef;
})(PS["Control.Monad.ST"] = PS["Control.Monad.ST"] || {});
(function(exports) {
    "use strict";
  var Prelude = PS["Prelude"];
  var Control_Monad_Eff = PS["Control.Monad.Eff"];
  var Control_Monad_Eff_Unsafe = PS["Control.Monad.Eff.Unsafe"];
  var Control_Monad_ST = PS["Control.Monad.ST"];
  var Data_Either = PS["Data.Either"];
  var Data_Identity = PS["Data.Identity"];
  var Data_Bifunctor = PS["Data.Bifunctor"];
  var Partial_Unsafe = PS["Partial.Unsafe"];
  var Data_Functor = PS["Data.Functor"];
  var Control_Semigroupoid = PS["Control.Semigroupoid"];
  var Control_Bind = PS["Control.Bind"];
  var Control_Applicative = PS["Control.Applicative"];
  var Data_Unit = PS["Data.Unit"];        

  /**
 *  | The result of a computation: either `Loop` containing the updated
 *  | accumulator, or `Done` containing the final result of the computation.
 */  
  var Loop = (function () {
      function Loop(value0) {
          this.value0 = value0;
      };
      Loop.create = function (value0) {
          return new Loop(value0);
      };
      return Loop;
  })();

  /**
 *  | The result of a computation: either `Loop` containing the updated
 *  | accumulator, or `Done` containing the final result of the computation.
 */  
  var Done = (function () {
      function Done(value0) {
          this.value0 = value0;
      };
      Done.create = function (value0) {
          return new Done(value0);
      };
      return Done;
  })();

  /**
 *  | This type class captures those monads which support tail recursion in
 *  | constant stack space.
 *  |
 *  | The `tailRecM` function takes a step function, and applies that step
 *  | function recursively until a pure value of type `b` is found.
 *  |
 *  | Instances are provided for standard monad transformers.
 *  |
 *  | For example:
 *  |
 *  | ```purescript
 *  | loopWriter :: Number -> WriterT Sum (Eff (trace :: Trace)) Unit
 *  | loopWriter n = tailRecM go n
 *  |   where
 *  |   go 0 = do
 *  |     lift $ trace "Done!"
 *  |     pure (Done unit)
 *  |   go n = do
 *  |     tell $ Sum n
 *  |     pure (Loop (n - 1))
 *  | ```
 */  
  var MonadRec = function (__superclass_Control$dotMonad$dotMonad_0, tailRecM) {
      this["__superclass_Control.Monad.Monad_0"] = __superclass_Control$dotMonad$dotMonad_0;
      this.tailRecM = tailRecM;
  };

  /**
 *  | This type class captures those monads which support tail recursion in
 *  | constant stack space.
 *  |
 *  | The `tailRecM` function takes a step function, and applies that step
 *  | function recursively until a pure value of type `b` is found.
 *  |
 *  | Instances are provided for standard monad transformers.
 *  |
 *  | For example:
 *  |
 *  | ```purescript
 *  | loopWriter :: Number -> WriterT Sum (Eff (trace :: Trace)) Unit
 *  | loopWriter n = tailRecM go n
 *  |   where
 *  |   go 0 = do
 *  |     lift $ trace "Done!"
 *  |     pure (Done unit)
 *  |   go n = do
 *  |     tell $ Sum n
 *  |     pure (Loop (n - 1))
 *  | ```
 */  
  var tailRecM = function (dict) {
      return dict.tailRecM;
  };

  /**
 *  | Create a tail-recursive function of two arguments which uses constant stack space.
 */  
  var tailRecM2 = function (dictMonadRec) {
      return function (f) {
          return function (a) {
              return function (b) {
                  return tailRecM(dictMonadRec)(function (o) {
                      return f(o.a)(o.b);
                  })({
                      a: a, 
                      b: b
                  });
              };
          };
      };
  };

  /**
 *  | Create a tail-recursive function of three arguments which uses constant stack space.
 */  
  var tailRecM3 = function (dictMonadRec) {
      return function (f) {
          return function (a) {
              return function (b) {
                  return function (c) {
                      return tailRecM(dictMonadRec)(function (o) {
                          return f(o.a)(o.b)(o.c);
                      })({
                          a: a, 
                          b: b, 
                          c: c
                      });
                  };
              };
          };
      };
  };
  var tailRecEff = function (f) {
      return function (a) {
          var fromDone = Partial_Unsafe.unsafePartial(function (dictPartial) {
              return function (v) {
                  var __unused = function (dictPartial1) {
                      return function ($dollar15) {
                          return $dollar15;
                      };
                  };
                  return __unused(dictPartial)((function () {
                      if (v instanceof Done) {
                          return v.value0;
                      };
                      throw new Error("Failed pattern match at Control.Monad.Rec.Class line 130, column 28 - line 130, column 42: " + [ v.constructor.name ]);
                  })());
              };
          });
          var f$prime = function ($47) {
              return Control_Monad_Eff_Unsafe.unsafeCoerceEff(f($47));
          };
          return function __do() {
              var v = f$prime(a)();
              var v1 = {
                  value: v
              };
              (function () {
                  while (!(function __do() {
                      var v2 = v1.value;
                      if (v2 instanceof Loop) {
                          var v3 = f$prime(v2.value0)();
                          v1.value = v3;
                          return false;
                      };
                      if (v2 instanceof Done) {
                          return true;
                      };
                      throw new Error("Failed pattern match at Control.Monad.Rec.Class line 119, column 5 - line 124, column 26: " + [ v2.constructor.name ]);
                  })()) {

                  };
                  return {};
              })();
              return Data_Functor.map(Control_Monad_Eff.functorEff)(fromDone)(Control_Monad_ST.readSTRef(v1))();
          };
      };
  };

  /**
 *  | Create a pure tail-recursive function of one argument
 *  |
 *  | For example:
 *  |
 *  | ```purescript
 *  | pow :: Number -> Number -> Number
 *  | pow n p = tailRec go { accum: 1, power: p }
 *  |   where
 *  |   go :: _ -> Step _ Number
 *  |   go { accum: acc, power: 0 } = Done acc
 *  |   go { accum: acc, power: p } = Loop { accum: acc * n, power: p - 1 }
 *  | ```
 */  
  var tailRec = function (f) {
      return function (a) {
          var go = function (__copy_v) {
              var v = __copy_v;
              tco: while (true) {
                  if (v instanceof Loop) {
                      var __tco_v = f(v.value0);
                      v = __tco_v;
                      continue tco;
                  };
                  if (v instanceof Done) {
                      return v.value0;
                  };
                  throw new Error("Failed pattern match at Control.Monad.Rec.Class line 93, column 1 - line 96, column 18: " + [ v.constructor.name ]);
              };
          };
          return go(f(a));
      };
  };
  var monadRecIdentity = new MonadRec(function () {
      return Data_Identity.monadIdentity;
  }, function (f) {
      var runIdentity = function (v) {
          return v;
      };
      return function ($48) {
          return Data_Identity.Identity(tailRec(function ($49) {
              return runIdentity(f($49));
          })($48));
      };
  });
  var monadRecEither = new MonadRec(function () {
      return Data_Either.monadEither;
  }, function (f) {
      return function (a0) {
          var g = function (v) {
              if (v instanceof Data_Either.Left) {
                  return new Done(new Data_Either.Left(v.value0));
              };
              if (v instanceof Data_Either.Right && v.value0 instanceof Loop) {
                  return new Loop(f(v.value0.value0));
              };
              if (v instanceof Data_Either.Right && v.value0 instanceof Done) {
                  return new Done(new Data_Either.Right(v.value0.value0));
              };
              throw new Error("Failed pattern match at Control.Monad.Rec.Class line 108, column 7 - line 108, column 33: " + [ v.constructor.name ]);
          };
          return tailRec(g)(f(a0));
      };
  });
  var monadRecEff = new MonadRec(function () {
      return Control_Monad_Eff.monadEff;
  }, tailRecEff);
  var functorStep = new Data_Functor.Functor(function (f) {
      return function (v) {
          if (v instanceof Loop) {
              return new Loop(v.value0);
          };
          if (v instanceof Done) {
              return new Done(f(v.value0));
          };
          throw new Error("Failed pattern match at Control.Monad.Rec.Class line 28, column 3 - line 28, column 26: " + [ f.constructor.name, v.constructor.name ]);
      };
  });

  /**
 *  | `forever` runs an action indefinitely, using the `MonadRec` instance to
 *  | ensure constant stack usage.
 *  |
 *  | For example:
 *  |
 *  | ```purescript
 *  | main = forever $ trace "Hello, World!"
 *  | ```
 */  
  var forever = function (dictMonadRec) {
      return function (ma) {
          return tailRecM(dictMonadRec)(function (u) {
              return Data_Functor.voidRight((((dictMonadRec["__superclass_Control.Monad.Monad_0"]())["__superclass_Control.Bind.Bind_1"]())["__superclass_Control.Apply.Apply_0"]())["__superclass_Data.Functor.Functor_0"]())(new Loop(u))(ma);
          })(Data_Unit.unit);
      };
  };
  var bifunctorStep = new Data_Bifunctor.Bifunctor(function (v) {
      return function (v1) {
          return function (v2) {
              if (v2 instanceof Loop) {
                  return new Loop(v(v2.value0));
              };
              if (v2 instanceof Done) {
                  return new Done(v1(v2.value0));
              };
              throw new Error("Failed pattern match at Control.Monad.Rec.Class line 32, column 3 - line 32, column 34: " + [ v.constructor.name, v1.constructor.name, v2.constructor.name ]);
          };
      };
  });
  exports["Loop"] = Loop;
  exports["Done"] = Done;
  exports["MonadRec"] = MonadRec;
  exports["forever"] = forever;
  exports["tailRec"] = tailRec;
  exports["tailRecM"] = tailRecM;
  exports["tailRecM2"] = tailRecM2;
  exports["tailRecM3"] = tailRecM3;
  exports["functorStep"] = functorStep;
  exports["bifunctorStep"] = bifunctorStep;
  exports["monadRecIdentity"] = monadRecIdentity;
  exports["monadRecEff"] = monadRecEff;
  exports["monadRecEither"] = monadRecEither;
})(PS["Control.Monad.Rec.Class"] = PS["Control.Monad.Rec.Class"] || {});
(function(exports) {
  
  /**
 *  | This module defines the `MonadWriter` type class and its instances.
 */  
  "use strict";
  var Prelude = PS["Prelude"];
  var Data_Tuple = PS["Data.Tuple"];
  var Control_Bind = PS["Control.Bind"];
  var Data_Function = PS["Data.Function"];
  var Control_Applicative = PS["Control.Applicative"];        

  /**
 *  | The `MonadTell w` type class represents those monads which support a
 *  | monoidal accumulator of type `w`, were `tell` appends a value to the
 *  | accumulator.
 *  |
 *  | An implementation is provided for `WriterT`, and for other monad
 *  | transformers defined in this library.
 *  |
 *  | Law:
 *  |
 *  | - `do { tell x ; tell y } = tell (x <> y)`
 */  
  var MonadTell = function (__superclass_Control$dotMonad$dotMonad_0, tell) {
      this["__superclass_Control.Monad.Monad_0"] = __superclass_Control$dotMonad$dotMonad_0;
      this.tell = tell;
  };

  /**
 *  | An extension of the `MonadTell` class that introduces some operations on
 *  | the accumulator:
 *  |
 *  | - `listen` modifies the result to include the changes to the accumulator.
 *  | - `pass` applies the returned function to the accumulator.
 *  |
 *  | An implementation is provided for `WriterT`, and for other monad
 *  | transformers defined in this library.
 *  |
 *  | Laws in addition to the `MonadTell` law:
 *  |
 *  | - `do { tell x ; tell y } = tell (x <> y)`
 *  | - `listen (pure a) = pure (Tuple a mempty)`
 *  | - `listen (writer a x) = tell x $> Tuple a x`
 */  
  var MonadWriter = function (__superclass_Control$dotMonad$dotWriter$dotClass$dotMonadTell_0, listen, pass) {
      this["__superclass_Control.Monad.Writer.Class.MonadTell_0"] = __superclass_Control$dotMonad$dotWriter$dotClass$dotMonadTell_0;
      this.listen = listen;
      this.pass = pass;
  };

  /**
 *  | The `MonadTell w` type class represents those monads which support a
 *  | monoidal accumulator of type `w`, were `tell` appends a value to the
 *  | accumulator.
 *  |
 *  | An implementation is provided for `WriterT`, and for other monad
 *  | transformers defined in this library.
 *  |
 *  | Law:
 *  |
 *  | - `do { tell x ; tell y } = tell (x <> y)`
 */  
  var tell = function (dict) {
      return dict.tell;
  };

  /**
 *  | An extension of the `MonadTell` class that introduces some operations on
 *  | the accumulator:
 *  |
 *  | - `listen` modifies the result to include the changes to the accumulator.
 *  | - `pass` applies the returned function to the accumulator.
 *  |
 *  | An implementation is provided for `WriterT`, and for other monad
 *  | transformers defined in this library.
 *  |
 *  | Laws in addition to the `MonadTell` law:
 *  |
 *  | - `do { tell x ; tell y } = tell (x <> y)`
 *  | - `listen (pure a) = pure (Tuple a mempty)`
 *  | - `listen (writer a x) = tell x $> Tuple a x`
 */  
  var pass = function (dict) {
      return dict.pass;
  };

  /**
 *  | An extension of the `MonadTell` class that introduces some operations on
 *  | the accumulator:
 *  |
 *  | - `listen` modifies the result to include the changes to the accumulator.
 *  | - `pass` applies the returned function to the accumulator.
 *  |
 *  | An implementation is provided for `WriterT`, and for other monad
 *  | transformers defined in this library.
 *  |
 *  | Laws in addition to the `MonadTell` law:
 *  |
 *  | - `do { tell x ; tell y } = tell (x <> y)`
 *  | - `listen (pure a) = pure (Tuple a mempty)`
 *  | - `listen (writer a x) = tell x $> Tuple a x`
 */  
  var listen = function (dict) {
      return dict.listen;
  };

  /**
 *  | Projects a value from modifications made to the accumulator during an
 *  | action.
 */  
  var listens = function (dictMonadWriter) {
      return function (f) {
          return function (m) {
              return Control_Bind.bind(((dictMonadWriter["__superclass_Control.Monad.Writer.Class.MonadTell_0"]())["__superclass_Control.Monad.Monad_0"]())["__superclass_Control.Bind.Bind_1"]())(listen(dictMonadWriter)(m))(function (v) {
                  return Control_Applicative.pure(((dictMonadWriter["__superclass_Control.Monad.Writer.Class.MonadTell_0"]())["__superclass_Control.Monad.Monad_0"]())["__superclass_Control.Applicative.Applicative_0"]())(new Data_Tuple.Tuple(v.value0, f(v.value1)));
              });
          };
      };
  };

  /**
 *  | Modify the final accumulator value by applying a function.
 */  
  var censor = function (dictMonadWriter) {
      return function (f) {
          return function (m) {
              return pass(dictMonadWriter)(Control_Bind.bind(((dictMonadWriter["__superclass_Control.Monad.Writer.Class.MonadTell_0"]())["__superclass_Control.Monad.Monad_0"]())["__superclass_Control.Bind.Bind_1"]())(m)(function (v) {
                  return Control_Applicative.pure(((dictMonadWriter["__superclass_Control.Monad.Writer.Class.MonadTell_0"]())["__superclass_Control.Monad.Monad_0"]())["__superclass_Control.Applicative.Applicative_0"]())(new Data_Tuple.Tuple(v, f));
              }));
          };
      };
  };
  exports["MonadTell"] = MonadTell;
  exports["MonadWriter"] = MonadWriter;
  exports["censor"] = censor;
  exports["listen"] = listen;
  exports["listens"] = listens;
  exports["pass"] = pass;
  exports["tell"] = tell;
})(PS["Control.Monad.Writer.Class"] = PS["Control.Monad.Writer.Class"] || {});
(function(exports) {
    "use strict";
  var Control_Alt = PS["Control.Alt"];
  var Control_Alternative = PS["Control.Alternative"];
  var Control_Applicative = PS["Control.Applicative"];
  var Control_Apply = PS["Control.Apply"];
  var Control_Bind = PS["Control.Bind"];
  var Control_Monad = PS["Control.Monad"];
  var Control_MonadZero = PS["Control.MonadZero"];
  var Control_Plus = PS["Control.Plus"];
  var Data_Functor = PS["Data.Functor"];        

  /**
 *  | The `MonadPlus` type class has no members of its own but extends
 *  | `MonadZero` with an additional law:
 *  |
 *  | - Distributivity: `(x <|> y) >>= f == (x >>= f) <|> (y >>= f)`
 */  
  var MonadPlus = function (__superclass_Control$dotMonadZero$dotMonadZero_0) {
      this["__superclass_Control.MonadZero.MonadZero_0"] = __superclass_Control$dotMonadZero$dotMonadZero_0;
  };
  var monadPlusArray = new MonadPlus(function () {
      return Control_MonadZero.monadZeroArray;
  });
  exports["MonadPlus"] = MonadPlus;
  exports["monadPlusArray"] = monadPlusArray;
})(PS["Control.MonadPlus"] = PS["Control.MonadPlus"] || {});
(function(exports) {
  
  /**
 *  | This module defines the _exception monad transformer_ `ExceptT`.
 */  
  "use strict";
  var Prelude = PS["Prelude"];
  var Control_Alt = PS["Control.Alt"];
  var Control_Alternative = PS["Control.Alternative"];
  var Control_Monad_Cont_Class = PS["Control.Monad.Cont.Class"];
  var Control_Monad_Eff_Class = PS["Control.Monad.Eff.Class"];
  var Control_Monad_Error_Class = PS["Control.Monad.Error.Class"];
  var Control_Monad_Reader_Class = PS["Control.Monad.Reader.Class"];
  var Control_Monad_Rec_Class = PS["Control.Monad.Rec.Class"];
  var Control_Monad_State_Class = PS["Control.Monad.State.Class"];
  var Control_Monad_Trans_Class = PS["Control.Monad.Trans.Class"];
  var Control_Monad_Writer_Class = PS["Control.Monad.Writer.Class"];
  var Control_MonadPlus = PS["Control.MonadPlus"];
  var Control_MonadZero = PS["Control.MonadZero"];
  var Control_Plus = PS["Control.Plus"];
  var Data_Either = PS["Data.Either"];
  var Data_Monoid = PS["Data.Monoid"];
  var Data_Newtype = PS["Data.Newtype"];
  var Data_Tuple = PS["Data.Tuple"];
  var Data_Functor = PS["Data.Functor"];
  var Control_Apply = PS["Control.Apply"];
  var Control_Monad = PS["Control.Monad"];
  var Control_Applicative = PS["Control.Applicative"];
  var Control_Semigroupoid = PS["Control.Semigroupoid"];
  var Control_Bind = PS["Control.Bind"];
  var Data_Semigroup = PS["Data.Semigroup"];
  var Data_Function = PS["Data.Function"];
  var Control_Category = PS["Control.Category"];        

  /**
 *  | A monad transformer which adds exceptions to other monads, in the same way
 *  | as `Except`. As before, `e` is the type of exceptions, and `a` is the type
 *  | of successful results. The new type parameter `m` is the inner monad that
 *  | computations run in.
 */  
  var ExceptT = function (x) {
      return x;
  };

  /**
 *  | Transform any exceptions thrown by an `ExceptT` computation using the given function.
 */  
  var withExceptT = function (dictFunctor) {
      return function (f) {
          return function (v) {
              var mapLeft = function (v1) {
                  return function (v2) {
                      if (v2 instanceof Data_Either.Right) {
                          return new Data_Either.Right(v2.value0);
                      };
                      if (v2 instanceof Data_Either.Left) {
                          return new Data_Either.Left(v1(v2.value0));
                      };
                      throw new Error("Failed pattern match at Control.Monad.Except.Trans line 44, column 3 - line 44, column 32: " + [ v1.constructor.name, v2.constructor.name ]);
                  };
              };
              return ExceptT(Data_Functor.map(dictFunctor)(mapLeft(f))(v));
          };
      };
  };

  /**
 *  | The inverse of `ExceptT`. Run a computation in the `ExceptT` monad.
 */  
  var runExceptT = function (v) {
      return v;
  };
  var newtypeExceptT = new Data_Newtype.Newtype(function (n) {
      return n;
  }, ExceptT);
  var monadTransExceptT = new Control_Monad_Trans_Class.MonadTrans(function (dictMonad) {
      return function (m) {
          return Control_Bind.bind(dictMonad["__superclass_Control.Bind.Bind_1"]())(m)(function (v) {
              return Control_Applicative.pure(dictMonad["__superclass_Control.Applicative.Applicative_0"]())(new Data_Either.Right(v));
          });
      };
  });

  /**
 *  | Transform the unwrapped computation using the given function.
 */  
  var mapExceptT = function (f) {
      return function (v) {
          return f(v);
      };
  };
  var functorExceptT = function (dictFunctor) {
      return new Data_Functor.Functor(function (f) {
          return mapExceptT(Data_Functor.map(dictFunctor)(Data_Functor.map(Data_Either.functorEither)(f)));
      });
  };

  /**
 *  | Construct a computation in the `ExceptT` transformer from an `Either` value.
 */  
  var except = function (dictApplicative) {
      return function ($87) {
          return ExceptT(Control_Applicative.pure(dictApplicative)($87));
      };
  };
  var monadExceptT = function (dictMonad) {
      return new Control_Monad.Monad(function () {
          return applicativeExceptT(dictMonad);
      }, function () {
          return bindExceptT(dictMonad);
      });
  };
  var bindExceptT = function (dictMonad) {
      return new Control_Bind.Bind(function () {
          return applyExceptT(dictMonad);
      }, function (v) {
          return function (k) {
              return Control_Bind.bind(dictMonad["__superclass_Control.Bind.Bind_1"]())(v)(Data_Either.either(function ($88) {
                  return Control_Applicative.pure(dictMonad["__superclass_Control.Applicative.Applicative_0"]())(Data_Either.Left.create($88));
              })(function (a) {
                  var $56 = k(a);
                  return $56;
              }));
          };
      });
  };
  var applyExceptT = function (dictMonad) {
      return new Control_Apply.Apply(function () {
          return functorExceptT(((dictMonad["__superclass_Control.Bind.Bind_1"]())["__superclass_Control.Apply.Apply_0"]())["__superclass_Data.Functor.Functor_0"]());
      }, Control_Monad.ap(monadExceptT(dictMonad)));
  };
  var applicativeExceptT = function (dictMonad) {
      return new Control_Applicative.Applicative(function () {
          return applyExceptT(dictMonad);
      }, function ($89) {
          return ExceptT(Control_Applicative.pure(dictMonad["__superclass_Control.Applicative.Applicative_0"]())(Data_Either.Right.create($89)));
      });
  };
  var monadAskExceptT = function (dictMonadAsk) {
      return new Control_Monad_Reader_Class.MonadAsk(function () {
          return monadExceptT(dictMonadAsk["__superclass_Control.Monad.Monad_0"]());
      }, Control_Monad_Trans_Class.lift(monadTransExceptT)(dictMonadAsk["__superclass_Control.Monad.Monad_0"]())(Control_Monad_Reader_Class.ask(dictMonadAsk)));
  };
  var monadReaderExceptT = function (dictMonadReader) {
      return new Control_Monad_Reader_Class.MonadReader(function () {
          return monadAskExceptT(dictMonadReader["__superclass_Control.Monad.Reader.Class.MonadAsk_0"]());
      }, function (f) {
          return mapExceptT(Control_Monad_Reader_Class.local(dictMonadReader)(f));
      });
  };
  var monadContExceptT = function (dictMonadCont) {
      return new Control_Monad_Cont_Class.MonadCont(function () {
          return monadExceptT(dictMonadCont["__superclass_Control.Monad.Monad_0"]());
      }, function (f) {
          return ExceptT(Control_Monad_Cont_Class.callCC(dictMonadCont)(function (c) {
              var $57 = f(function (a) {
                  return ExceptT(c(new Data_Either.Right(a)));
              });
              return $57;
          }));
      });
  };
  var monadEffExceptT = function (dictMonadEff) {
      return new Control_Monad_Eff_Class.MonadEff(function () {
          return monadExceptT(dictMonadEff["__superclass_Control.Monad.Monad_0"]());
      }, function ($90) {
          return Control_Monad_Trans_Class.lift(monadTransExceptT)(dictMonadEff["__superclass_Control.Monad.Monad_0"]())(Control_Monad_Eff_Class.liftEff(dictMonadEff)($90));
      });
  };
  var monadErrorExceptT = function (dictMonad) {
      return new Control_Monad_Error_Class.MonadError(function () {
          return monadExceptT(dictMonad);
      }, function (v) {
          return function (k) {
              return Control_Bind.bind(dictMonad["__superclass_Control.Bind.Bind_1"]())(v)(Data_Either.either(function (a) {
                  var $60 = k(a);
                  return $60;
              })(function ($91) {
                  return Control_Applicative.pure(dictMonad["__superclass_Control.Applicative.Applicative_0"]())(Data_Either.Right.create($91));
              }));
          };
      }, function ($92) {
          return ExceptT(Control_Applicative.pure(dictMonad["__superclass_Control.Applicative.Applicative_0"]())(Data_Either.Left.create($92)));
      });
  };
  var monadRecExceptT = function (dictMonadRec) {
      return new Control_Monad_Rec_Class.MonadRec(function () {
          return monadExceptT(dictMonadRec["__superclass_Control.Monad.Monad_0"]());
      }, function (f) {
          return function ($93) {
              return ExceptT(Control_Monad_Rec_Class.tailRecM(dictMonadRec)(function (a) {
                  return Control_Bind.bind((dictMonadRec["__superclass_Control.Monad.Monad_0"]())["__superclass_Control.Bind.Bind_1"]())((function () {
                      var $61 = f(a);
                      return $61;
                  })())(function (m$prime) {
                      return Control_Applicative.pure((dictMonadRec["__superclass_Control.Monad.Monad_0"]())["__superclass_Control.Applicative.Applicative_0"]())((function () {
                          if (m$prime instanceof Data_Either.Left) {
                              return new Control_Monad_Rec_Class.Done(new Data_Either.Left(m$prime.value0));
                          };
                          if (m$prime instanceof Data_Either.Right && m$prime.value0 instanceof Control_Monad_Rec_Class.Loop) {
                              return new Control_Monad_Rec_Class.Loop(m$prime.value0.value0);
                          };
                          if (m$prime instanceof Data_Either.Right && m$prime.value0 instanceof Control_Monad_Rec_Class.Done) {
                              return new Control_Monad_Rec_Class.Done(new Data_Either.Right(m$prime.value0.value0));
                          };
                          throw new Error("Failed pattern match at Control.Monad.Except.Trans line 76, column 14 - line 79, column 43: " + [ m$prime.constructor.name ]);
                      })());
                  });
              })($93));
          };
      });
  };
  var monadStateExceptT = function (dictMonadState) {
      return new Control_Monad_State_Class.MonadState(function () {
          return monadExceptT(dictMonadState["__superclass_Control.Monad.Monad_0"]());
      }, function (f) {
          return Control_Monad_Trans_Class.lift(monadTransExceptT)(dictMonadState["__superclass_Control.Monad.Monad_0"]())(Control_Monad_State_Class.state(dictMonadState)(f));
      });
  };
  var monadTellExceptT = function (dictMonadTell) {
      return new Control_Monad_Writer_Class.MonadTell(function () {
          return monadExceptT(dictMonadTell["__superclass_Control.Monad.Monad_0"]());
      }, function ($94) {
          return Control_Monad_Trans_Class.lift(monadTransExceptT)(dictMonadTell["__superclass_Control.Monad.Monad_0"]())(Control_Monad_Writer_Class.tell(dictMonadTell)($94));
      });
  };
  var monadWriterExceptT = function (dictMonadWriter) {
      return new Control_Monad_Writer_Class.MonadWriter(function () {
          return monadTellExceptT(dictMonadWriter["__superclass_Control.Monad.Writer.Class.MonadTell_0"]());
      }, mapExceptT(function (m) {
          return Control_Bind.bind(((dictMonadWriter["__superclass_Control.Monad.Writer.Class.MonadTell_0"]())["__superclass_Control.Monad.Monad_0"]())["__superclass_Control.Bind.Bind_1"]())(Control_Monad_Writer_Class.listen(dictMonadWriter)(m))(function (v) {
              return Control_Applicative.pure(((dictMonadWriter["__superclass_Control.Monad.Writer.Class.MonadTell_0"]())["__superclass_Control.Monad.Monad_0"]())["__superclass_Control.Applicative.Applicative_0"]())(Data_Functor.map(Data_Either.functorEither)(function (r) {
                  return new Data_Tuple.Tuple(r, v.value1);
              })(v.value0));
          });
      }), mapExceptT(function (m) {
          return Control_Monad_Writer_Class.pass(dictMonadWriter)(Control_Bind.bind(((dictMonadWriter["__superclass_Control.Monad.Writer.Class.MonadTell_0"]())["__superclass_Control.Monad.Monad_0"]())["__superclass_Control.Bind.Bind_1"]())(m)(function (v) {
              return Control_Applicative.pure(((dictMonadWriter["__superclass_Control.Monad.Writer.Class.MonadTell_0"]())["__superclass_Control.Monad.Monad_0"]())["__superclass_Control.Applicative.Applicative_0"]())((function () {
                  if (v instanceof Data_Either.Left) {
                      return new Data_Tuple.Tuple(new Data_Either.Left(v.value0), Control_Category.id(Control_Category.categoryFn));
                  };
                  if (v instanceof Data_Either.Right) {
                      return new Data_Tuple.Tuple(new Data_Either.Right(v.value0.value0), v.value0.value1);
                  };
                  throw new Error("Failed pattern match at Control.Monad.Except.Trans line 136, column 10 - line 138, column 44: " + [ v.constructor.name ]);
              })());
          }));
      }));
  };
  var altExceptT = function (dictSemigroup) {
      return function (dictMonad) {
          return new Control_Alt.Alt(function () {
              return functorExceptT(((dictMonad["__superclass_Control.Bind.Bind_1"]())["__superclass_Control.Apply.Apply_0"]())["__superclass_Data.Functor.Functor_0"]());
          }, function (v) {
              return function (v1) {
                  return Control_Bind.bind(dictMonad["__superclass_Control.Bind.Bind_1"]())(v)(function (v2) {
                      if (v2 instanceof Data_Either.Right) {
                          return Control_Applicative.pure(dictMonad["__superclass_Control.Applicative.Applicative_0"]())(new Data_Either.Right(v2.value0));
                      };
                      if (v2 instanceof Data_Either.Left) {
                          return Control_Bind.bind(dictMonad["__superclass_Control.Bind.Bind_1"]())(v1)(function (v3) {
                              if (v3 instanceof Data_Either.Right) {
                                  return Control_Applicative.pure(dictMonad["__superclass_Control.Applicative.Applicative_0"]())(new Data_Either.Right(v3.value0));
                              };
                              if (v3 instanceof Data_Either.Left) {
                                  return Control_Applicative.pure(dictMonad["__superclass_Control.Applicative.Applicative_0"]())(new Data_Either.Left(Data_Semigroup.append(dictSemigroup)(v2.value0)(v3.value0)));
                              };
                              throw new Error("Failed pattern match at Control.Monad.Except.Trans line 88, column 9 - line 90, column 49: " + [ v3.constructor.name ]);
                          });
                      };
                      throw new Error("Failed pattern match at Control.Monad.Except.Trans line 84, column 5 - line 90, column 49: " + [ v2.constructor.name ]);
                  });
              };
          });
      };
  };
  var plusExceptT = function (dictMonoid) {
      return function (dictMonad) {
          return new Control_Plus.Plus(function () {
              return altExceptT(dictMonoid["__superclass_Data.Semigroup.Semigroup_0"]())(dictMonad);
          }, Control_Monad_Error_Class.throwError(monadErrorExceptT(dictMonad))(Data_Monoid.mempty(dictMonoid)));
      };
  };
  var alternativeExceptT = function (dictMonoid) {
      return function (dictMonad) {
          return new Control_Alternative.Alternative(function () {
              return applicativeExceptT(dictMonad);
          }, function () {
              return plusExceptT(dictMonoid)(dictMonad);
          });
      };
  };
  var monadZeroExceptT = function (dictMonoid) {
      return function (dictMonad) {
          return new Control_MonadZero.MonadZero(function () {
              return alternativeExceptT(dictMonoid)(dictMonad);
          }, function () {
              return monadExceptT(dictMonad);
          });
      };
  };
  var monadPlusExceptT = function (dictMonoid) {
      return function (dictMonad) {
          return new Control_MonadPlus.MonadPlus(function () {
              return monadZeroExceptT(dictMonoid)(dictMonad);
          });
      };
  };
  exports["ExceptT"] = ExceptT;
  exports["except"] = except;
  exports["mapExceptT"] = mapExceptT;
  exports["runExceptT"] = runExceptT;
  exports["withExceptT"] = withExceptT;
  exports["newtypeExceptT"] = newtypeExceptT;
  exports["functorExceptT"] = functorExceptT;
  exports["applyExceptT"] = applyExceptT;
  exports["applicativeExceptT"] = applicativeExceptT;
  exports["bindExceptT"] = bindExceptT;
  exports["monadExceptT"] = monadExceptT;
  exports["monadRecExceptT"] = monadRecExceptT;
  exports["altExceptT"] = altExceptT;
  exports["plusExceptT"] = plusExceptT;
  exports["alternativeExceptT"] = alternativeExceptT;
  exports["monadPlusExceptT"] = monadPlusExceptT;
  exports["monadZeroExceptT"] = monadZeroExceptT;
  exports["monadTransExceptT"] = monadTransExceptT;
  exports["monadEffExceptT"] = monadEffExceptT;
  exports["monadContExceptT"] = monadContExceptT;
  exports["monadErrorExceptT"] = monadErrorExceptT;
  exports["monadAskExceptT"] = monadAskExceptT;
  exports["monadReaderExceptT"] = monadReaderExceptT;
  exports["monadStateExceptT"] = monadStateExceptT;
  exports["monadTellExceptT"] = monadTellExceptT;
  exports["monadWriterExceptT"] = monadWriterExceptT;
})(PS["Control.Monad.Except.Trans"] = PS["Control.Monad.Except.Trans"] || {});
(function(exports) {
    "use strict";
  var Prelude = PS["Prelude"];
  var Control_Monad_Error_Class = PS["Control.Monad.Error.Class"];
  var Control_Monad_Except_Trans = PS["Control.Monad.Except.Trans"];
  var Data_Either = PS["Data.Either"];
  var Data_Identity = PS["Data.Identity"];
  var Data_Newtype = PS["Data.Newtype"];
  var Control_Semigroupoid = PS["Control.Semigroupoid"];        

  /**
 *  | Transform any exceptions thrown by an `Except` computation using the given function.
 */  
  var withExcept = Control_Monad_Except_Trans.withExceptT(Data_Identity.functorIdentity);

  /**
 *  | Run a computation in the `Except` monad. The inverse of `except`.
 */  
  var runExcept = function ($0) {
      return Data_Newtype.unwrap(Data_Identity.newtypeIdentity)(Control_Monad_Except_Trans.runExceptT($0));
  };

  /**
 *  | Transform the unwrapped computation using the given function.
 */  
  var mapExcept = function (f) {
      return Control_Monad_Except_Trans.mapExceptT(function ($1) {
          return Data_Identity.Identity(f(Data_Newtype.unwrap(Data_Identity.newtypeIdentity)($1)));
      });
  };
  exports["mapExcept"] = mapExcept;
  exports["runExcept"] = runExcept;
  exports["withExcept"] = withExcept;
})(PS["Control.Monad.Except"] = PS["Control.Monad.Except"] || {});
(function(exports) {
    "use strict";

  // module Data.Generic

  exports.zipAll = function (f) {
    return function (xs) {
      return function (ys) {
        var l = xs.length < ys.length ? xs.length : ys.length;
        for (var i = 0; i < l; i++) {
          if (!f(xs[i])(ys[i])) {
            return false;
          }
        }
        return true;
      };
    };
  };

  exports.zipCompare = function (f) {
    return function (xs) {
      return function (ys) {
        var i = 0;
        var xlen = xs.length;
        var ylen = ys.length;
        while (i < xlen && i < ylen) {
          var o = f(xs[i])(ys[i]);
          if (o !== 0) {
            return o;
          }
          i++;
        }
        if (xlen === ylen) {
          return 0;
        } else if (xlen > ylen) {
          return -1;
        } else {
          return 1;
        }
      };
    };
  };
})(PS["Data.Generic"] = PS["Data.Generic"] || {});
(function(exports) {
    "use strict";

  //------------------------------------------------------------------------------
  // Array creation --------------------------------------------------------------
  //------------------------------------------------------------------------------

  exports.range = function (start) {
    return function (end) {
      var step = start > end ? -1 : 1;
      var result = [];
      for (var i = start, n = 0; i !== end; i += step) {
        result[n++] = i;
      }
      result[n] = i;
      return result;
    };
  };

  exports.replicate = function (count) {
    return function (value) {
      var result = [];
      var n = 0;
      for (var i = 0; i < count; i++) {
        result[n++] = value;
      }
      return result;
    };
  };

  exports.fromFoldableImpl = (function () {
    // jshint maxparams: 2
    function Cons(head, tail) {
      this.head = head;
      this.tail = tail;
    }
    var emptyList = {};

    function curryCons(head) {
      return function (tail) {
        return new Cons(head, tail);
      };
    }

    function listToArray(list) {
      var result = [];
      var count = 0;
      while (list !== emptyList) {
        result[count++] = list.head;
        list = list.tail;
      }
      return result;
    }

    return function (foldr) {
      return function (xs) {
        return listToArray(foldr(curryCons)(emptyList)(xs));
      };
    };
  })();

  //------------------------------------------------------------------------------
  // Array size ------------------------------------------------------------------
  //------------------------------------------------------------------------------

  exports.length = function (xs) {
    return xs.length;
  };

  //------------------------------------------------------------------------------
  // Extending arrays ------------------------------------------------------------
  //------------------------------------------------------------------------------

  exports.cons = function (e) {
    return function (l) {
      return [e].concat(l);
    };
  };

  exports.snoc = function (l) {
    return function (e) {
      var l1 = l.slice();
      l1.push(e);
      return l1;
    };
  };

  //------------------------------------------------------------------------------
  // Non-indexed reads -----------------------------------------------------------
  //------------------------------------------------------------------------------

  exports["uncons'"] = function (empty) {
    return function (next) {
      return function (xs) {
        return xs.length === 0 ? empty({}) : next(xs[0])(xs.slice(1));
      };
    };
  };

  //------------------------------------------------------------------------------
  // Indexed operations ----------------------------------------------------------
  //------------------------------------------------------------------------------

  exports.indexImpl = function (just) {
    return function (nothing) {
      return function (xs) {
        return function (i) {
          return i < 0 || i >= xs.length ? nothing :  just(xs[i]);
        };
      };
    };
  };

  exports.findIndexImpl = function (just) {
    return function (nothing) {
      return function (f) {
        return function (xs) {
          for (var i = 0, l = xs.length; i < l; i++) {
            if (f(xs[i])) return just(i);
          }
          return nothing;
        };
      };
    };
  };

  exports.findLastIndexImpl = function (just) {
    return function (nothing) {
      return function (f) {
        return function (xs) {
          for (var i = xs.length - 1; i >= 0; i--) {
            if (f(xs[i])) return just(i);
          }
          return nothing;
        };
      };
    };
  };

  exports._insertAt = function (just) {
    return function (nothing) {
      return function (i) {
        return function (a) {
          return function (l) {
            if (i < 0 || i > l.length) return nothing;
            var l1 = l.slice();
            l1.splice(i, 0, a);
            return just(l1);
          };
        };
      };
    };
  };

  exports._deleteAt = function (just) {
    return function (nothing) {
      return function (i) {
        return function (l) {
          if (i < 0 || i >= l.length) return nothing;
          var l1 = l.slice();
          l1.splice(i, 1);
          return just(l1);
        };
      };
    };
  };

  exports._updateAt = function (just) {
    return function (nothing) {
      return function (i) {
        return function (a) {
          return function (l) {
            if (i < 0 || i >= l.length) return nothing;
            var l1 = l.slice();
            l1[i] = a;
            return just(l1);
          };
        };
      };
    };
  };

  //------------------------------------------------------------------------------
  // Transformations -------------------------------------------------------------
  //------------------------------------------------------------------------------

  exports.reverse = function (l) {
    return l.slice().reverse();
  };

  exports.concat = function (xss) {
    var result = [];
    for (var i = 0, l = xss.length; i < l; i++) {
      var xs = xss[i];
      for (var j = 0, m = xs.length; j < m; j++) {
        result.push(xs[j]);
      }
    }
    return result;
  };

  exports.filter = function (f) {
    return function (xs) {
      return xs.filter(f);
    };
  };

  exports.partition = function (f) {
    return function (xs) {
      var yes = [];
      var no  = [];
      for (var i = 0; i < xs.length; i++) {
        var x = xs[i];
        if (f(x))
          yes.push(x);
        else
          no.push(x);
      }
      return { yes: yes, no: no };
    };
  };

  //------------------------------------------------------------------------------
  // Sorting ---------------------------------------------------------------------
  //------------------------------------------------------------------------------

  exports.sortImpl = function (f) {
    return function (l) {
      // jshint maxparams: 2
      return l.slice().sort(function (x, y) {
        return f(x)(y);
      });
    };
  };

  //------------------------------------------------------------------------------
  // Subarrays -------------------------------------------------------------------
  //------------------------------------------------------------------------------

  exports.slice = function (s) {
    return function (e) {
      return function (l) {
        return l.slice(s, e);
      };
    };
  };

  exports.take = function (n) {
    return function (l) {
      return n < 1 ? [] : l.slice(0, n);
    };
  };

  exports.drop = function (n) {
    return function (l) {
      return n < 1 ? l : l.slice(n);
    };
  };

  //------------------------------------------------------------------------------
  // Zipping ---------------------------------------------------------------------
  //------------------------------------------------------------------------------

  exports.zipWith = function (f) {
    return function (xs) {
      return function (ys) {
        var l = xs.length < ys.length ? xs.length : ys.length;
        var result = new Array(l);
        for (var i = 0; i < l; i++) {
          result[i] = f(xs[i])(ys[i]);
        }
        return result;
      };
    };
  };

  //------------------------------------------------------------------------------
  // Partial ---------------------------------------------------------------------
  //------------------------------------------------------------------------------

  exports.unsafeIndexImpl = function (xs) {
    return function (n) {
      return xs[n];
    };
  };
})(PS["Data.Array"] = PS["Data.Array"] || {});
(function(exports) {
  
  /**
 *  | This module defines a generic non-empty data structure, which adds an
 *  | additional element to any container type.
 */  
  "use strict";
  var Prelude = PS["Prelude"];
  var Control_Alt = PS["Control.Alt"];
  var Control_Alternative = PS["Control.Alternative"];
  var Control_Plus = PS["Control.Plus"];
  var Data_Foldable = PS["Data.Foldable"];
  var Data_Traversable = PS["Data.Traversable"];
  var Data_Show = PS["Data.Show"];
  var Data_Semigroup = PS["Data.Semigroup"];
  var Data_Eq = PS["Data.Eq"];
  var Data_HeytingAlgebra = PS["Data.HeytingAlgebra"];
  var Data_Ord = PS["Data.Ord"];
  var Data_Ordering = PS["Data.Ordering"];
  var Data_Functor = PS["Data.Functor"];
  var Control_Apply = PS["Control.Apply"];
  var Control_Applicative = PS["Control.Applicative"];
  var Control_Category = PS["Control.Category"];        

  /**
 *  | A non-empty container of elements of type a.
 *  |
 *  | For example:
 *  |
 *  | ```purescript
 *  | nonEmptyList :: NonEmpty List Int
 *  | nonEmptyList = 0 :| empty
 *  | ```
 */  
  var NonEmpty = (function () {
      function NonEmpty(value0, value1) {
          this.value0 = value0;
          this.value1 = value1;
      };
      NonEmpty.create = function (value0) {
          return function (value1) {
              return new NonEmpty(value0, value1);
          };
      };
      return NonEmpty;
  })();

  /**
 *  | Get everything but the 'first' element of a non-empty container.
 */  
  var tail = function (v) {
      return v.value1;
  };

  /**
 *  | Create a non-empty structure with a single value.
 */  
  var singleton = function (dictPlus) {
      return function (a) {
          return new NonEmpty(a, Control_Plus.empty(dictPlus));
      };
  };
  var showNonEmpty = function (dictShow) {
      return function (dictShow1) {
          return new Data_Show.Show(function (v) {
              return "(NonEmpty " + (Data_Show.show(dictShow)(v.value0) + (" " + (Data_Show.show(dictShow1)(v.value1) + ")")));
          });
      };
  };
  var oneOf = function (dictAlternative) {
      return function (v) {
          return Control_Alt.alt((dictAlternative["__superclass_Control.Plus.Plus_1"]())["__superclass_Control.Alt.Alt_0"]())(Control_Applicative.pure(dictAlternative["__superclass_Control.Applicative.Applicative_0"]())(v.value0))(v.value1);
      };
  };

  /**
 *  | Get the 'first' element of a non-empty container.
 */  
  var head = function (v) {
      return v.value0;
  };
  var functorNonEmpty = function (dictFunctor) {
      return new Data_Functor.Functor(function (f) {
          return function (v) {
              return new NonEmpty(f(v.value0), Data_Functor.map(dictFunctor)(f)(v.value1));
          };
      });
  };
  var fromNonEmpty = function (f) {
      return function (v) {
          return f(v.value0)(v.value1);
      };
  };

  /**
 *  | Fold a non-empty structure, collecting results using a binary operation.
 */  
  var foldl1 = function (dictFoldable) {
      return function (f) {
          return function (v) {
              return Data_Foldable.foldl(dictFoldable)(f)(v.value0)(v.value1);
          };
      };
  };
  var foldableNonEmpty = function (dictFoldable) {
      return new Data_Foldable.Foldable(function (dictMonoid) {
          return function (f) {
              return function (v) {
                  return Data_Semigroup.append(dictMonoid["__superclass_Data.Semigroup.Semigroup_0"]())(f(v.value0))(Data_Foldable.foldMap(dictFoldable)(dictMonoid)(f)(v.value1));
              };
          };
      }, function (f) {
          return function (b) {
              return function (v) {
                  return Data_Foldable.foldl(dictFoldable)(f)(f(b)(v.value0))(v.value1);
              };
          };
      }, function (f) {
          return function (b) {
              return function (v) {
                  return f(v.value0)(Data_Foldable.foldr(dictFoldable)(f)(b)(v.value1));
              };
          };
      });
  };
  var traversableNonEmpty = function (dictTraversable) {
      return new Data_Traversable.Traversable(function () {
          return foldableNonEmpty(dictTraversable["__superclass_Data.Foldable.Foldable_1"]());
      }, function () {
          return functorNonEmpty(dictTraversable["__superclass_Data.Functor.Functor_0"]());
      }, function (dictApplicative) {
          return function (v) {
              return Control_Apply.apply(dictApplicative["__superclass_Control.Apply.Apply_0"]())(Data_Functor.map((dictApplicative["__superclass_Control.Apply.Apply_0"]())["__superclass_Data.Functor.Functor_0"]())(NonEmpty.create)(v.value0))(Data_Traversable.sequence(dictTraversable)(dictApplicative)(v.value1));
          };
      }, function (dictApplicative) {
          return function (f) {
              return function (v) {
                  return Control_Apply.apply(dictApplicative["__superclass_Control.Apply.Apply_0"]())(Data_Functor.map((dictApplicative["__superclass_Control.Apply.Apply_0"]())["__superclass_Data.Functor.Functor_0"]())(NonEmpty.create)(f(v.value0)))(Data_Traversable.traverse(dictTraversable)(dictApplicative)(f)(v.value1));
              };
          };
      });
  };

  /**
 *  | Fold a non-empty structure, collecting results in a `Semigroup`.
 */  
  var foldMap1 = function (dictSemigroup) {
      return function (dictFoldable) {
          return function (f) {
              return function (v) {
                  return Data_Foldable.foldl(dictFoldable)(function (s) {
                      return function (a1) {
                          return Data_Semigroup.append(dictSemigroup)(s)(f(a1));
                      };
                  })(f(v.value0))(v.value1);
              };
          };
      };
  };

  /**
 *  | Fold a non-empty structure.
 */  
  var fold1 = function (dictSemigroup) {
      return function (dictFoldable) {
          return foldMap1(dictSemigroup)(dictFoldable)(Control_Category.id(Control_Category.categoryFn));
      };
  };
  var eqNonEmpty = function (dictEq) {
      return function (dictEq1) {
          return new Data_Eq.Eq(function (x) {
              return function (y) {
                  return Data_Eq.eq(dictEq)(x.value0)(y.value0) && Data_Eq.eq(dictEq1)(x.value1)(y.value1);
              };
          });
      };
  };
  var ordNonEmpty = function (dictOrd) {
      return function (dictOrd1) {
          return new Data_Ord.Ord(function () {
              return eqNonEmpty(dictOrd["__superclass_Data.Eq.Eq_0"]())(dictOrd1["__superclass_Data.Eq.Eq_0"]());
          }, function (x) {
              return function (y) {
                  var $101 = Data_Ord.compare(dictOrd)(x.value0)(y.value0);
                  if ($101 instanceof Data_Ordering.LT) {
                      return Data_Ordering.LT.value;
                  };
                  if ($101 instanceof Data_Ordering.GT) {
                      return Data_Ordering.GT.value;
                  };
                  return Data_Ord.compare(dictOrd1)(x.value1)(y.value1);
              };
          });
      };
  };
  exports["NonEmpty"] = NonEmpty;
  exports["fold1"] = fold1;
  exports["foldMap1"] = foldMap1;
  exports["foldl1"] = foldl1;
  exports["fromNonEmpty"] = fromNonEmpty;
  exports["head"] = head;
  exports["oneOf"] = oneOf;
  exports["singleton"] = singleton;
  exports["tail"] = tail;
  exports["showNonEmpty"] = showNonEmpty;
  exports["eqNonEmpty"] = eqNonEmpty;
  exports["ordNonEmpty"] = ordNonEmpty;
  exports["functorNonEmpty"] = functorNonEmpty;
  exports["foldableNonEmpty"] = foldableNonEmpty;
  exports["traversableNonEmpty"] = traversableNonEmpty;
})(PS["Data.NonEmpty"] = PS["Data.NonEmpty"] || {});
(function(exports) {
    "use strict";

  exports.unfoldrArrayImpl = function (isNothing) {
    return function (fromJust) {
      return function (fst) {
        return function (snd) {
          return function (f) {
            return function (b) {
              var result = [];
              while (true) {
                var maybe = f(b);
                if (isNothing(maybe)) return result;
                var tuple = fromJust(maybe);
                result.push(fst(tuple));
                b = snd(tuple);
              }
            };
          };
        };
      };
    };
  };
})(PS["Data.Unfoldable"] = PS["Data.Unfoldable"] || {});
(function(exports) {
  
  /**
 *  | This module provides a type class for _unfoldable functors_, i.e.
 *  | functors which support an `unfoldr` operation.
 *  |
 *  | This allows us to unify various operations on arrays, lists,
 *  | sequences, etc.
 */  
  "use strict";
  var $foreign = PS["Data.Unfoldable"];
  var Prelude = PS["Prelude"];
  var Data_Maybe = PS["Data.Maybe"];
  var Data_Traversable = PS["Data.Traversable"];
  var Data_Tuple = PS["Data.Tuple"];
  var Partial_Unsafe = PS["Partial.Unsafe"];
  var Data_Ord = PS["Data.Ord"];
  var Data_Ring = PS["Data.Ring"];
  var Data_Function = PS["Data.Function"];
  var Data_Unit = PS["Data.Unit"];
  var Data_Functor = PS["Data.Functor"];        

  /**
 *  | This class identifies data structures which can be _unfolded_,
 *  | generalizing `unfoldr` on arrays.
 *  |
 *  | The generating function `f` in `unfoldr f` in understood as follows:
 *  |
 *  | - If `f b` is `Nothing`, then `unfoldr f b` should be empty.
 *  | - If `f b` is `Just (Tuple a b1)`, then `unfoldr f b` should consist of `a`
 *  |   appended to the result of `unfoldr f b1`.
 */  
  var Unfoldable = function (unfoldr) {
      this.unfoldr = unfoldr;
  };

  /**
 *  | This class identifies data structures which can be _unfolded_,
 *  | generalizing `unfoldr` on arrays.
 *  |
 *  | The generating function `f` in `unfoldr f` in understood as follows:
 *  |
 *  | - If `f b` is `Nothing`, then `unfoldr f b` should be empty.
 *  | - If `f b` is `Just (Tuple a b1)`, then `unfoldr f b` should consist of `a`
 *  |   appended to the result of `unfoldr f b1`.
 */  
  var unfoldr = function (dict) {
      return dict.unfoldr;
  };
  var unfoldableArray = new Unfoldable($foreign.unfoldrArrayImpl(Data_Maybe.isNothing)(Partial_Unsafe.unsafePartial(function (dictPartial) {
      return Data_Maybe.fromJust(dictPartial);
  }))(Data_Tuple.fst)(Data_Tuple.snd));

  /**
 *  | Replicate a value some natural number of times.
 *  | For example:
 *  |
 *  | ~~~ purescript
 *  | replicate 2 "foo" == ["foo", "foo"] :: Array String
 *  | ~~~
 */  
  var replicate = function (dictUnfoldable) {
      return function (n) {
          return function (v) {
              var step = function (i) {
                  var $8 = i <= 0;
                  if ($8) {
                      return Data_Maybe.Nothing.value;
                  };
                  if (!$8) {
                      return new Data_Maybe.Just(new Data_Tuple.Tuple(v, i - 1));
                  };
                  throw new Error("Failed pattern match at Data.Unfoldable line 59, column 7 - line 60, column 34: " + [ $8.constructor.name ]);
              };
              return unfoldr(dictUnfoldable)(step)(n);
          };
      };
  };

  /**
 *  | Perform an Applicative action `n` times, and accumulate all the results.
 */  
  var replicateA = function (dictApplicative) {
      return function (dictUnfoldable) {
          return function (dictTraversable) {
              return function (n) {
                  return function (m) {
                      return Data_Traversable.sequence(dictTraversable)(dictApplicative)(replicate(dictUnfoldable)(n)(m));
                  };
              };
          };
      };
  };

  /**
 *  | Contain a single value.
 *  | For example:
 *  |
 *  | ~~~ purescript
 *  | singleton "foo" == ["foo"] :: Array String
 *  | ~~~
 */  
  var singleton = function (dictUnfoldable) {
      return replicate(dictUnfoldable)(1);
  };

  /**
 *  | The container with no elements - unfolded with zero iterations.
 *  | For example:
 *  |
 *  | ~~~ purescript
 *  | none == [] :: forall a. Array a
 *  | ~~~
 */  
  var none = function (dictUnfoldable) {
      return unfoldr(dictUnfoldable)(Data_Function["const"](Data_Maybe.Nothing.value))(Data_Unit.unit);
  };

  /**
 *  | Convert a Maybe to any Unfoldable like lists and arrays.
 */  
  var fromMaybe = function (dictUnfoldable) {
      return unfoldr(dictUnfoldable)(function (b) {
          return Data_Functor.map(Data_Maybe.functorMaybe)(Data_Function.flip(Data_Tuple.Tuple.create)(Data_Maybe.Nothing.value))(b);
      });
  };
  exports["Unfoldable"] = Unfoldable;
  exports["fromMaybe"] = fromMaybe;
  exports["none"] = none;
  exports["replicate"] = replicate;
  exports["replicateA"] = replicateA;
  exports["singleton"] = singleton;
  exports["unfoldr"] = unfoldr;
  exports["unfoldableArray"] = unfoldableArray;
})(PS["Data.Unfoldable"] = PS["Data.Unfoldable"] || {});
(function(exports) {
  
  /**
 *  | Helper functions for working with immutable Javascript arrays.
 *  |
 *  | _Note_: Depending on your use-case, you may prefer to use `Data.List` or
 *  | `Data.Sequence` instead, which might give better performance for certain
 *  | use cases. This module is useful when integrating with JavaScript libraries
 *  | which use arrays, but immutable arrays are not a practical data structure
 *  | for many use cases due to their poor asymptotics.
 *  |
 *  | In addition to the functions in this module, Arrays have a number of
 *  | useful instances:
 *  |
 *  | * `Functor`, which provides `map :: forall a b. (a -> b) -> Array a ->
 *  |   Array b`
 *  | * `Apply`, which provides `(<*>) :: forall a b. Array (a -> b) -> Array a
 *  |   -> Array b`. This function works a bit like a Cartesian product; the
 *  |   result array is constructed by applying each function in the first
 *  |   array to each value in the second, so that the result array ends up with
 *  |   a length equal to the product of the two arguments' lengths.
 *  | * `Bind`, which provides `(>>=) :: forall a b. (a -> Array b) -> Array a
 *  |   -> Array b` (this is the same as `concatMap`).
 *  | * `Semigroup`, which provides `(<>) :: forall a. Array a -> Array a ->
 *  |   Array a`, for concatenating arrays.
 *  | * `Foldable`, which provides a slew of functions for *folding* (also known
 *  |   as *reducing*) arrays down to one value. For example,
 *  |   `Data.Foldable.or` tests whether an array of `Boolean` values contains
 *  |   at least one `true` value.
 *  | * `Traversable`, which provides the PureScript version of a for-loop,
 *  |   allowing you to iterate over an array and accumulate effects.
 *  |
 */  
  "use strict";
  var $foreign = PS["Data.Array"];
  var Prelude = PS["Prelude"];
  var Control_Alt = PS["Control.Alt"];
  var Control_Alternative = PS["Control.Alternative"];
  var Control_Lazy = PS["Control.Lazy"];
  var Control_Monad_Rec_Class = PS["Control.Monad.Rec.Class"];
  var Data_Foldable = PS["Data.Foldable"];
  var Data_Maybe = PS["Data.Maybe"];
  var Data_NonEmpty = PS["Data.NonEmpty"];
  var Data_Traversable = PS["Data.Traversable"];
  var Data_Tuple = PS["Data.Tuple"];
  var Data_Unfoldable = PS["Data.Unfoldable"];
  var Partial_Unsafe = PS["Partial.Unsafe"];
  var Data_Function = PS["Data.Function"];
  var Data_Ordering = PS["Data.Ordering"];
  var Data_Ring = PS["Data.Ring"];
  var Data_Ord = PS["Data.Ord"];
  var Data_Eq = PS["Data.Eq"];
  var Data_HeytingAlgebra = PS["Data.HeytingAlgebra"];
  var Control_Apply = PS["Control.Apply"];
  var Data_Functor = PS["Data.Functor"];
  var Control_Applicative = PS["Control.Applicative"];
  var Data_Boolean = PS["Data.Boolean"];
  var Data_Semiring = PS["Data.Semiring"];
  var Control_Semigroupoid = PS["Control.Semigroupoid"];
  var Control_Bind = PS["Control.Bind"];
  var Data_Semigroup = PS["Data.Semigroup"];
  var Control_Category = PS["Control.Category"];        

  /**
 *  | A generalization of `zipWith` which accumulates results in some
 *  | `Applicative` functor.
 */  
  var zipWithA = function (dictApplicative) {
      return function (f) {
          return function (xs) {
              return function (ys) {
                  return Data_Traversable.sequence(Data_Traversable.traversableArray)(dictApplicative)($foreign.zipWith(f)(xs)(ys));
              };
          };
      };
  };

  /**
 *  | Rakes two lists and returns a list of corresponding pairs.
 *  | If one input list is short, excess elements of the longer list are
 *  | discarded.
 */  
  var zip = $foreign.zipWith(Data_Tuple.Tuple.create);

  /**
 *  | Change the element at the specified index, creating a new array, or
 *  | returning `Nothing` if the index is out of bounds.
 */  
  var updateAt = $foreign._updateAt(Data_Maybe.Just.create)(Data_Maybe.Nothing.value);
  var unzip = $foreign["uncons'"](function (v) {
      return new Data_Tuple.Tuple([  ], [  ]);
  })(function (v) {
      return function (ts) {
          var $43 = unzip(ts);
          return new Data_Tuple.Tuple($foreign.cons(v.value0)($43.value0), $foreign.cons(v.value1)($43.value1));
      };
  });

  /**
 *  | Find the element of an array at the specified index.
 */  
  var unsafeIndex = function (dictPartial) {
      return $foreign.unsafeIndexImpl;
  };

  /**
 *  | Break an array into its first element and remaining elements.
 *  |
 *  | Using `uncons` provides a way of writing code that would use cons patterns
 *  | in Haskell or pre-PureScript 0.7:
 *  | ``` purescript
 *  | f (x : xs) = something
 *  | f [] = somethingElse
 *  | ```
 *  | Becomes:
 *  | ``` purescript
 *  | f arr = case uncons arr of
 *  |   Just { head: x, tail: xs } -> something
 *  |   Nothing -> somethingElse
 *  | ```
 */  
  var uncons = $foreign["uncons'"](Data_Function["const"](Data_Maybe.Nothing.value))(function (x) {
      return function (xs) {
          return new Data_Maybe.Just({
              head: x, 
              tail: xs
          });
      };
  });

  /**
 *  | Convert an `Array` into an `Unfoldable` structure.
 */  
  var toUnfoldable = function (dictUnfoldable) {
      return Data_Unfoldable.unfoldr(dictUnfoldable)($foreign["uncons'"](Data_Function["const"](Data_Maybe.Nothing.value))(function (h) {
          return function (t) {
              return new Data_Maybe.Just(new Data_Tuple.Tuple(h, t));
          };
      }));
  };

  /**
 *  | Get all but the first element of an array, creating a new array, or
 *  | `Nothing` if the array is empty
 *  |
 *  | Running time: `O(n)` where `n` is the length of the array
 */  
  var tail = $foreign["uncons'"](Data_Function["const"](Data_Maybe.Nothing.value))(function (v) {
      return function (xs) {
          return new Data_Maybe.Just(xs);
      };
  });

  /**
 *  | Split an array into two parts:
 *  |
 *  | 1. the longest initial subarray for which all element satisfy the specified
 *  |    predicate
 *  | 2. the remaining elements
 *  |
 *  | ```purescript
 *  | span (\n -> n % 2 == 1) [1,3,2,4,5] == { init: [1,3], rest: [2,4,5] }
 *  | ```
 */  
  var span = function (p) {
      var go = function (__copy_acc) {
          return function (__copy_xs) {
              var acc = __copy_acc;
              var xs = __copy_xs;
              tco: while (true) {
                  var $49 = uncons(xs);
                  if ($49 instanceof Data_Maybe.Just && p($49.value0.head)) {
                      var __tco_acc = $foreign.cons($49.value0.head)(acc);
                      acc = __tco_acc;
                      xs = $49.value0.tail;
                      continue tco;
                  };
                  return {
                      init: $foreign.reverse(acc), 
                      rest: xs
                  };
              };
          };
      };
      return go([  ]);
  };

  /**
 *  | Calculate the longest initial subarray for which all element satisfy the
 *  | specified predicate, creating a new array.
 */  
  var takeWhile = function (p) {
      return function (xs) {
          return (span(p)(xs)).init;
      };
  };

  /**
 *  | Sort the elements of an array in increasing order, where elements are
 *  | compared using the specified partial ordering, creating a new array.
 */  
  var sortBy = function (comp) {
      return function (xs) {
          var comp$prime = function (x) {
              return function (y) {
                  var $53 = comp(x)(y);
                  if ($53 instanceof Data_Ordering.GT) {
                      return 1;
                  };
                  if ($53 instanceof Data_Ordering.EQ) {
                      return 0;
                  };
                  if ($53 instanceof Data_Ordering.LT) {
                      return -1;
                  };
                  throw new Error("Failed pattern match at Data.Array line 451, column 15 - line 456, column 1: " + [ $53.constructor.name ]);
              };
          };
          return $foreign.sortImpl(comp$prime)(xs);
      };
  };

  /**
 * ------------------------------------------------------------------------------
 *  Sorting ---------------------------------------------------------------------
 * ------------------------------------------------------------------------------
 *  | Sort the elements of an array in increasing order, creating a new array.
 */  
  var sort = function (dictOrd) {
      return function (xs) {
          return sortBy(Data_Ord.compare(dictOrd))(xs);
      };
  };

  /**
 *  | Create an array of one element
 */  
  var singleton = function (a) {
      return [ a ];
  };

  /**
 * ------------------------------------------------------------------------------
 *  Array size ------------------------------------------------------------------
 * ------------------------------------------------------------------------------
 *  | Test whether an array is empty.
 */  
  var $$null = function (xs) {
      return $foreign.length(xs) === 0;
  };
  var nubBy = function (eq) {
      return function (xs) {
          var $54 = uncons(xs);
          if ($54 instanceof Data_Maybe.Just) {
              return $foreign.cons($54.value0.head)(nubBy(eq)($foreign.filter(function (y) {
                  return !eq($54.value0.head)(y);
              })($54.value0.tail)));
          };
          if ($54 instanceof Data_Maybe.Nothing) {
              return [  ];
          };
          throw new Error("Failed pattern match at Data.Array line 540, column 3 - line 542, column 18: " + [ $54.constructor.name ]);
      };
  };

  /**
 *  | Remove the duplicates from an array, creating a new array.
 */  
  var nub = function (dictEq) {
      return nubBy(Data_Eq.eq(dictEq));
  };

  /**
 *  | Apply a function to each element in an array, supplying a generated
 *  | zero-based index integer along with the element, creating an array
 *  | with the new elements.
 */  
  var mapWithIndex = function (f) {
      return function (xs) {
          return $foreign.zipWith(f)($foreign.range(0)($foreign.length(xs) - 1))(xs);
      };
  };
  var some = function (dictAlternative) {
      return function (dictLazy) {
          return function (v) {
              return Control_Apply.apply((dictAlternative["__superclass_Control.Applicative.Applicative_0"]())["__superclass_Control.Apply.Apply_0"]())(Data_Functor.map(((dictAlternative["__superclass_Control.Plus.Plus_1"]())["__superclass_Control.Alt.Alt_0"]())["__superclass_Data.Functor.Functor_0"]())($foreign.cons)(v))(Control_Lazy.defer(dictLazy)(function (v1) {
                  return many(dictAlternative)(dictLazy)(v);
              }));
          };
      };
  };
  var many = function (dictAlternative) {
      return function (dictLazy) {
          return function (v) {
              return Control_Alt.alt((dictAlternative["__superclass_Control.Plus.Plus_1"]())["__superclass_Control.Alt.Alt_0"]())(some(dictAlternative)(dictLazy)(v))(Control_Applicative.pure(dictAlternative["__superclass_Control.Applicative.Applicative_0"]())([  ]));
          };
      };
  };

  /**
 *  | Insert an element at the specified index, creating a new array, or
 *  | returning `Nothing` if the index is out of bounds.
 */  
  var insertAt = $foreign._insertAt(Data_Maybe.Just.create)(Data_Maybe.Nothing.value);

  /**
 *  | Get all but the last element of an array, creating a new array, or
 *  | `Nothing` if the array is empty.
 *  |
 *  | Running time: `O(n)` where `n` is the length of the array
 */  
  var init = function (xs) {
      if ($$null(xs)) {
          return Data_Maybe.Nothing.value;
      };
      if (Data_Boolean.otherwise) {
          return new Data_Maybe.Just($foreign.slice(0)($foreign.length(xs) - 1)(xs));
      };
      throw new Error("Failed pattern match at Data.Array line 242, column 1 - line 244, column 55: " + [ xs.constructor.name ]);
  };

  /**
 * ------------------------------------------------------------------------------
 *  Indexed operations ----------------------------------------------------------
 * ------------------------------------------------------------------------------
 *  | This function provides a safe way to read a value at a particular index
 *  | from an array.
 */  
  var index = $foreign.indexImpl(Data_Maybe.Just.create)(Data_Maybe.Nothing.value);

  /**
 *  | Get the last element in an array, or `Nothing` if the array is empty
 *  |
 *  | Running time: `O(1)`.
 */  
  var last = function (xs) {
      return index(xs)($foreign.length(xs) - 1);
  };

  /**
 *  | Apply a function to the element at the specified index, creating a new
 *  | array, or returning `Nothing` if the index is out of bounds.
 */  
  var modifyAt = function (i) {
      return function (f) {
          return function (xs) {
              var go = function (x) {
                  return updateAt(i)(f(x))(xs);
              };
              return Data_Maybe.maybe(Data_Maybe.Nothing.value)(go)(index(xs)(i));
          };
      };
  };

  /**
 * ------------------------------------------------------------------------------
 *  Non-indexed reads -----------------------------------------------------------
 * ------------------------------------------------------------------------------
 *  | Get the first element in an array, or `Nothing` if the array is empty
 *  |
 *  | Running time: `O(1)`.
 */  
  var head = $foreign["uncons'"](Data_Function["const"](Data_Maybe.Nothing.value))(function (x) {
      return function (v) {
          return new Data_Maybe.Just(x);
      };
  });

  /**
 *  | Group equal, consecutive elements of an array into arrays, using the
 *  | specified equivalence relation to detemine equality.
 */  
  var groupBy = function (op) {
      var go = function (__copy_acc) {
          return function (__copy_xs) {
              var acc = __copy_acc;
              var xs = __copy_xs;
              tco: while (true) {
                  var $59 = uncons(xs);
                  if ($59 instanceof Data_Maybe.Just) {
                      var sp = span(op($59.value0.head))($59.value0.tail);
                      var __tco_acc = $foreign.cons(new Data_NonEmpty.NonEmpty($59.value0.head, sp.init))(acc);
                      acc = __tco_acc;
                      xs = sp.rest;
                      continue tco;
                  };
                  if ($59 instanceof Data_Maybe.Nothing) {
                      return $foreign.reverse(acc);
                  };
                  throw new Error("Failed pattern match at Data.Array line 526, column 15 - line 530, column 27: " + [ $59.constructor.name ]);
              };
          };
      };
      return go([  ]);
  };

  /**
 *  | Group equal, consecutive elements of an array into arrays.
 *  |
 *  | ```purescript
 *  | group [1,1,2,2,1] == [[1,1],[2,2],[1]]
 *  | ```
 */  
  var group = function (dictEq) {
      return function (xs) {
          return groupBy(Data_Eq.eq(dictEq))(xs);
      };
  };

  /**
 *  | Sort and then group the elements of an array into arrays.
 *  |
 *  | ```purescript
 *  | group' [1,1,2,2,1] == [[1,1,1],[2,2]]
 *  | ```
 */  
  var group$prime = function (dictOrd) {
      return function ($76) {
          return group(dictOrd["__superclass_Data.Eq.Eq_0"]())(sort(dictOrd)($76));
      };
  };

  /**
 *  | Convert a `Foldable` structure into an `Array`.
 */  
  var fromFoldable = function (dictFoldable) {
      return $foreign.fromFoldableImpl(Data_Foldable.foldr(dictFoldable));
  };
  var foldRecM = function (dictMonadRec) {
      return function (f) {
          return function (a) {
              return function (array) {
                  var go = function (res) {
                      return function (i) {
                          if (i >= $foreign.length(array)) {
                              return Control_Applicative.pure((dictMonadRec["__superclass_Control.Monad.Monad_0"]())["__superclass_Control.Applicative.Applicative_0"]())(new Control_Monad_Rec_Class.Done(res));
                          };
                          if (Data_Boolean.otherwise) {
                              return Control_Bind.bind((dictMonadRec["__superclass_Control.Monad.Monad_0"]())["__superclass_Control.Bind.Bind_1"]())(f(res)(Partial_Unsafe.unsafePartial(function (dictPartial) {
                                  return unsafeIndex(dictPartial)(array)(i);
                              })))(function (v) {
                                  return Control_Applicative.pure((dictMonadRec["__superclass_Control.Monad.Monad_0"]())["__superclass_Control.Applicative.Applicative_0"]())(new Control_Monad_Rec_Class.Loop({
                                      a: v, 
                                      b: i + 1 | 0
                                  }));
                              });
                          };
                          throw new Error("Failed pattern match at Data.Array line 638, column 3 - line 642, column 42: " + [ res.constructor.name, i.constructor.name ]);
                      };
                  };
                  return Control_Monad_Rec_Class.tailRecM2(dictMonadRec)(go)(a)(0);
              };
          };
      };
  };
  var foldM = function (dictMonad) {
      return function (f) {
          return function (a) {
              return $foreign["uncons'"](function (v) {
                  return Control_Applicative.pure(dictMonad["__superclass_Control.Applicative.Applicative_0"]())(a);
              })(function (b) {
                  return function (bs) {
                      return Control_Bind.bind(dictMonad["__superclass_Control.Bind.Bind_1"]())(f(a)(b))(function (a$prime) {
                          return foldM(dictMonad)(f)(a$prime)(bs);
                      });
                  };
              });
          };
      };
  };

  /**
 *  | Find the last index for which a predicate holds.
 */  
  var findLastIndex = $foreign.findLastIndexImpl(Data_Maybe.Just.create)(Data_Maybe.Nothing.value);

  /**
 *  | Insert an element into a sorted array, using the specified function to
 *  | determine the ordering of elements.
 */  
  var insertBy = function (cmp) {
      return function (x) {
          return function (ys) {
              var i = Data_Maybe.maybe(0)(function (v) {
                  return v + 1 | 0;
              })(findLastIndex(function (y) {
                  return Data_Eq.eq(Data_Ordering.eqOrdering)(cmp(x)(y))(Data_Ordering.GT.value);
              })(ys));
              return Partial_Unsafe.unsafePartial(function (dictPartial) {
                  return Data_Maybe.fromJust(dictPartial)(insertAt(i)(x)(ys));
              });
          };
      };
  };

  /**
 *  | Insert an element into a sorted array.
 */  
  var insert = function (dictOrd) {
      return insertBy(Data_Ord.compare(dictOrd));
  };

  /**
 *  | Find the first index for which a predicate holds.
 */  
  var findIndex = $foreign.findIndexImpl(Data_Maybe.Just.create)(Data_Maybe.Nothing.value);

  /**
 *  | Calculate the intersection of two arrays, using the specified equivalence
 *  | relation to compare elements, creating a new array. Note that duplicates
 *  | in the first array are preserved while duplicates in the second array are
 *  | removed.
 */  
  var intersectBy = function (eq) {
      return function (xs) {
          return function (ys) {
              return $foreign.filter(function (x) {
                  return Data_Maybe.isJust(findIndex(eq(x))(ys));
              })(xs);
          };
      };
  };

  /**
 *  | Calculate the intersection of two arrays, creating a new array. Note that
 *  | duplicates in the first array are preserved while duplicates in the second
 *  | array are removed.
 */  
  var intersect = function (dictEq) {
      return intersectBy(Data_Eq.eq(dictEq));
  };
  var filterM = function (dictMonad) {
      return function (p) {
          return $foreign["uncons'"](function (v) {
              return Control_Applicative.pure(dictMonad["__superclass_Control.Applicative.Applicative_0"]())([  ]);
          })(function (x) {
              return function (xs) {
                  return Control_Bind.bind(dictMonad["__superclass_Control.Bind.Bind_1"]())(p(x))(function (v) {
                      return Control_Bind.bind(dictMonad["__superclass_Control.Bind.Bind_1"]())(filterM(dictMonad)(p)(xs))(function (v1) {
                          return Control_Applicative.pure(dictMonad["__superclass_Control.Applicative.Applicative_0"]())((function () {
                              if (v) {
                                  return $foreign.cons(x)(v1);
                              };
                              if (!v) {
                                  return v1;
                              };
                              throw new Error("Failed pattern match at Data.Array line 418, column 8 - line 418, column 34: " + [ v.constructor.name ]);
                          })());
                      });
                  });
              };
          });
      };
  };

  /**
 *  | Find the index of the last element equal to the specified element.
 */  
  var elemLastIndex = function (dictEq) {
      return function (x) {
          return findLastIndex(function (v) {
              return Data_Eq.eq(dictEq)(v)(x);
          });
      };
  };

  /**
 *  | Find the index of the first element equal to the specified element.
 */  
  var elemIndex = function (dictEq) {
      return function (x) {
          return findIndex(function (v) {
              return Data_Eq.eq(dictEq)(v)(x);
          });
      };
  };

  /**
 *  | Remove the longest initial subarray for which all element satisfy the
 *  | specified predicate, creating a new array.
 */  
  var dropWhile = function (p) {
      return function (xs) {
          return (span(p)(xs)).rest;
      };
  };

  /**
 *  | Delete the element at the specified index, creating a new array, or
 *  | returning `Nothing` if the index is out of bounds.
 */  
  var deleteAt = $foreign._deleteAt(Data_Maybe.Just.create)(Data_Maybe.Nothing.value);

  /**
 *  | Delete the first element of an array which matches the specified value,
 *  | under the equivalence relation provided in the first argument, creating a
 *  | new array.
 */  
  var deleteBy = function (v) {
      return function (v1) {
          return function (v2) {
              if (v2.length === 0) {
                  return [  ];
              };
              return Data_Maybe.maybe(v2)(function (i) {
                  return Partial_Unsafe.unsafePartial(function (dictPartial) {
                      return Data_Maybe.fromJust(dictPartial)(deleteAt(i)(v2));
                  });
              })(findIndex(v(v1))(v2));
          };
      };
  };

  /**
 *  | Calculate the union of two arrays, using the specified function to
 *  | determine equality of elements. Note that duplicates in the first array
 *  | are preserved while duplicates in the second array are removed.
 */  
  var unionBy = function (eq) {
      return function (xs) {
          return function (ys) {
              return Data_Semigroup.append(Data_Semigroup.semigroupArray)(xs)(Data_Foldable.foldl(Data_Foldable.foldableArray)(Data_Function.flip(deleteBy(eq)))(nubBy(eq)(ys))(xs));
          };
      };
  };

  /**
 *  | Calculate the union of two arrays. Note that duplicates in the first array
 *  | are preserved while duplicates in the second array are removed.
 *  |
 *  | Running time: `O(n^2)`
 */  
  var union = function (dictEq) {
      return unionBy(Data_Eq.eq(dictEq));
  };

  /**
 *  | Delete the first element of an array which is equal to the specified value,
 *  | creating a new array.
 */  
  var $$delete = function (dictEq) {
      return deleteBy(Data_Eq.eq(dictEq));
  };
  var difference = function (dictEq) {
      return function (xs) {
          return function (ys) {
              if ($$null(xs)) {
                  return [  ];
              };
              if (Data_Boolean.otherwise) {
                  return $foreign["uncons'"](Data_Function["const"](xs))(function (z) {
                      return function (zs) {
                          return difference(dictEq)($$delete(dictEq)(z)(xs))(zs);
                      };
                  })(ys);
              };
              throw new Error("Failed pattern match at Data.Array line 572, column 1 - line 574, column 67: " + [ xs.constructor.name, ys.constructor.name ]);
          };
      };
  };

  /**
 *  | Apply a function to each element in an array, and flatten the results
 *  | into a single, new array.
 */  
  var concatMap = Data_Function.flip(Control_Bind.bind(Control_Bind.bindArray));

  /**
 *  | Apply a function to each element in an array, keeping only the results
 *  | which contain a value, creating a new array.
 */  
  var mapMaybe = function (f) {
      return concatMap(function ($77) {
          return Data_Maybe.maybe([  ])(singleton)(f($77));
      });
  };

  /**
 *  | Filter an array of optional values, keeping only the elements which contain
 *  | a value, creating a new array.
 */  
  var catMaybes = mapMaybe(Control_Category.id(Control_Category.categoryFn));

  /**
 *  | Update or delete the element at the specified index by applying a
 *  | function to the current value, returning a new array or `Nothing` if the
 *  | index is out-of-bounds.
 */  
  var alterAt = function (i) {
      return function (f) {
          return function (xs) {
              var go = function (x) {
                  var $74 = f(x);
                  if ($74 instanceof Data_Maybe.Nothing) {
                      return deleteAt(i)(xs);
                  };
                  if ($74 instanceof Data_Maybe.Just) {
                      return updateAt(i)($74.value0)(xs);
                  };
                  throw new Error("Failed pattern match at Data.Array line 376, column 10 - line 378, column 32: " + [ $74.constructor.name ]);
              };
              return Data_Maybe.maybe(Data_Maybe.Nothing.value)(go)(index(xs)(i));
          };
      };
  };
  exports["alterAt"] = alterAt;
  exports["catMaybes"] = catMaybes;
  exports["concatMap"] = concatMap;
  exports["delete"] = $$delete;
  exports["deleteAt"] = deleteAt;
  exports["deleteBy"] = deleteBy;
  exports["difference"] = difference;
  exports["dropWhile"] = dropWhile;
  exports["elemIndex"] = elemIndex;
  exports["elemLastIndex"] = elemLastIndex;
  exports["filterM"] = filterM;
  exports["findIndex"] = findIndex;
  exports["findLastIndex"] = findLastIndex;
  exports["foldM"] = foldM;
  exports["foldRecM"] = foldRecM;
  exports["fromFoldable"] = fromFoldable;
  exports["group"] = group;
  exports["group'"] = group$prime;
  exports["groupBy"] = groupBy;
  exports["head"] = head;
  exports["index"] = index;
  exports["init"] = init;
  exports["insert"] = insert;
  exports["insertAt"] = insertAt;
  exports["insertBy"] = insertBy;
  exports["intersect"] = intersect;
  exports["intersectBy"] = intersectBy;
  exports["last"] = last;
  exports["many"] = many;
  exports["mapMaybe"] = mapMaybe;
  exports["mapWithIndex"] = mapWithIndex;
  exports["modifyAt"] = modifyAt;
  exports["nub"] = nub;
  exports["nubBy"] = nubBy;
  exports["null"] = $$null;
  exports["singleton"] = singleton;
  exports["some"] = some;
  exports["sort"] = sort;
  exports["sortBy"] = sortBy;
  exports["span"] = span;
  exports["tail"] = tail;
  exports["takeWhile"] = takeWhile;
  exports["toUnfoldable"] = toUnfoldable;
  exports["uncons"] = uncons;
  exports["union"] = union;
  exports["unionBy"] = unionBy;
  exports["unsafeIndex"] = unsafeIndex;
  exports["unzip"] = unzip;
  exports["updateAt"] = updateAt;
  exports["zip"] = zip;
  exports["zipWithA"] = zipWithA;
  exports["concat"] = $foreign.concat;
  exports["cons"] = $foreign.cons;
  exports["drop"] = $foreign.drop;
  exports["filter"] = $foreign.filter;
  exports["length"] = $foreign.length;
  exports["partition"] = $foreign.partition;
  exports["range"] = $foreign.range;
  exports["replicate"] = $foreign.replicate;
  exports["reverse"] = $foreign.reverse;
  exports["slice"] = $foreign.slice;
  exports["snoc"] = $foreign.snoc;
  exports["take"] = $foreign.take;
  exports["zipWith"] = $foreign.zipWith;
})(PS["Data.Array"] = PS["Data.Array"] || {});
(function(exports) {
    "use strict";

  exports._charAt = function (just) {
    return function (nothing) {
      return function (i) {
        return function (s) {
          return i >= 0 && i < s.length ? just(s.charAt(i)) : nothing;
        };
      };
    };
  };

  exports.singleton = function (c) {
    return c;
  };

  exports._charCodeAt = function (just) {
    return function (nothing) {
      return function (i) {
        return function (s) {
          return i >= 0 && i < s.length ? just(s.charCodeAt(i)) : nothing;
        };
      };
    };
  };

  exports._toChar = function (just) {
    return function (nothing) {
      return function (s) {
        return s.length === 1 ? just(s) : nothing;
      };
    };
  };

  exports.fromCharArray = function (a) {
    return a.join("");
  };

  exports._indexOf = function (just) {
    return function (nothing) {
      return function (x) {
        return function (s) {
          var i = s.indexOf(x);
          return i === -1 ? nothing : just(i);
        };
      };
    };
  };

  exports["_indexOf'"] = function (just) {
    return function (nothing) {
      return function (x) {
        return function (startAt) {
          return function (s) {
            if (startAt < 0 || startAt > s.length) return nothing;
            var i = s.indexOf(x, startAt);
            return i === -1 ? nothing : just(i);
          };
        };
      };
    };
  };

  exports._lastIndexOf = function (just) {
    return function (nothing) {
      return function (x) {
        return function (s) {
          var i = s.lastIndexOf(x);
          return i === -1 ? nothing : just(i);
        };
      };
    };
  };

  exports["_lastIndexOf'"] = function (just) {
    return function (nothing) {
      return function (x) {
        return function (startAt) {
          return function (s) {
            if (startAt < 0 || startAt > s.length) return nothing;
            var i = s.lastIndexOf(x, startAt);
            return i === -1 ? nothing : just(i);
          };
        };
      };
    };
  };

  exports.length = function (s) {
    return s.length;
  };

  exports._localeCompare = function (lt) {
    return function (eq) {
      return function (gt) {
        return function (s1) {
          return function (s2) {
            var result = s1.localeCompare(s2);
            return result < 0 ? lt : result > 0 ? gt : eq;
          };
        };
      };
    };
  };

  exports.replace = function (s1) {
    return function (s2) {
      return function (s3) {
        return s3.replace(s1, s2);
      };
    };
  };

  exports.replaceAll = function (s1) {
    return function (s2) {
      return function (s3) {
        return s3.replace(new RegExp(s1.replace(/[-\/\\^$*+?.()|[\]{}]/g, "\\$&"), "g"), s2);
      };
    };
  };

  exports.take = function (n) {
    return function (s) {
      return s.substr(0, n);
    };
  };

  exports.drop = function (n) {
    return function (s) {
      return s.substring(n);
    };
  };

  exports.count = function (p) {
    return function (s) {
      for (var i = 0; i < s.length && p(s.charAt(i)); i++); {}
      return i;
    };
  };

  exports.split = function (sep) {
    return function (s) {
      return s.split(sep);
    };
  };

  exports._splitAt = function (just) {
    return function (nothing) {
      return function (i) {
        return function (s) {
          return i >= 0 && i < s.length ?
                 just([s.substring(0, i), s.substring(i)]) : nothing;
        };
      };
    };
  };

  exports.toCharArray = function (s) {
    return s.split("");
  };

  exports.toLower = function (s) {
    return s.toLowerCase();
  };

  exports.toUpper = function (s) {
    return s.toUpperCase();
  };

  exports.trim = function (s) {
    return s.trim();
  };

  exports.joinWith = function (s) {
    return function (xs) {
      return xs.join(s);
    };
  };
})(PS["Data.String"] = PS["Data.String"] || {});
(function(exports) {
    "use strict";

  exports.charCodeAt = function (i) {
    return function (s) {
      if (i >= 0 && i < s.length) return s.charCodeAt(i);
      throw new Error("Data.String.Unsafe.charCodeAt: Invalid index.");
    };
  };

  exports.charAt = function (i) {
    return function (s) {
      if (i >= 0 && i < s.length) return s.charAt(i);
      throw new Error("Data.String.Unsafe.charAt: Invalid index.");
    };
  };

  exports.char = function (s) {
    if (s.length === 1) return s.charAt(0);
    throw new Error("Data.String.Unsafe.char: Expected string of length 1.");
  };
})(PS["Data.String.Unsafe"] = PS["Data.String.Unsafe"] || {});
(function(exports) {
  
  /**
 *  | Unsafe string and character functions.
 */  
  "use strict";
  var $foreign = PS["Data.String.Unsafe"];
  exports["char"] = $foreign["char"];
  exports["charAt"] = $foreign.charAt;
  exports["charCodeAt"] = $foreign.charCodeAt;
})(PS["Data.String.Unsafe"] = PS["Data.String.Unsafe"] || {});
(function(exports) {
  
  /**
 *  | Wraps the functions of Javascript's `String` object.
 *  | A String represents a sequence of characters.
 *  | For details of the underlying implementation, see [String Reference at MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String).
 */  
  "use strict";
  var $foreign = PS["Data.String"];
  var Prelude = PS["Prelude"];
  var Data_Maybe = PS["Data.Maybe"];
  var Data_Newtype = PS["Data.Newtype"];
  var Data_String_Unsafe = PS["Data.String.Unsafe"];
  var Data_Eq = PS["Data.Eq"];
  var Data_Ord = PS["Data.Ord"];
  var Data_Show = PS["Data.Show"];
  var Data_Semigroup = PS["Data.Semigroup"];
  var Data_Semiring = PS["Data.Semiring"];
  var Data_Ordering = PS["Data.Ordering"];
  var Data_Ring = PS["Data.Ring"];
  var Data_Function = PS["Data.Function"];
  var Control_Semigroupoid = PS["Control.Semigroupoid"];        

  /**
 *  | A newtype used in cases to specify a replacement for a pattern.
 */  
  var Replacement = function (x) {
      return x;
  };

  /**
 *  | A newtype used in cases where there is a string to be matched.
 */  
  var Pattern = function (x) {
      return x;
  };

  /**
 *  | Returns the first character and the rest of the string,
 *  | if the string is not empty.
 */  
  var uncons = function (v) {
      if (v === "") {
          return Data_Maybe.Nothing.value;
      };
      return new Data_Maybe.Just({
          head: Data_String_Unsafe.charAt(0)(v), 
          tail: $foreign.drop(1)(v)
      });
  };
  var toChar = $foreign._toChar(Data_Maybe.Just.create)(Data_Maybe.Nothing.value);

  /**
 *  | Returns the longest prefix (possibly empty) of characters that satisfy
 *  | the predicate.
 */  
  var takeWhile = function (p) {
      return function (s) {
          return $foreign.take($foreign.count(p)(s))(s);
      };
  };

  /**
 *  | Returns the substrings of split at the given index, if the index is within bounds.
 */  
  var splitAt = $foreign._splitAt(Data_Maybe.Just.create)(Data_Maybe.Nothing.value);
  var showReplacement = new Data_Show.Show(function (v) {
      return "(Replacement " + (v + ")");
  });
  var showPattern = new Data_Show.Show(function (v) {
      return "(Pattern " + (v + ")");
  });

  /**
 *  | Returns `true` if the given string is empty.
 */  
  var $$null = function (s) {
      return $foreign.length(s) === 0;
  };
  var newtypeReplacement = new Data_Newtype.Newtype(function (n) {
      return n;
  }, Replacement);
  var newtypePattern = new Data_Newtype.Newtype(function (n) {
      return n;
  }, Pattern);

  /**
 *  | Locale-aware sort order comparison.
 */  
  var localeCompare = $foreign._localeCompare(Data_Ordering.LT.value)(Data_Ordering.EQ.value)(Data_Ordering.GT.value);

  /**
 *  | Returns the index of the last occurrence of the first string in the
 *  | second string, starting at the given index. Returns `Nothing` if there is
 *  | no match.
 */  
  var lastIndexOf$prime = $foreign["_lastIndexOf'"](Data_Maybe.Just.create)(Data_Maybe.Nothing.value);

  /**
 *  | Returns the index of the last occurrence of the first string in the
 *  | second string. Returns `Nothing` if there is no match.
 */  
  var lastIndexOf = $foreign._lastIndexOf(Data_Maybe.Just.create)(Data_Maybe.Nothing.value);

  /**
 *  | If the string ends with the given suffix, return the portion of the
 *  | string left after removing it, as a Just value. Otherwise, return Nothing.
 *  | * `stripSuffix (Pattern ".exe") "psc.exe" == Just "psc"`
 *  | * `stripSuffix (Pattern ".exe") "psc" == Nothing`
 */  
  var stripSuffix = function (v) {
      return function (str) {
          var $32 = lastIndexOf(v)(str);
          if ($32 instanceof Data_Maybe.Just && $32.value0 === $foreign.length(str) - $foreign.length(v)) {
              return Data_Maybe.Just.create($foreign.take($32.value0)(str));
          };
          return Data_Maybe.Nothing.value;
      };
  };

  /**
 *  | Returns the index of the first occurrence of the first string in the
 *  | second string, starting at the given index. Returns `Nothing` if there is
 *  | no match.
 */  
  var indexOf$prime = $foreign["_indexOf'"](Data_Maybe.Just.create)(Data_Maybe.Nothing.value);

  /**
 *  | Returns the index of the first occurrence of the first string in the
 *  | second string. Returns `Nothing` if there is no match.
 */  
  var indexOf = $foreign._indexOf(Data_Maybe.Just.create)(Data_Maybe.Nothing.value);

  /**
 *  | If the string starts with the given prefix, return the portion of the
 *  | string left after removing it, as a Just value. Otherwise, return Nothing.
 *  | * `stripPrefix (Pattern "http:") "http://purescript.org" == Just "//purescript.org"`
 *  | * `stripPrefix (Pattern "http:") "https://purescript.org" == Nothing`
 */  
  var stripPrefix = function (v) {
      return function (str) {
          var $36 = indexOf(v)(str);
          if ($36 instanceof Data_Maybe.Just && $36.value0 === 0) {
              return Data_Maybe.Just.create($foreign.drop($foreign.length(v))(str));
          };
          return Data_Maybe.Nothing.value;
      };
  };
  var eqReplacement = new Data_Eq.Eq(function (x) {
      return function (y) {
          return x === y;
      };
  });
  var ordReplacement = new Data_Ord.Ord(function () {
      return eqReplacement;
  }, function (x) {
      return function (y) {
          return Data_Ord.compare(Data_Ord.ordString)(x)(y);
      };
  });
  var eqPattern = new Data_Eq.Eq(function (x) {
      return function (y) {
          return x === y;
      };
  });
  var ordPattern = new Data_Ord.Ord(function () {
      return eqPattern;
  }, function (x) {
      return function (y) {
          return Data_Ord.compare(Data_Ord.ordString)(x)(y);
      };
  });

  /**
 *  | Returns the suffix remaining after `takeWhile`.
 */  
  var dropWhile = function (p) {
      return function (s) {
          return $foreign.drop($foreign.count(p)(s))(s);
      };
  };

  /**
 *  | Checks whether the first string exists in the second string.
 */  
  var contains = function (pat) {
      return function ($46) {
          return Data_Maybe.isJust(indexOf(pat)($46));
      };
  };

  /**
 *  | Returns the numeric Unicode value of the character at the given index,
 *  | if the index is within bounds.
 */  
  var charCodeAt = $foreign._charCodeAt(Data_Maybe.Just.create)(Data_Maybe.Nothing.value);

  /**
 *  | Returns the character at the given index, if the index is within bounds.
 */  
  var charAt = $foreign._charAt(Data_Maybe.Just.create)(Data_Maybe.Nothing.value);
  exports["Pattern"] = Pattern;
  exports["Replacement"] = Replacement;
  exports["charAt"] = charAt;
  exports["charCodeAt"] = charCodeAt;
  exports["contains"] = contains;
  exports["dropWhile"] = dropWhile;
  exports["indexOf"] = indexOf;
  exports["indexOf'"] = indexOf$prime;
  exports["lastIndexOf"] = lastIndexOf;
  exports["lastIndexOf'"] = lastIndexOf$prime;
  exports["localeCompare"] = localeCompare;
  exports["null"] = $$null;
  exports["splitAt"] = splitAt;
  exports["stripPrefix"] = stripPrefix;
  exports["stripSuffix"] = stripSuffix;
  exports["takeWhile"] = takeWhile;
  exports["toChar"] = toChar;
  exports["uncons"] = uncons;
  exports["eqPattern"] = eqPattern;
  exports["ordPattern"] = ordPattern;
  exports["newtypePattern"] = newtypePattern;
  exports["showPattern"] = showPattern;
  exports["eqReplacement"] = eqReplacement;
  exports["ordReplacement"] = ordReplacement;
  exports["newtypeReplacement"] = newtypeReplacement;
  exports["showReplacement"] = showReplacement;
  exports["count"] = $foreign.count;
  exports["drop"] = $foreign.drop;
  exports["fromCharArray"] = $foreign.fromCharArray;
  exports["joinWith"] = $foreign.joinWith;
  exports["length"] = $foreign.length;
  exports["replace"] = $foreign.replace;
  exports["replaceAll"] = $foreign.replaceAll;
  exports["singleton"] = $foreign.singleton;
  exports["split"] = $foreign.split;
  exports["take"] = $foreign.take;
  exports["toCharArray"] = $foreign.toCharArray;
  exports["toLower"] = $foreign.toLower;
  exports["toUpper"] = $foreign.toUpper;
  exports["trim"] = $foreign.trim;
})(PS["Data.String"] = PS["Data.String"] || {});
(function(exports) {
  
  /**
 *  | The `Proxy` type and values are for situations where type information is
 *  | required for an input to determine the type of an output, but where it is
 *  | not possible or convenient to provide a _value_ for the input.
 *  |
 *  | A hypothetical example: if you have a class that is used to handle the
 *  | result of an AJAX request, you may want to use this information to set the
 *  | expected content type of the request, so you might have a class something
 *  | like this:
 *  |
 *  | ``` purescript
 *  | class AjaxResponse a where
 *  |   responseType :: a -> ResponseType
 *  |   fromResponse :: Foreign -> a
 *  | ```
 *  |
 *  | The problem here is `responseType` requires a value of type `a`, but we
 *  | won't have a value of that type until the request has been completed. The
 *  | solution is to use a `Proxy` type instead:
 *  |
 *  | ``` purescript
 *  | class AjaxResponse a where
 *  |   responseType :: Proxy a -> ResponseType
 *  |   fromResponse :: Foreign -> a
 *  | ```
 *  |
 *  | We can now call `responseType (Proxy :: Proxy SomeContentType)` to produce
 *  | a `ResponseType` for `SomeContentType` without having to construct some
 *  | empty version of `SomeContentType` first. In situations like this where
 *  | the `Proxy` type can be statically determined, it is recommended to pull
 *  | out the definition to the top level and make a declaration like:
 *  |
 *  | ``` purescript
 *  | _SomeContentType :: Proxy SomeContentType
 *  | _SomeContentType = Proxy
 *  | ```
 *  |
 *  | That way the proxy value can be used as `responseType _SomeContentType`
 *  | for improved readability. However, this is not always possible, sometimes
 *  | the type required will be determined by a type variable. As PureScript has
 *  | scoped type variables, we can do things like this:
 *  |
 *  | ``` purescript
 *  | makeRequest :: URL -> ResponseType -> Aff _ Foreign
 *  | makeRequest = ...
 *  |
 *  | fetchData :: forall a. (AjaxResponse a) => URL -> Aff _ a
 *  | fetchData url = fromResponse <$> makeRequest url (responseType (Proxy :: Proxy a))
 *  | ```
 */  
  "use strict";

  /**
 *  | Value proxy for kind `* -> * -> *` types.
 */  
  var Proxy3 = (function () {
      function Proxy3() {

      };
      Proxy3.value = new Proxy3();
      return Proxy3;
  })();

  /**
 *  | Value proxy for kind `* -> *` types.
 */  
  var Proxy2 = (function () {
      function Proxy2() {

      };
      Proxy2.value = new Proxy2();
      return Proxy2;
  })();

  /**
 *  | Value proxy for kind `*` types.
 */  
  var $$Proxy = (function () {
      function $$Proxy() {

      };
      $$Proxy.value = new $$Proxy();
      return $$Proxy;
  })();
  exports["Proxy"] = $$Proxy;
  exports["Proxy2"] = Proxy2;
  exports["Proxy3"] = Proxy3;
})(PS["Type.Proxy"] = PS["Type.Proxy"] || {});
(function(exports) {
    "use strict";
  var $foreign = PS["Data.Generic"];
  var Prelude = PS["Prelude"];
  var Data_Array = PS["Data.Array"];
  var Data_Either = PS["Data.Either"];
  var Data_Foldable = PS["Data.Foldable"];
  var Data_Identity = PS["Data.Identity"];
  var Data_Maybe = PS["Data.Maybe"];
  var Data_NonEmpty = PS["Data.NonEmpty"];
  var Data_String = PS["Data.String"];
  var Data_Traversable = PS["Data.Traversable"];
  var Data_Tuple = PS["Data.Tuple"];
  var Type_Proxy = PS["Type.Proxy"];
  var Control_Semigroupoid = PS["Control.Semigroupoid"];
  var Data_Functor = PS["Data.Functor"];
  var Data_Unit = PS["Data.Unit"];
  var Control_Apply = PS["Control.Apply"];
  var Control_Applicative = PS["Control.Applicative"];
  var Data_Ordering = PS["Data.Ordering"];
  var Data_Eq = PS["Data.Eq"];
  var Data_HeytingAlgebra = PS["Data.HeytingAlgebra"];
  var Data_Ord = PS["Data.Ord"];
  var Data_Function = PS["Data.Function"];
  var Data_Show = PS["Data.Show"];
  var Data_Semigroup = PS["Data.Semigroup"];
  var Data_Monoid = PS["Data.Monoid"];
  var Data_Ring = PS["Data.Ring"];
  var Data_Boolean = PS["Data.Boolean"];        

  /**
 *  | A GenericSpine is a universal representation of an arbitrary data
 *  | structure (that does not contain function arrows).
 */  
  var SProd = (function () {
      function SProd(value0, value1) {
          this.value0 = value0;
          this.value1 = value1;
      };
      SProd.create = function (value0) {
          return function (value1) {
              return new SProd(value0, value1);
          };
      };
      return SProd;
  })();

  /**
 *  | A GenericSpine is a universal representation of an arbitrary data
 *  | structure (that does not contain function arrows).
 */  
  var SRecord = (function () {
      function SRecord(value0) {
          this.value0 = value0;
      };
      SRecord.create = function (value0) {
          return new SRecord(value0);
      };
      return SRecord;
  })();

  /**
 *  | A GenericSpine is a universal representation of an arbitrary data
 *  | structure (that does not contain function arrows).
 */  
  var SNumber = (function () {
      function SNumber(value0) {
          this.value0 = value0;
      };
      SNumber.create = function (value0) {
          return new SNumber(value0);
      };
      return SNumber;
  })();

  /**
 *  | A GenericSpine is a universal representation of an arbitrary data
 *  | structure (that does not contain function arrows).
 */  
  var SBoolean = (function () {
      function SBoolean(value0) {
          this.value0 = value0;
      };
      SBoolean.create = function (value0) {
          return new SBoolean(value0);
      };
      return SBoolean;
  })();

  /**
 *  | A GenericSpine is a universal representation of an arbitrary data
 *  | structure (that does not contain function arrows).
 */  
  var SInt = (function () {
      function SInt(value0) {
          this.value0 = value0;
      };
      SInt.create = function (value0) {
          return new SInt(value0);
      };
      return SInt;
  })();

  /**
 *  | A GenericSpine is a universal representation of an arbitrary data
 *  | structure (that does not contain function arrows).
 */  
  var SString = (function () {
      function SString(value0) {
          this.value0 = value0;
      };
      SString.create = function (value0) {
          return new SString(value0);
      };
      return SString;
  })();

  /**
 *  | A GenericSpine is a universal representation of an arbitrary data
 *  | structure (that does not contain function arrows).
 */  
  var SChar = (function () {
      function SChar(value0) {
          this.value0 = value0;
      };
      SChar.create = function (value0) {
          return new SChar(value0);
      };
      return SChar;
  })();

  /**
 *  | A GenericSpine is a universal representation of an arbitrary data
 *  | structure (that does not contain function arrows).
 */  
  var SArray = (function () {
      function SArray(value0) {
          this.value0 = value0;
      };
      SArray.create = function (value0) {
          return new SArray(value0);
      };
      return SArray;
  })();

  /**
 *  | A GenericSpine is a universal representation of an arbitrary data
 *  | structure (that does not contain function arrows).
 */  
  var SUnit = (function () {
      function SUnit() {

      };
      SUnit.value = new SUnit();
      return SUnit;
  })();

  /**
 *  | A GenericSignature is a universal representation of the structure of an
 *  | arbitrary data structure (that does not contain function arrows).
 */  
  var SigProd = (function () {
      function SigProd(value0, value1) {
          this.value0 = value0;
          this.value1 = value1;
      };
      SigProd.create = function (value0) {
          return function (value1) {
              return new SigProd(value0, value1);
          };
      };
      return SigProd;
  })();

  /**
 *  | A GenericSignature is a universal representation of the structure of an
 *  | arbitrary data structure (that does not contain function arrows).
 */  
  var SigRecord = (function () {
      function SigRecord(value0) {
          this.value0 = value0;
      };
      SigRecord.create = function (value0) {
          return new SigRecord(value0);
      };
      return SigRecord;
  })();

  /**
 *  | A GenericSignature is a universal representation of the structure of an
 *  | arbitrary data structure (that does not contain function arrows).
 */  
  var SigNumber = (function () {
      function SigNumber() {

      };
      SigNumber.value = new SigNumber();
      return SigNumber;
  })();

  /**
 *  | A GenericSignature is a universal representation of the structure of an
 *  | arbitrary data structure (that does not contain function arrows).
 */  
  var SigBoolean = (function () {
      function SigBoolean() {

      };
      SigBoolean.value = new SigBoolean();
      return SigBoolean;
  })();

  /**
 *  | A GenericSignature is a universal representation of the structure of an
 *  | arbitrary data structure (that does not contain function arrows).
 */  
  var SigInt = (function () {
      function SigInt() {

      };
      SigInt.value = new SigInt();
      return SigInt;
  })();

  /**
 *  | A GenericSignature is a universal representation of the structure of an
 *  | arbitrary data structure (that does not contain function arrows).
 */  
  var SigString = (function () {
      function SigString() {

      };
      SigString.value = new SigString();
      return SigString;
  })();

  /**
 *  | A GenericSignature is a universal representation of the structure of an
 *  | arbitrary data structure (that does not contain function arrows).
 */  
  var SigChar = (function () {
      function SigChar() {

      };
      SigChar.value = new SigChar();
      return SigChar;
  })();

  /**
 *  | A GenericSignature is a universal representation of the structure of an
 *  | arbitrary data structure (that does not contain function arrows).
 */  
  var SigArray = (function () {
      function SigArray(value0) {
          this.value0 = value0;
      };
      SigArray.create = function (value0) {
          return new SigArray(value0);
      };
      return SigArray;
  })();

  /**
 *  | A GenericSignature is a universal representation of the structure of an
 *  | arbitrary data structure (that does not contain function arrows).
 */  
  var SigUnit = (function () {
      function SigUnit() {

      };
      SigUnit.value = new SigUnit();
      return SigUnit;
  })();

  /**
 *  | The Generic typeclass provides methods for sending data to/from spine
 *  | representations, as well as querying about the signatures of spine
 *  | representations.
 *  |
 *  | For standard data structures, you can simply write
 *  | `derive instance genericFoo :: Generic Foo` in the module they are
 *  | declared, and the instance methods will be filled in for you.
 */  
  var Generic = function (fromSpine, toSignature, toSpine) {
      this.fromSpine = fromSpine;
      this.toSignature = toSignature;
      this.toSpine = toSpine;
  };

  /**
 *  | The Generic typeclass provides methods for sending data to/from spine
 *  | representations, as well as querying about the signatures of spine
 *  | representations.
 *  |
 *  | For standard data structures, you can simply write
 *  | `derive instance genericFoo :: Generic Foo` in the module they are
 *  | declared, and the instance methods will be filled in for you.
 */  
  var toSpine = function (dict) {
      return dict.toSpine;
  };

  /**
 *  | The Generic typeclass provides methods for sending data to/from spine
 *  | representations, as well as querying about the signatures of spine
 *  | representations.
 *  |
 *  | For standard data structures, you can simply write
 *  | `derive instance genericFoo :: Generic Foo` in the module they are
 *  | declared, and the instance methods will be filled in for you.
 */  
  var toSignature = function (dict) {
      return dict.toSignature;
  };

  /**
 *  We use this instead of the default Show Array instance to avoid escaping
 *  strings twice.
 */  
  var showArray = function (f) {
      return function (xs) {
          return "[ " + (Data_Foldable.intercalate(Data_Foldable.foldableArray)(Data_Monoid.monoidString)(", ")(Data_Functor.map(Data_Functor.functorArray)(f)(xs)) + " ]");
      };
  };
  var orderingToInt = function (v) {
      if (v instanceof Data_Ordering.EQ) {
          return 0;
      };
      if (v instanceof Data_Ordering.LT) {
          return 1;
      };
      if (v instanceof Data_Ordering.GT) {
          return -1;
      };
      throw new Error("Failed pattern match at Data.Generic line 467, column 17 - line 470, column 10: " + [ v.constructor.name ]);
  };
  var genericUnit = new Generic(function (v) {
      if (v instanceof SUnit) {
          return new Data_Maybe.Just(Data_Unit.unit);
      };
      return Data_Maybe.Nothing.value;
  }, function (v) {
      return SigUnit.value;
  }, function (v) {
      return SUnit.value;
  });
  var genericString = new Generic(function (v) {
      if (v instanceof SString) {
          return new Data_Maybe.Just(v.value0);
      };
      return Data_Maybe.Nothing.value;
  }, function (v) {
      return SigString.value;
  }, SString.create);
  var genericOrdering = new Generic(function (v) {
      if (v instanceof SProd && (v.value0 === "Data.Ordering.LT" && v.value1.length === 0)) {
          return new Data_Maybe.Just(Data_Ordering.LT.value);
      };
      if (v instanceof SProd && (v.value0 === "Data.Ordering.EQ" && v.value1.length === 0)) {
          return new Data_Maybe.Just(Data_Ordering.EQ.value);
      };
      if (v instanceof SProd && (v.value0 === "Data.Ordering.GT" && v.value1.length === 0)) {
          return new Data_Maybe.Just(Data_Ordering.GT.value);
      };
      return Data_Maybe.Nothing.value;
  }, function (v) {
      return new SigProd("Data.Ordering.Ordering", [ {
          sigConstructor: "Data.Ordering.LT", 
          sigValues: [  ]
      }, {
          sigConstructor: "Data.Ordering.EQ", 
          sigValues: [  ]
      }, {
          sigConstructor: "Data.Ordering.GT", 
          sigValues: [  ]
      } ]);
  }, function (v) {
      if (v instanceof Data_Ordering.LT) {
          return new SProd("Data.Ordering.LT", [  ]);
      };
      if (v instanceof Data_Ordering.EQ) {
          return new SProd("Data.Ordering.EQ", [  ]);
      };
      if (v instanceof Data_Ordering.GT) {
          return new SProd("Data.Ordering.GT", [  ]);
      };
      throw new Error("Failed pattern match at Data.Generic line 168, column 13 - line 171, column 38: " + [ v.constructor.name ]);
  });
  var genericNumber = new Generic(function (v) {
      if (v instanceof SNumber) {
          return new Data_Maybe.Just(v.value0);
      };
      return Data_Maybe.Nothing.value;
  }, function (v) {
      return SigNumber.value;
  }, SNumber.create);
  var genericInt = new Generic(function (v) {
      if (v instanceof SInt) {
          return new Data_Maybe.Just(v.value0);
      };
      return Data_Maybe.Nothing.value;
  }, function (v) {
      return SigInt.value;
  }, SInt.create);
  var genericChar = new Generic(function (v) {
      if (v instanceof SChar) {
          return new Data_Maybe.Just(v.value0);
      };
      return Data_Maybe.Nothing.value;
  }, function (v) {
      return SigChar.value;
  }, SChar.create);
  var genericBool = new Generic(function (v) {
      if (v instanceof SBoolean) {
          return new Data_Maybe.Just(v.value0);
      };
      return Data_Maybe.Nothing.value;
  }, function (v) {
      return SigBoolean.value;
  }, SBoolean.create);

  /**
 *  | The Generic typeclass provides methods for sending data to/from spine
 *  | representations, as well as querying about the signatures of spine
 *  | representations.
 *  |
 *  | For standard data structures, you can simply write
 *  | `derive instance genericFoo :: Generic Foo` in the module they are
 *  | declared, and the instance methods will be filled in for you.
 */  
  var fromSpine = function (dict) {
      return dict.fromSpine;
  };
  var force = function (f) {
      return f(Data_Unit.unit);
  };
  var genericArray = function (dictGeneric) {
      return new Generic(function (v) {
          if (v instanceof SArray) {
              return Data_Traversable.traverse(Data_Traversable.traversableArray)(Data_Maybe.applicativeMaybe)(function ($272) {
                  return fromSpine(dictGeneric)(force($272));
              })(v.value0);
          };
          return Data_Maybe.Nothing.value;
      }, function (x) {
          var lowerProxy = function (v) {
              return (Type_Proxy["Proxy"]).value;
          };
          return new SigArray(function (v) {
              return toSignature(dictGeneric)(lowerProxy(x));
          });
      }, function ($273) {
          return SArray.create(Data_Functor.map(Data_Functor.functorArray)(function (x) {
              return function (v) {
                  return toSpine(dictGeneric)(x);
              };
          })($273));
      });
  };
  var genericEither = function (dictGeneric) {
      return function (dictGeneric1) {
          return new Generic(function (v) {
              if (v instanceof SProd && (v.value0 === "Data.Either.Left" && v.value1.length === 1)) {
                  return Data_Functor.map(Data_Maybe.functorMaybe)(Data_Either.Left.create)(fromSpine(dictGeneric)(force(v.value1[0])));
              };
              if (v instanceof SProd && (v.value0 === "Data.Either.Right" && v.value1.length === 1)) {
                  return Data_Functor.map(Data_Maybe.functorMaybe)(Data_Either.Right.create)(fromSpine(dictGeneric1)(force(v.value1[0])));
              };
              return Data_Maybe.Nothing.value;
          }, function (x) {
              var rproxy = function (v) {
                  return (Type_Proxy["Proxy"]).value;
              };
              var lproxy = function (v) {
                  return (Type_Proxy["Proxy"]).value;
              };
              return new SigProd("Data.Either.Either", [ {
                  sigConstructor: "Data.Either.Left", 
                  sigValues: [ function (v) {
                      return toSignature(dictGeneric)(lproxy(x));
                  } ]
              }, {
                  sigConstructor: "Data.Either.Right", 
                  sigValues: [ function (v) {
                      return toSignature(dictGeneric1)(rproxy(x));
                  } ]
              } ]);
          }, function (v) {
              if (v instanceof Data_Either.Left) {
                  return new SProd("Data.Either.Left", [ function (v1) {
                      return toSpine(dictGeneric)(v.value0);
                  } ]);
              };
              if (v instanceof Data_Either.Right) {
                  return new SProd("Data.Either.Right", [ function (v1) {
                      return toSpine(dictGeneric1)(v.value0);
                  } ]);
              };
              throw new Error("Failed pattern match at Data.Generic line 131, column 3 - line 131, column 64: " + [ v.constructor.name ]);
          });
      };
  };
  var genericIdentity = function (dictGeneric) {
      return new Generic(function (v) {
          if (v instanceof SProd && (v.value0 === "Data.Identity.Identity" && v.value1.length === 1)) {
              return Data_Functor.map(Data_Maybe.functorMaybe)(Data_Identity.Identity)(fromSpine(dictGeneric)(force(v.value1[0])));
          };
          return Data_Maybe.Nothing.value;
      }, function (x) {
          var iproxy = function (v) {
              return (Type_Proxy["Proxy"]).value;
          };
          return new SigProd("Data.Identity.Identity", [ {
              sigConstructor: "Data.Identity.Identity", 
              sigValues: [ function (v) {
                  return toSignature(dictGeneric)(iproxy(x));
              } ]
          } ]);
      }, function (v) {
          return new SProd("Data.Identity.Identity", [ function (v1) {
              return toSpine(dictGeneric)(v);
          } ]);
      });
  };
  var genericMaybe = function (dictGeneric) {
      return new Generic(function (v) {
          if (v instanceof SProd && (v.value0 === "Data.Maybe.Just" && v.value1.length === 1)) {
              return Data_Functor.map(Data_Maybe.functorMaybe)(Data_Maybe.Just.create)(fromSpine(dictGeneric)(force(v.value1[0])));
          };
          if (v instanceof SProd && (v.value0 === "Data.Maybe.Nothing" && v.value1.length === 0)) {
              return Control_Applicative.pure(Data_Maybe.applicativeMaybe)(Data_Maybe.Nothing.value);
          };
          return Data_Maybe.Nothing.value;
      }, function (x) {
          var mbProxy = function (v) {
              return (Type_Proxy["Proxy"]).value;
          };
          return new SigProd("Data.Maybe.Maybe", [ {
              sigConstructor: "Data.Maybe.Just", 
              sigValues: [ function (v) {
                  return toSignature(dictGeneric)(mbProxy(x));
              } ]
          }, {
              sigConstructor: "Data.Maybe.Nothing", 
              sigValues: [  ]
          } ]);
      }, function (v) {
          if (v instanceof Data_Maybe.Just) {
              return new SProd("Data.Maybe.Just", [ function (v1) {
                  return toSpine(dictGeneric)(v.value0);
              } ]);
          };
          if (v instanceof Data_Maybe.Nothing) {
              return new SProd("Data.Maybe.Nothing", [  ]);
          };
          throw new Error("Failed pattern match at Data.Generic line 111, column 3 - line 111, column 63: " + [ v.constructor.name ]);
      });
  };
  var genericNonEmpty = function (dictGeneric) {
      return function (dictGeneric1) {
          return new Generic(function (v) {
              if (v instanceof SProd && (v.value0 === "Data.NonEmpty.NonEmpty" && v.value1.length === 2)) {
                  return Control_Apply.apply(Data_Maybe.applyMaybe)(Data_Functor.map(Data_Maybe.functorMaybe)(Data_NonEmpty.NonEmpty.create)(fromSpine(dictGeneric1)(force(v.value1[0]))))(fromSpine(dictGeneric)(force(v.value1[1])));
              };
              return Data_Maybe.Nothing.value;
          }, function (x) {
              var tailProxy = function (v) {
                  return (Type_Proxy["Proxy"]).value;
              };
              var headProxy = function (v) {
                  return (Type_Proxy["Proxy"]).value;
              };
              return new SigProd("Data.NonEmpty.NonEmpty", [ {
                  sigConstructor: "Data.NonEmpty.NonEmpty", 
                  sigValues: [ function (v) {
                      return toSignature(dictGeneric1)(headProxy(x));
                  }, function (v) {
                      return toSignature(dictGeneric)(tailProxy(x));
                  } ]
              } ]);
          }, function (v) {
              return new SProd("Data.NonEmpty.NonEmpty", [ function (v1) {
                  return toSpine(dictGeneric1)(v.value0);
              }, function (v1) {
                  return toSpine(dictGeneric)(v.value1);
              } ]);
          });
      };
  };
  var genericShowPrec = function (v) {
      return function (v1) {
          if (v1 instanceof SProd) {
              if (Data_Array["null"](v1.value1)) {
                  return v1.value0;
              };
              if (Data_Boolean.otherwise) {
                  var showParen = function (v2) {
                      return function (x) {
                          if (!v2) {
                              return x;
                          };
                          if (v2) {
                              return "(" + (x + ")");
                          };
                          throw new Error("Failed pattern match at Data.Generic line 396, column 7 - line 396, column 28: " + [ v2.constructor.name, x.constructor.name ]);
                      };
                  };
                  return showParen(v > 10)(v1.value0 + (" " + Data_String.joinWith(" ")(Data_Functor.map(Data_Functor.functorArray)(function (x) {
                      return genericShowPrec(11)(force(x));
                  })(v1.value1))));
              };
          };
          if (v1 instanceof SRecord) {
              var showLabelPart = function (x) {
                  return x.recLabel + (": " + genericShowPrec(0)(force(x.recValue)));
              };
              return "{" + (Data_String.joinWith(", ")(Data_Functor.map(Data_Functor.functorArray)(showLabelPart)(v1.value0)) + "}");
          };
          if (v1 instanceof SBoolean) {
              return Data_Show.show(Data_Show.showBoolean)(v1.value0);
          };
          if (v1 instanceof SInt) {
              return Data_Show.show(Data_Show.showInt)(v1.value0);
          };
          if (v1 instanceof SNumber) {
              return Data_Show.show(Data_Show.showNumber)(v1.value0);
          };
          if (v1 instanceof SString) {
              return Data_Show.show(Data_Show.showString)(v1.value0);
          };
          if (v1 instanceof SChar) {
              return Data_Show.show(Data_Show.showChar)(v1.value0);
          };
          if (v1 instanceof SArray) {
              return "[" + (Data_String.joinWith(", ")(Data_Functor.map(Data_Functor.functorArray)(function (x) {
                  return genericShowPrec(0)(force(x));
              })(v1.value0)) + "]");
          };
          if (v1 instanceof SUnit) {
              return "unit";
          };
          throw new Error("Failed pattern match at Data.Generic line 390, column 1 - line 398, column 1: " + [ v.constructor.name, v1.constructor.name ]);
      };
  };

  /**
 *  ## Generic Functions
 *  | This function can be used as the default instance for Show for any
 *  | instance of Generic
 */  
  var gShow = function (dictGeneric) {
      return function ($274) {
          return genericShowPrec(0)(toSpine(dictGeneric)($274));
      };
  };
  var genericTuple = function (dictGeneric) {
      return function (dictGeneric1) {
          return new Generic(function (v) {
              if (v instanceof SProd && (v.value0 === "Data.Tuple.Tuple" && v.value1.length === 2)) {
                  return Control_Apply.apply(Data_Maybe.applyMaybe)(Data_Functor.map(Data_Maybe.functorMaybe)(Data_Tuple.Tuple.create)(fromSpine(dictGeneric)(force(v.value1[0]))))(fromSpine(dictGeneric1)(force(v.value1[1])));
              };
              return Data_Maybe.Nothing.value;
          }, function (x) {
              var sndProxy = function (v) {
                  return (Type_Proxy["Proxy"]).value;
              };
              var fstProxy = function (v) {
                  return (Type_Proxy["Proxy"]).value;
              };
              return new SigProd("Data.Tuple.Tuple", [ {
                  sigConstructor: "Data.Tuple.Tuple", 
                  sigValues: [ function (v) {
                      return toSignature(dictGeneric)(fstProxy(x));
                  }, function (v) {
                      return toSignature(dictGeneric1)(sndProxy(x));
                  } ]
              } ]);
          }, function (v) {
              return new SProd("Data.Tuple.Tuple", [ function (v1) {
                  return toSpine(dictGeneric)(v.value0);
              }, function (v1) {
                  return toSpine(dictGeneric1)(v.value1);
              } ]);
          });
      };
  };
  var isValidSpine = function (v) {
      return function (v1) {
          if (v instanceof SigBoolean && v1 instanceof SBoolean) {
              return true;
          };
          if (v instanceof SigNumber && v1 instanceof SNumber) {
              return true;
          };
          if (v instanceof SigInt && v1 instanceof SInt) {
              return true;
          };
          if (v instanceof SigString && v1 instanceof SString) {
              return true;
          };
          if (v instanceof SigChar && v1 instanceof SChar) {
              return true;
          };
          if (v instanceof SigArray && v1 instanceof SArray) {
              return Data_Foldable.all(Data_Foldable.foldableArray)(Data_HeytingAlgebra.heytingAlgebraBoolean)(function ($275) {
                  return isValidSpine(force(v.value0))(force($275));
              })(v1.value0);
          };
          if (v instanceof SigProd && v1 instanceof SProd) {
              var $182 = Data_Foldable.find(Data_Foldable.foldableArray)(function (alt) {
                  return alt.sigConstructor === v1.value0;
              })(v.value1);
              if ($182 instanceof Data_Maybe.Nothing) {
                  return false;
              };
              if ($182 instanceof Data_Maybe.Just) {
                  return Data_Foldable.and(Data_Foldable.foldableArray)(Data_HeytingAlgebra.heytingAlgebraBoolean)(Data_Array.zipWith(function (sig) {
                      return function (spine) {
                          return isValidSpine(force(sig))(force(spine));
                      };
                  })($182.value0.sigValues)(v1.value1));
              };
              throw new Error("Failed pattern match at Data.Generic line 367, column 3 - line 373, column 15: " + [ $182.constructor.name ]);
          };
          if (v instanceof SigRecord && v1 instanceof SRecord) {
              return Data_Foldable.and(Data_Foldable.foldableArray)(Data_HeytingAlgebra.heytingAlgebraBoolean)(Data_Array.zipWith(function (sig) {
                  return function (val) {
                      return isValidSpine(force(sig.recValue))(force(val.recValue));
                  };
              })(Data_Array.sortBy(function (a) {
                  return function (b) {
                      return Data_Ord.compare(Data_Ord.ordString)(a.recLabel)(b.recLabel);
                  };
              })(v.value0))(Data_Array.sortBy(function (a) {
                  return function (b) {
                      return Data_Ord.compare(Data_Ord.ordString)(a.recLabel)(b.recLabel);
                  };
              })(v1.value0)));
          };
          if (v instanceof SigUnit && v1 instanceof SUnit) {
              return true;
          };
          return false;
      };
  };
  var showSignature = function (sig) {
      var needsParen = function (s) {
          if (s instanceof SigProd) {
              return true;
          };
          if (s instanceof SigRecord) {
              return true;
          };
          if (s instanceof SigNumber) {
              return false;
          };
          if (s instanceof SigBoolean) {
              return false;
          };
          if (s instanceof SigInt) {
              return false;
          };
          if (s instanceof SigString) {
              return false;
          };
          if (s instanceof SigChar) {
              return false;
          };
          if (s instanceof SigArray) {
              return true;
          };
          if (s instanceof SigUnit) {
              return false;
          };
          throw new Error("Failed pattern match at Data.Generic line 333, column 18 - line 342, column 21: " + [ s.constructor.name ]);
      };
      var paren = function (s) {
          if (needsParen(s)) {
              return "(" + (showSignature(s) + ")");
          };
          if (Data_Boolean.otherwise) {
              return showSignature(s);
          };
          throw new Error("Failed pattern match at Data.Generic line 315, column 1 - line 342, column 21: " + [ s.constructor.name ]);
      };
      return Data_Foldable.fold(Data_Foldable.foldableArray)(Data_Monoid.monoidString)((function () {
          if (sig instanceof SigProd) {
              return [ "SigProd ", Data_Show.show(Data_Show.showString)(sig.value0), " ", showArray(showDataConstructor)(sig.value1) ];
          };
          if (sig instanceof SigRecord) {
              return [ "SigRecord ", showArray(showLabel)(sig.value0) ];
          };
          if (sig instanceof SigNumber) {
              return [ "SigNumber" ];
          };
          if (sig instanceof SigBoolean) {
              return [ "SigBoolean" ];
          };
          if (sig instanceof SigInt) {
              return [ "SigInt" ];
          };
          if (sig instanceof SigString) {
              return [ "SigString" ];
          };
          if (sig instanceof SigChar) {
              return [ "SigChar" ];
          };
          if (sig instanceof SigArray) {
              return [ "SigArray ", paren(force(sig.value0)) ];
          };
          if (sig instanceof SigUnit) {
              return [ "SigUnit" ];
          };
          throw new Error("Failed pattern match at Data.Generic line 316, column 10 - line 326, column 27: " + [ sig.constructor.name ]);
      })());
  };
  var showLabel = function (l) {
      return "{ recLabel: " + (Data_Show.show(Data_Show.showString)(l.recLabel) + (", recValue: " + (showSignature(force(l.recValue)) + " }")));
  };
  var showDataConstructor = function (dc) {
      return "{ sigConstructor: " + (Data_Show.show(Data_Show.showString)(dc.sigConstructor) + (", sigValues: " + (showArray(function ($276) {
          return showSignature(force($276));
      })(dc.sigValues) + "}")));
  };
  var showGenericSignature = new Data_Show.Show(showSignature);
  var eqThunk = function (dictEq) {
      return function (x) {
          return function (y) {
              return Data_Eq.eq(dictEq)(force(x))(force(y));
          };
      };
  };
  var eqRecordSigs = function (dictEq) {
      return function (arr1) {
          return function (arr2) {
              var labelCompare = function (r1) {
                  return function (r2) {
                      return Data_Ord.compare(Data_Ord.ordString)(r1.recLabel)(r2.recLabel);
                  };
              };
              var sorted1 = Data_Array.sortBy(labelCompare)(arr1);
              var sorted2 = Data_Array.sortBy(labelCompare)(arr2);
              var doCmp = function (x) {
                  return function (y) {
                      return x.recLabel === y.recLabel && Data_Eq.eq(dictEq)(force(x.recValue))(force(y.recValue));
                  };
              };
              return Data_Array.length(arr1) === Data_Array.length(arr2) && $foreign.zipAll(doCmp)(sorted1)(sorted2);
          };
      };
  };
  var eqGenericSpine = new Data_Eq.Eq(function (v) {
      return function (v1) {
          if (v instanceof SProd && v1 instanceof SProd) {
              return v.value0 === v1.value0 && (Data_Array.length(v.value1) === Data_Array.length(v1.value1) && $foreign.zipAll(eqThunk(eqGenericSpine))(v.value1)(v1.value1));
          };
          if (v instanceof SRecord && v1 instanceof SRecord) {
              return eqRecordSigs(eqGenericSpine)(v.value0)(v1.value0);
          };
          if (v instanceof SNumber && v1 instanceof SNumber) {
              return v.value0 === v1.value0;
          };
          if (v instanceof SBoolean && v1 instanceof SBoolean) {
              return v.value0 === v1.value0;
          };
          if (v instanceof SInt && v1 instanceof SInt) {
              return v.value0 === v1.value0;
          };
          if (v instanceof SString && v1 instanceof SString) {
              return v.value0 === v1.value0;
          };
          if (v instanceof SChar && v1 instanceof SChar) {
              return v.value0 === v1.value0;
          };
          if (v instanceof SArray && v1 instanceof SArray) {
              return Data_Array.length(v.value0) === Data_Array.length(v1.value0) && $foreign.zipAll(eqThunk(eqGenericSpine))(v.value0)(v1.value0);
          };
          if (v instanceof SUnit && v1 instanceof SUnit) {
              return true;
          };
          return false;
      };
  });

  /**
 *  | This function can be used as an implementation of the `eq` function of `Eq`
 *  | for any type with a `Generic` instance.
 *  |
 *  | **Note**: It is preferrable to use `derive instance` for `Eq` instances
 *  | rather than relying on `gEq`, where possible.
 */  
  var gEq = function (dictGeneric) {
      return function (x) {
          return function (y) {
              return Data_Eq.eq(eqGenericSpine)(toSpine(dictGeneric)(x))(toSpine(dictGeneric)(y));
          };
      };
  };
  var eqGenericSignature = new Data_Eq.Eq(function (v) {
      return function (v1) {
          if (v instanceof SigProd && v1 instanceof SigProd) {
              return v.value0 === v1.value0 && (Data_Array.length(v.value1) === Data_Array.length(v1.value1) && $foreign.zipAll(eqDataConstructor)(v.value1)(v1.value1));
          };
          if (v instanceof SigRecord && v1 instanceof SigRecord) {
              return eqRecordSigs(eqGenericSignature)(v.value0)(v1.value0);
          };
          if (v instanceof SigNumber && v1 instanceof SigNumber) {
              return true;
          };
          if (v instanceof SigBoolean && v1 instanceof SigBoolean) {
              return true;
          };
          if (v instanceof SigInt && v1 instanceof SigInt) {
              return true;
          };
          if (v instanceof SigString && v1 instanceof SigString) {
              return true;
          };
          if (v instanceof SigChar && v1 instanceof SigChar) {
              return true;
          };
          if (v instanceof SigArray && v1 instanceof SigArray) {
              return eqThunk(eqGenericSignature)(v.value0)(v1.value0);
          };
          if (v instanceof SigUnit && v1 instanceof SigUnit) {
              return true;
          };
          return false;
      };
  });
  var eqDataConstructor = function (p1) {
      return function (p2) {
          return p1.sigConstructor === p2.sigConstructor && $foreign.zipAll(eqThunk(eqGenericSignature))(p1.sigValues)(p2.sigValues);
      };
  };
  var compareThunk = function (dictOrd) {
      return function (x) {
          return function (y) {
              return orderingToInt(Data_Ord.compare(dictOrd)(force(x))(force(y)));
          };
      };
  };
  var ordGenericSpine = new Data_Ord.Ord(function () {
      return eqGenericSpine;
  }, function (v) {
      return function (v1) {
          if (v instanceof SProd && v1 instanceof SProd) {
              var $234 = Data_Ord.compare(Data_Ord.ordString)(v.value0)(v1.value0);
              if ($234 instanceof Data_Ordering.EQ) {
                  return Data_Ord.compare(Data_Ord.ordInt)(0)($foreign.zipCompare(compareThunk(ordGenericSpine))(v.value1)(v1.value1));
              };
              return $234;
          };
          if (v instanceof SProd) {
              return Data_Ordering.LT.value;
          };
          if (v1 instanceof SProd) {
              return Data_Ordering.GT.value;
          };
          if (v instanceof SRecord && v1 instanceof SRecord) {
              var go = function (x) {
                  return function (y) {
                      var $243 = Data_Ord.compare(Data_Ord.ordString)(x.recLabel)(y.recLabel);
                      if ($243 instanceof Data_Ordering.EQ) {
                          return orderingToInt(Data_Ord.compare(ordGenericSpine)(force(x.recValue))(force(y.recValue)));
                      };
                      return orderingToInt($243);
                  };
              };
              return Data_Ord.compare(Data_Ord.ordInt)(0)($foreign.zipCompare(go)(v.value0)(v1.value0));
          };
          if (v instanceof SRecord) {
              return Data_Ordering.LT.value;
          };
          if (v1 instanceof SRecord) {
              return Data_Ordering.GT.value;
          };
          if (v instanceof SInt && v1 instanceof SInt) {
              return Data_Ord.compare(Data_Ord.ordInt)(v.value0)(v1.value0);
          };
          if (v instanceof SInt) {
              return Data_Ordering.LT.value;
          };
          if (v1 instanceof SInt) {
              return Data_Ordering.GT.value;
          };
          if (v instanceof SBoolean && v1 instanceof SBoolean) {
              return Data_Ord.compare(Data_Ord.ordBoolean)(v.value0)(v1.value0);
          };
          if (v instanceof SBoolean) {
              return Data_Ordering.LT.value;
          };
          if (v1 instanceof SBoolean) {
              return Data_Ordering.GT.value;
          };
          if (v instanceof SNumber && v1 instanceof SNumber) {
              return Data_Ord.compare(Data_Ord.ordNumber)(v.value0)(v1.value0);
          };
          if (v instanceof SNumber) {
              return Data_Ordering.LT.value;
          };
          if (v1 instanceof SNumber) {
              return Data_Ordering.GT.value;
          };
          if (v instanceof SString && v1 instanceof SString) {
              return Data_Ord.compare(Data_Ord.ordString)(v.value0)(v1.value0);
          };
          if (v instanceof SString) {
              return Data_Ordering.LT.value;
          };
          if (v1 instanceof SString) {
              return Data_Ordering.GT.value;
          };
          if (v instanceof SChar && v1 instanceof SChar) {
              return Data_Ord.compare(Data_Ord.ordChar)(v.value0)(v1.value0);
          };
          if (v instanceof SChar) {
              return Data_Ordering.LT.value;
          };
          if (v1 instanceof SChar) {
              return Data_Ordering.GT.value;
          };
          if (v instanceof SArray && v1 instanceof SArray) {
              return Data_Ord.compare(Data_Ord.ordInt)(0)($foreign.zipCompare(compareThunk(ordGenericSpine))(v.value0)(v1.value0));
          };
          if (v instanceof SArray) {
              return Data_Ordering.LT.value;
          };
          if (v1 instanceof SArray) {
              return Data_Ordering.GT.value;
          };
          if (v instanceof SUnit && v1 instanceof SUnit) {
              return Data_Ordering.EQ.value;
          };
          throw new Error("Failed pattern match at Data.Generic line 234, column 3 - line 237, column 15: " + [ v.constructor.name, v1.constructor.name ]);
      };
  });

  /**
 *  | This function can be used as an implementation of the `compare` function
 *  | of `Ord` for any type with a `Generic` instance.
 *  |
 *  | **Note**: It is preferrable to use `derive instance` for `Ord` instances
 *  | rather than relying on `gCompare`, where possible.
 */  
  var gCompare = function (dictGeneric) {
      return function (x) {
          return function (y) {
              return Data_Ord.compare(ordGenericSpine)(toSpine(dictGeneric)(x))(toSpine(dictGeneric)(y));
          };
      };
  };
  exports["SigProd"] = SigProd;
  exports["SigRecord"] = SigRecord;
  exports["SigNumber"] = SigNumber;
  exports["SigBoolean"] = SigBoolean;
  exports["SigInt"] = SigInt;
  exports["SigString"] = SigString;
  exports["SigChar"] = SigChar;
  exports["SigArray"] = SigArray;
  exports["SigUnit"] = SigUnit;
  exports["SProd"] = SProd;
  exports["SRecord"] = SRecord;
  exports["SNumber"] = SNumber;
  exports["SBoolean"] = SBoolean;
  exports["SInt"] = SInt;
  exports["SString"] = SString;
  exports["SChar"] = SChar;
  exports["SArray"] = SArray;
  exports["SUnit"] = SUnit;
  exports["Generic"] = Generic;
  exports["fromSpine"] = fromSpine;
  exports["gCompare"] = gCompare;
  exports["gEq"] = gEq;
  exports["gShow"] = gShow;
  exports["isValidSpine"] = isValidSpine;
  exports["showDataConstructor"] = showDataConstructor;
  exports["showSignature"] = showSignature;
  exports["toSignature"] = toSignature;
  exports["toSpine"] = toSpine;
  exports["genericNumber"] = genericNumber;
  exports["genericInt"] = genericInt;
  exports["genericString"] = genericString;
  exports["genericChar"] = genericChar;
  exports["genericBool"] = genericBool;
  exports["genericArray"] = genericArray;
  exports["genericUnit"] = genericUnit;
  exports["genericTuple"] = genericTuple;
  exports["genericMaybe"] = genericMaybe;
  exports["genericEither"] = genericEither;
  exports["genericIdentity"] = genericIdentity;
  exports["genericOrdering"] = genericOrdering;
  exports["genericNonEmpty"] = genericNonEmpty;
  exports["eqGenericSpine"] = eqGenericSpine;
  exports["ordGenericSpine"] = ordGenericSpine;
  exports["eqGenericSignature"] = eqGenericSignature;
  exports["showGenericSignature"] = showGenericSignature;
})(PS["Data.Generic"] = PS["Data.Generic"] || {});
(function(exports) {
    "use strict";
  var Prelude = PS["Prelude"];
  var Control_Alt = PS["Control.Alt"];
  var Control_Alternative = PS["Control.Alternative"];
  var Control_Apply = PS["Control.Apply"];
  var Control_Comonad = PS["Control.Comonad"];
  var Control_Extend = PS["Control.Extend"];
  var Control_MonadPlus = PS["Control.MonadPlus"];
  var Control_MonadZero = PS["Control.MonadZero"];
  var Control_Plus = PS["Control.Plus"];
  var Data_Foldable = PS["Data.Foldable"];
  var Data_Generic = PS["Data.Generic"];
  var Data_Maybe = PS["Data.Maybe"];
  var Data_Monoid = PS["Data.Monoid"];
  var Data_Newtype = PS["Data.Newtype"];
  var Data_NonEmpty = PS["Data.NonEmpty"];
  var Data_Traversable = PS["Data.Traversable"];
  var Data_Tuple = PS["Data.Tuple"];
  var Data_Unfoldable = PS["Data.Unfoldable"];
  var Data_Unit = PS["Data.Unit"];
  var Data_Show = PS["Data.Show"];
  var Data_Semigroup = PS["Data.Semigroup"];
  var Data_Functor = PS["Data.Functor"];
  var Data_Eq = PS["Data.Eq"];
  var Data_Function = PS["Data.Function"];
  var Data_HeytingAlgebra = PS["Data.HeytingAlgebra"];
  var Data_Ord = PS["Data.Ord"];
  var Data_Ordering = PS["Data.Ordering"];
  var Control_Semigroupoid = PS["Control.Semigroupoid"];
  var Control_Applicative = PS["Control.Applicative"];
  var Control_Category = PS["Control.Category"];
  var Control_Bind = PS["Control.Bind"];
  var Control_Monad = PS["Control.Monad"];        
  var Nil = (function () {
      function Nil() {

      };
      Nil.value = new Nil();
      return Nil;
  })();
  var Cons = (function () {
      function Cons(value0, value1) {
          this.value0 = value0;
          this.value1 = value1;
      };
      Cons.create = function (value0) {
          return function (value1) {
              return new Cons(value0, value1);
          };
      };
      return Cons;
  })();
  var NonEmptyList = function (x) {
      return x;
  };
  var toList = function (v) {
      return new Cons(v.value0, v.value1);
  };
  var semigroupList = new Data_Semigroup.Semigroup(function (v) {
      return function (ys) {
          if (v instanceof Nil) {
              return ys;
          };
          if (v instanceof Cons) {
              return new Cons(v.value0, Data_Semigroup.append(semigroupList)(v.value1)(ys));
          };
          throw new Error("Failed pattern match at Data.List.Types line 53, column 3 - line 53, column 21: " + [ v.constructor.name, ys.constructor.name ]);
      };
  });
  var semigroupNonEmptyList = new Data_Semigroup.Semigroup(function (v) {
      return function (as$prime) {
          return new Data_NonEmpty.NonEmpty(v.value0, Data_Semigroup.append(semigroupList)(v.value1)(toList(as$prime)));
      };
  });
  var newtypeNonEmptyList = new Data_Newtype.Newtype(function (n) {
      return n;
  }, NonEmptyList);
  var monoidList = new Data_Monoid.Monoid(function () {
      return semigroupList;
  }, Nil.value);
  var genericList = function (dictGeneric) {
      return new Data_Generic.Generic(function (v) {
          if (v instanceof Data_Generic.SProd && (v.value0 === "Data.List.Types.Nil" && v.value1.length === 0)) {
              return new Data_Maybe.Just(Nil.value);
          };
          if (v instanceof Data_Generic.SProd && (v.value0 === "Data.List.Types.Cons" && v.value1.length === 2)) {
              return Control_Apply.apply(Data_Maybe.applyMaybe)(Control_Apply.apply(Data_Maybe.applyMaybe)(new Data_Maybe.Just(Cons.create))(Data_Generic.fromSpine(dictGeneric)(v.value1[0](Data_Unit.unit))))(Data_Generic.fromSpine(genericList(dictGeneric))(v.value1[1](Data_Unit.unit)));
          };
          return Data_Maybe.Nothing.value;
      }, function ($dollarq) {
          return new Data_Generic.SigProd("Data.List.Types.List", [ {
              sigConstructor: "Data.List.Types.Nil", 
              sigValues: [  ]
          }, {
              sigConstructor: "Data.List.Types.Cons", 
              sigValues: [ function ($dollarq1) {
                  return Data_Generic.toSignature(dictGeneric)(Data_Generic.anyProxy);
              }, function ($dollarq1) {
                  return Data_Generic.toSignature(genericList(dictGeneric))(Data_Generic.anyProxy);
              } ]
          } ]);
      }, function (v) {
          if (v instanceof Nil) {
              return new Data_Generic.SProd("Data.List.Types.Nil", [  ]);
          };
          if (v instanceof Cons) {
              return new Data_Generic.SProd("Data.List.Types.Cons", [ function ($dollarq) {
                  return Data_Generic.toSpine(dictGeneric)(v.value0);
              }, function ($dollarq) {
                  return Data_Generic.toSpine(genericList(dictGeneric))(v.value1);
              } ]);
          };
          throw new Error("Failed pattern match: " + [ v.constructor.name ]);
      });
  };
  var genericEmptyList = function (dictGeneric) {
      return Data_Generic.genericNonEmpty(genericList(dictGeneric))(dictGeneric);
  };
  var foldableList = new Data_Foldable.Foldable(function (dictMonoid) {
      return function (f) {
          return Data_Foldable.foldl(foldableList)(function (acc) {
              return function ($133) {
                  return Data_Semigroup.append(dictMonoid["__superclass_Data.Semigroup.Semigroup_0"]())(acc)(f($133));
              };
          })(Data_Monoid.mempty(dictMonoid));
      };
  }, function (f) {
      var go = function (__copy_b) {
          return function (__copy_v) {
              var b = __copy_b;
              var v = __copy_v;
              tco: while (true) {
                  if (v instanceof Nil) {
                      return b;
                  };
                  if (v instanceof Cons) {
                      var __tco_b = f(b)(v.value0);
                      var __tco_v = v.value1;
                      b = __tco_b;
                      v = __tco_v;
                      continue tco;
                  };
                  throw new Error("Failed pattern match at Data.List.Types line 67, column 3 - line 70, column 34: " + [ b.constructor.name, v.constructor.name ]);
              };
          };
      };
      return go;
  }, function (f) {
      return function (b) {
          return function (as) {
              var rev = function (__copy_acc) {
                  return function (__copy_v) {
                      var acc = __copy_acc;
                      var v = __copy_v;
                      tco: while (true) {
                          if (v instanceof Nil) {
                              return acc;
                          };
                          if (v instanceof Cons) {
                              var __tco_acc = new Cons(v.value0, acc);
                              var __tco_v = v.value1;
                              acc = __tco_acc;
                              v = __tco_v;
                              continue tco;
                          };
                          throw new Error("Failed pattern match at Data.List.Types line 63, column 3 - line 66, column 40: " + [ acc.constructor.name, v.constructor.name ]);
                      };
                  };
              };
              return Data_Foldable.foldl(foldableList)(Data_Function.flip(f))(b)(rev(Nil.value)(as));
          };
      };
  });
  var foldableNonEmptyList = Data_NonEmpty.foldableNonEmpty(foldableList);
  var functorList = new Data_Functor.Functor(function (f) {
      return Data_Foldable.foldr(foldableList)(function (x) {
          return function (acc) {
              return new Cons(f(x), acc);
          };
      })(Nil.value);
  });
  var functorNonEmptyList = Data_NonEmpty.functorNonEmpty(functorList);
  var showList = function (dictShow) {
      return new Data_Show.Show(function (v) {
          if (v instanceof Nil) {
              return "Nil";
          };
          return "(" + (Data_Foldable.intercalate(foldableList)(Data_Monoid.monoidString)(" : ")(Data_Functor.map(functorList)(Data_Show.show(dictShow))(v)) + " : Nil)");
      });
  };
  var showNonEmptyList = function (dictShow) {
      return new Data_Show.Show(function (v) {
          return "(NonEmptyList " + (Data_Show.show(Data_NonEmpty.showNonEmpty(dictShow)(showList(dictShow)))(v) + ")");
      });
  };
  var traversableList = new Data_Traversable.Traversable(function () {
      return foldableList;
  }, function () {
      return functorList;
  }, function (dictApplicative) {
      return Data_Traversable.traverse(traversableList)(dictApplicative)(Control_Category.id(Control_Category.categoryFn));
  }, function (dictApplicative) {
      return function (f) {
          return function ($134) {
              return Data_Functor.map((dictApplicative["__superclass_Control.Apply.Apply_0"]())["__superclass_Data.Functor.Functor_0"]())(Data_Foldable.foldl(foldableList)(Data_Function.flip(Cons.create))(Nil.value))(Data_Foldable.foldl(foldableList)(function (acc) {
                  return function ($135) {
                      return Control_Apply.lift2(dictApplicative["__superclass_Control.Apply.Apply_0"]())(Data_Function.flip(Cons.create))(acc)(f($135));
                  };
              })(Control_Applicative.pure(dictApplicative)(Nil.value))($134));
          };
      };
  });
  var traversableNonEmptyList = Data_NonEmpty.traversableNonEmpty(traversableList);
  var unfoldableList = new Data_Unfoldable.Unfoldable(function (f) {
      return function (b) {
          var go = function (__copy_source) {
              return function (__copy_memo) {
                  var source = __copy_source;
                  var memo = __copy_memo;
                  tco: while (true) {
                      var $75 = f(source);
                      if ($75 instanceof Data_Maybe.Nothing) {
                          return Data_Foldable.foldl(foldableList)(Data_Function.flip(Cons.create))(Nil.value)(memo);
                      };
                      if ($75 instanceof Data_Maybe.Just) {
                          var __tco_memo = new Cons($75.value0.value0, memo);
                          source = $75.value0.value1;
                          memo = __tco_memo;
                          continue tco;
                      };
                      throw new Error("Failed pattern match at Data.List.Types line 76, column 24 - line 78, column 54: " + [ $75.constructor.name ]);
                  };
              };
          };
          return go(b)(Nil.value);
      };
  });
  var extendNonEmptyList = new Control_Extend.Extend(function () {
      return functorNonEmptyList;
  }, function (f) {
      return function (v) {
          var go = function (a) {
              return function (v1) {
                  return {
                      val: new Cons(f(new Data_NonEmpty.NonEmpty(a, v1.acc)), v1.val), 
                      acc: new Cons(a, v1.acc)
                  };
              };
          };
          return new Data_NonEmpty.NonEmpty(f(v), (Data_Foldable.foldr(foldableList)(go)({
              val: Nil.value, 
              acc: Nil.value
          })(v.value1)).val);
      };
  });
  var extendList = new Control_Extend.Extend(function () {
      return functorList;
  }, function (f) {
      return function (v) {
          if (v instanceof Nil) {
              return Nil.value;
          };
          if (v instanceof Cons) {
              var go = function (a1) {
                  return function (v1) {
                      var acc$prime = new Cons(a1, v1.acc);
                      return {
                          val: new Cons(f(acc$prime), v1.val), 
                          acc: acc$prime
                      };
                  };
              };
              return new Cons(f(v), (Data_Foldable.foldr(foldableList)(go)({
                  val: Nil.value, 
                  acc: Nil.value
              })(v.value1)).val);
          };
          throw new Error("Failed pattern match at Data.List.Types line 110, column 3 - line 110, column 21: " + [ f.constructor.name, v.constructor.name ]);
      };
  });
  var eqList = function (dictEq) {
      return new Data_Eq.Eq(function (xs) {
          return function (ys) {
              var go = function (__copy_v) {
                  return function (__copy_v1) {
                      return function (__copy_v2) {
                          var v = __copy_v;
                          var v1 = __copy_v1;
                          var v2 = __copy_v2;
                          tco: while (true) {
                              if (!v2) {
                                  return false;
                              };
                              if (v instanceof Nil && v1 instanceof Nil) {
                                  return v2;
                              };
                              if (v instanceof Cons && v1 instanceof Cons) {
                                  var __tco_v = v.value1;
                                  var __tco_v1 = v1.value1;
                                  var __tco_v2 = v2 && Data_Eq.eq(dictEq)(v1.value0)(v.value0);
                                  v = __tco_v;
                                  v1 = __tco_v1;
                                  v2 = __tco_v2;
                                  continue tco;
                              };
                              return false;
                          };
                      };
                  };
              };
              return go(xs)(ys)(true);
          };
      });
  };
  var eqNonEmptyList = function (dictEq) {
      return Data_NonEmpty.eqNonEmpty(dictEq)(eqList(dictEq));
  };
  var ordList = function (dictOrd) {
      return new Data_Ord.Ord(function () {
          return eqList(dictOrd["__superclass_Data.Eq.Eq_0"]());
      }, function (xs) {
          return function (ys) {
              var go = function (__copy_v) {
                  return function (__copy_v1) {
                      var v = __copy_v;
                      var v1 = __copy_v1;
                      tco: while (true) {
                          if (v instanceof Nil && v1 instanceof Nil) {
                              return Data_Ordering.EQ.value;
                          };
                          if (v instanceof Nil) {
                              return Data_Ordering.LT.value;
                          };
                          if (v1 instanceof Nil) {
                              return Data_Ordering.GT.value;
                          };
                          if (v instanceof Cons && v1 instanceof Cons) {
                              var $104 = Data_Ord.compare(dictOrd)(v.value0)(v1.value0);
                              if ($104 instanceof Data_Ordering.EQ) {
                                  var __tco_v = v.value1;
                                  var __tco_v1 = v1.value1;
                                  v = __tco_v;
                                  v1 = __tco_v1;
                                  continue tco;
                              };
                              return $104;
                          };
                          throw new Error("Failed pattern match at Data.List.Types line 42, column 3 - line 50, column 23: " + [ v.constructor.name, v1.constructor.name ]);
                      };
                  };
              };
              return go(xs)(ys);
          };
      });
  };
  var ordNonEmptyList = function (dictOrd) {
      return Data_NonEmpty.ordNonEmpty(dictOrd)(ordList(dictOrd));
  };
  var comonadNonEmptyList = new Control_Comonad.Comonad(function () {
      return extendNonEmptyList;
  }, function (v) {
      return v.value0;
  });
  var applyList = new Control_Apply.Apply(function () {
      return functorList;
  }, function (v) {
      return function (v1) {
          if (v instanceof Nil) {
              return Nil.value;
          };
          if (v instanceof Cons) {
              return Data_Semigroup.append(semigroupList)(Data_Functor.map(functorList)(v.value0)(v1))(Control_Apply.apply(applyList)(v.value1)(v1));
          };
          throw new Error("Failed pattern match at Data.List.Types line 85, column 3 - line 85, column 20: " + [ v.constructor.name, v1.constructor.name ]);
      };
  });
  var applyNonEmptyList = new Control_Apply.Apply(function () {
      return functorNonEmptyList;
  }, function (v) {
      return function (v1) {
          return new Data_NonEmpty.NonEmpty(v.value0(v1.value0), Data_Semigroup.append(semigroupList)(Control_Apply.apply(applyList)(v.value1)(new Cons(v1.value0, Nil.value)))(Control_Apply.apply(applyList)(new Cons(v.value0, v.value1))(v1.value1)));
      };
  });
  var bindList = new Control_Bind.Bind(function () {
      return applyList;
  }, function (v) {
      return function (v1) {
          if (v instanceof Nil) {
              return Nil.value;
          };
          if (v instanceof Cons) {
              return Data_Semigroup.append(semigroupList)(v1(v.value0))(Control_Bind.bind(bindList)(v.value1)(v1));
          };
          throw new Error("Failed pattern match at Data.List.Types line 92, column 3 - line 92, column 19: " + [ v.constructor.name, v1.constructor.name ]);
      };
  });
  var bindNonEmptyList = new Control_Bind.Bind(function () {
      return applyNonEmptyList;
  }, function (v) {
      return function (f) {
          var $128 = f(v.value0);
          return new Data_NonEmpty.NonEmpty($128.value0, Data_Semigroup.append(semigroupList)($128.value1)(Control_Bind.bind(bindList)(v.value1)(function ($136) {
              return toList(f($136));
          })));
      };
  });
  var applicativeList = new Control_Applicative.Applicative(function () {
      return applyList;
  }, function (a) {
      return new Cons(a, Nil.value);
  });
  var monadList = new Control_Monad.Monad(function () {
      return applicativeList;
  }, function () {
      return bindList;
  });
  var altNonEmptyList = new Control_Alt.Alt(function () {
      return functorNonEmptyList;
  }, Data_Semigroup.append(semigroupNonEmptyList));
  var altList = new Control_Alt.Alt(function () {
      return functorList;
  }, Data_Semigroup.append(semigroupList));
  var plusList = new Control_Plus.Plus(function () {
      return altList;
  }, Nil.value);
  var alternativeList = new Control_Alternative.Alternative(function () {
      return applicativeList;
  }, function () {
      return plusList;
  });
  var monadZeroList = new Control_MonadZero.MonadZero(function () {
      return alternativeList;
  }, function () {
      return monadList;
  });
  var monadPlusList = new Control_MonadPlus.MonadPlus(function () {
      return monadZeroList;
  });
  var applicativeNonEmptyList = new Control_Applicative.Applicative(function () {
      return applyNonEmptyList;
  }, function ($137) {
      return NonEmptyList(Data_NonEmpty.singleton(plusList)($137));
  });
  var monadNonEmptyList = new Control_Monad.Monad(function () {
      return applicativeNonEmptyList;
  }, function () {
      return bindNonEmptyList;
  });
  exports["Nil"] = Nil;
  exports["Cons"] = Cons;
  exports["NonEmptyList"] = NonEmptyList;
  exports["toList"] = toList;
  exports["genericList"] = genericList;
  exports["showList"] = showList;
  exports["eqList"] = eqList;
  exports["ordList"] = ordList;
  exports["semigroupList"] = semigroupList;
  exports["monoidList"] = monoidList;
  exports["functorList"] = functorList;
  exports["foldableList"] = foldableList;
  exports["unfoldableList"] = unfoldableList;
  exports["traversableList"] = traversableList;
  exports["applyList"] = applyList;
  exports["applicativeList"] = applicativeList;
  exports["bindList"] = bindList;
  exports["monadList"] = monadList;
  exports["altList"] = altList;
  exports["plusList"] = plusList;
  exports["alternativeList"] = alternativeList;
  exports["monadZeroList"] = monadZeroList;
  exports["monadPlusList"] = monadPlusList;
  exports["extendList"] = extendList;
  exports["newtypeNonEmptyList"] = newtypeNonEmptyList;
  exports["eqNonEmptyList"] = eqNonEmptyList;
  exports["ordNonEmptyList"] = ordNonEmptyList;
  exports["genericEmptyList"] = genericEmptyList;
  exports["showNonEmptyList"] = showNonEmptyList;
  exports["functorNonEmptyList"] = functorNonEmptyList;
  exports["applyNonEmptyList"] = applyNonEmptyList;
  exports["applicativeNonEmptyList"] = applicativeNonEmptyList;
  exports["bindNonEmptyList"] = bindNonEmptyList;
  exports["monadNonEmptyList"] = monadNonEmptyList;
  exports["altNonEmptyList"] = altNonEmptyList;
  exports["extendNonEmptyList"] = extendNonEmptyList;
  exports["comonadNonEmptyList"] = comonadNonEmptyList;
  exports["semigroupNonEmptyList"] = semigroupNonEmptyList;
  exports["foldableNonEmptyList"] = foldableNonEmptyList;
  exports["traversableNonEmptyList"] = traversableNonEmptyList;
})(PS["Data.List.Types"] = PS["Data.List.Types"] || {});
(function(exports) {
  
  /**
 *  | This module defines a type of _strict_ linked lists, and associated helper
 *  | functions and type class instances.
 *  |
 *  | _Note_: Depending on your use-case, you may prefer to use
 *  | `Data.Sequence` instead, which might give better performance for certain
 *  | use cases. This module is an improvement over `Data.Array` when working with
 *  | immutable lists of data in a purely-functional setting, but does not have
 *  | good random-access performance.
 */  
  "use strict";
  var Prelude = PS["Prelude"];
  var Control_Alt = PS["Control.Alt"];
  var Control_Alternative = PS["Control.Alternative"];
  var Control_Lazy = PS["Control.Lazy"];
  var Control_Monad_Rec_Class = PS["Control.Monad.Rec.Class"];
  var Data_Bifunctor = PS["Data.Bifunctor"];
  var Data_Foldable = PS["Data.Foldable"];
  var Data_List_Types = PS["Data.List.Types"];
  var Data_Maybe = PS["Data.Maybe"];
  var Data_NonEmpty = PS["Data.NonEmpty"];
  var Data_Traversable = PS["Data.Traversable"];
  var Data_Tuple = PS["Data.Tuple"];
  var Data_Unfoldable = PS["Data.Unfoldable"];
  var Data_Functor = PS["Data.Functor"];
  var Data_Ring = PS["Data.Ring"];
  var Data_Eq = PS["Data.Eq"];
  var Data_Ordering = PS["Data.Ordering"];
  var Data_Boolean = PS["Data.Boolean"];
  var Data_Function = PS["Data.Function"];
  var Control_Semigroupoid = PS["Control.Semigroupoid"];
  var Data_Ord = PS["Data.Ord"];
  var Data_Semiring = PS["Data.Semiring"];
  var Control_Bind = PS["Control.Bind"];
  var Control_Applicative = PS["Control.Applicative"];
  var Data_Unit = PS["Data.Unit"];
  var Control_Apply = PS["Control.Apply"];
  var Data_HeytingAlgebra = PS["Data.HeytingAlgebra"];
  var Data_Semigroup = PS["Data.Semigroup"];
  var Control_Category = PS["Control.Category"];        
  var updateAt = function (v) {
      return function (v1) {
          return function (v2) {
              if (v === 0 && v2 instanceof Data_List_Types.Cons) {
                  return new Data_Maybe.Just(new Data_List_Types.Cons(v1, v2.value1));
              };
              if (v2 instanceof Data_List_Types.Cons) {
                  return Data_Functor.map(Data_Maybe.functorMaybe)(function (v3) {
                      return new Data_List_Types.Cons(v2.value0, v3);
                  })(updateAt(v - 1)(v1)(v2.value1));
              };
              return Data_Maybe.Nothing.value;
          };
      };
  };

  /**
 *  | Transforms a list of pairs into a list of first components and a list of
 *  | second components.
 */  
  var unzip = Data_Foldable.foldr(Data_List_Types.foldableList)(function (v) {
      return function (v1) {
          return new Data_Tuple.Tuple(new Data_List_Types.Cons(v.value0, v1.value0), new Data_List_Types.Cons(v.value1, v1.value1));
      };
  })(new Data_Tuple.Tuple(Data_List_Types.Nil.value, Data_List_Types.Nil.value));

  /**
 *  | Break a list into its first element, and the remaining elements,
 *  | or `Nothing` if the list is empty.
 *  |
 *  | Running time: `O(1)`
 */  
  var uncons = function (v) {
      if (v instanceof Data_List_Types.Nil) {
          return Data_Maybe.Nothing.value;
      };
      if (v instanceof Data_List_Types.Cons) {
          return new Data_Maybe.Just({
              head: v.value0, 
              tail: v.value1
          });
      };
      throw new Error("Failed pattern match at Data.List line 257, column 1 - line 257, column 21: " + [ v.constructor.name ]);
  };

  /**
 *  | Convert a list into any unfoldable structure.
 *  |
 *  | Running time: `O(n)`
 */  
  var toUnfoldable = function (dictUnfoldable) {
      return Data_Unfoldable.unfoldr(dictUnfoldable)(function (xs) {
          return Data_Functor.map(Data_Maybe.functorMaybe)(function (rec) {
              return new Data_Tuple.Tuple(rec.head, rec.tail);
          })(uncons(xs));
      });
  };

  /**
 *  | Get all but the first element of a list, or `Nothing` if the list is empty.
 *  |
 *  | Running time: `O(1)`
 */  
  var tail = function (v) {
      if (v instanceof Data_List_Types.Nil) {
          return Data_Maybe.Nothing.value;
      };
      if (v instanceof Data_List_Types.Cons) {
          return new Data_Maybe.Just(v.value1);
      };
      throw new Error("Failed pattern match at Data.List line 238, column 1 - line 238, column 19: " + [ v.constructor.name ]);
  };
  var span = function (v) {
      return function (v1) {
          if (v1 instanceof Data_List_Types.Cons && v(v1.value0)) {
              var $124 = span(v)(v1.value1);
              return {
                  init: new Data_List_Types.Cons(v1.value0, $124.init), 
                  rest: $124.rest
              };
          };
          return {
              init: Data_List_Types.Nil.value, 
              rest: v1
          };
      };
  };

  /**
 * ------------------------------------------------------------------------------
 *  List creation ---------------------------------------------------------------
 * ------------------------------------------------------------------------------
 *  | Create a list with a single element.
 *  |
 *  | Running time: `O(1)`
 */  
  var singleton = function (a) {
      return new Data_List_Types.Cons(a, Data_List_Types.Nil.value);
  };

  /**
 *  | Sort the elements of a list in increasing order, where elements are
 *  | compared using the specified ordering.
 */  
  var sortBy = function (cmp) {
      var merge = function (v) {
          return function (v1) {
              if (v instanceof Data_List_Types.Cons && v1 instanceof Data_List_Types.Cons) {
                  if (Data_Eq.eq(Data_Ordering.eqOrdering)(cmp(v.value0)(v1.value0))(Data_Ordering.GT.value)) {
                      return new Data_List_Types.Cons(v1.value0, merge(v)(v1.value1));
                  };
                  if (Data_Boolean.otherwise) {
                      return new Data_List_Types.Cons(v.value0, merge(v.value1)(v1));
                  };
              };
              if (v instanceof Data_List_Types.Nil) {
                  return v1;
              };
              if (v1 instanceof Data_List_Types.Nil) {
                  return v;
              };
              throw new Error("Failed pattern match at Data.List line 461, column 3 - line 463, column 41: " + [ v.constructor.name, v1.constructor.name ]);
          };
      };
      var mergePairs = function (v) {
          if (v instanceof Data_List_Types.Cons && v.value1 instanceof Data_List_Types.Cons) {
              return new Data_List_Types.Cons(merge(v.value0)(v.value1.value0), mergePairs(v.value1.value1));
          };
          return v;
      };
      var mergeAll = function (__copy_v) {
          var v = __copy_v;
          tco: while (true) {
              if (v instanceof Data_List_Types.Cons && v.value1 instanceof Data_List_Types.Nil) {
                  return v.value0;
              };
              var __tco_v = mergePairs(v);
              v = __tco_v;
              continue tco;
          };
      };
      var sequences = function (v) {
          if (v instanceof Data_List_Types.Cons && v.value1 instanceof Data_List_Types.Cons) {
              if (Data_Eq.eq(Data_Ordering.eqOrdering)(cmp(v.value0)(v.value1.value0))(Data_Ordering.GT.value)) {
                  return descending(v.value1.value0)(singleton(v.value0))(v.value1.value1);
              };
              if (Data_Boolean.otherwise) {
                  return ascending(v.value1.value0)(function (v1) {
                      return new Data_List_Types.Cons(v.value0, v1);
                  })(v.value1.value1);
              };
          };
          return singleton(v);
      };
      var descending = function (__copy_a) {
          return function (__copy_as) {
              return function (__copy_v) {
                  var a = __copy_a;
                  var as = __copy_as;
                  var v = __copy_v;
                  tco: while (true) {
                      if (v instanceof Data_List_Types.Cons && Data_Eq.eq(Data_Ordering.eqOrdering)(cmp(a)(v.value0))(Data_Ordering.GT.value)) {
                          var __tco_a = v.value0;
                          var __tco_as = new Data_List_Types.Cons(a, as);
                          var __tco_v = v.value1;
                          a = __tco_a;
                          as = __tco_as;
                          v = __tco_v;
                          continue tco;
                      };
                      return new Data_List_Types.Cons(new Data_List_Types.Cons(a, as), sequences(v));
                  };
              };
          };
      };
      var ascending = function (a) {
          return function (as) {
              return function (v) {
                  if (v instanceof Data_List_Types.Cons && Data_Eq.notEq(Data_Ordering.eqOrdering)(cmp(a)(v.value0))(Data_Ordering.GT.value)) {
                      return ascending(v.value0)(function (ys) {
                          return as(new Data_List_Types.Cons(a, ys));
                      })(v.value1);
                  };
                  return new Data_List_Types.Cons(as(singleton(a)), sequences(v));
              };
          };
      };
      return function ($303) {
          return mergeAll(sequences($303));
      };
  };

  /**
 * ------------------------------------------------------------------------------
 *  Sorting ---------------------------------------------------------------------
 * ------------------------------------------------------------------------------
 *  | Sort the elements of an list in increasing order.
 */  
  var sort = function (dictOrd) {
      return function (xs) {
          return sortBy(Data_Ord.compare(dictOrd))(xs);
      };
  };

  /**
 * ------------------------------------------------------------------------------
 *  Transformations -------------------------------------------------------------
 * ------------------------------------------------------------------------------
 *  | Reverse a list.
 *  |
 *  | Running time: `O(n)`
 */  
  var reverse = (function () {
      var go = function (__copy_acc) {
          return function (__copy_v) {
              var acc = __copy_acc;
              var v = __copy_v;
              tco: while (true) {
                  if (v instanceof Data_List_Types.Nil) {
                      return acc;
                  };
                  if (v instanceof Data_List_Types.Cons) {
                      var __tco_acc = new Data_List_Types.Cons(v.value0, acc);
                      var __tco_v = v.value1;
                      acc = __tco_acc;
                      v = __tco_v;
                      continue tco;
                  };
                  throw new Error("Failed pattern match at Data.List line 352, column 1 - line 355, column 36: " + [ acc.constructor.name, v.constructor.name ]);
              };
          };
      };
      return go(Data_List_Types.Nil.value);
  })();

  /**
 * ------------------------------------------------------------------------------
 *  Extending arrays ------------------------------------------------------------
 * ------------------------------------------------------------------------------
 *  | Append an element to the end of a list, creating a new list.
 *  |
 *  | Running time: `O(2n)`
 */  
  var snoc = function (xs) {
      return function (x) {
          return reverse(new Data_List_Types.Cons(x, reverse(xs)));
      };
  };

  /**
 *  | Take the specified number of elements from the front of a list.
 *  |
 *  | Running time: `O(n)` where `n` is the number of elements to take.
 */  
  var take = (function () {
      var go = function (__copy_acc) {
          return function (__copy_v) {
              return function (__copy_v1) {
                  var acc = __copy_acc;
                  var v = __copy_v;
                  var v1 = __copy_v1;
                  tco: while (true) {
                      if (v === 0) {
                          return reverse(acc);
                      };
                      if (v1 instanceof Data_List_Types.Nil) {
                          return reverse(acc);
                      };
                      if (v1 instanceof Data_List_Types.Cons) {
                          var __tco_acc = new Data_List_Types.Cons(v1.value0, acc);
                          var __tco_v = v - 1;
                          var __tco_v1 = v1.value1;
                          acc = __tco_acc;
                          v = __tco_v;
                          v1 = __tco_v1;
                          continue tco;
                      };
                      throw new Error("Failed pattern match at Data.List line 479, column 1 - line 483, column 46: " + [ acc.constructor.name, v.constructor.name, v1.constructor.name ]);
                  };
              };
          };
      };
      return go(Data_List_Types.Nil.value);
  })();

  /**
 *  | Take those elements from the front of a list which match a predicate.
 *  |
 *  | Running time (worst case): `O(n)`
 */  
  var takeWhile = function (p) {
      var go = function (__copy_acc) {
          return function (__copy_v) {
              var acc = __copy_acc;
              var v = __copy_v;
              tco: while (true) {
                  if (v instanceof Data_List_Types.Cons && p(v.value0)) {
                      var __tco_acc = new Data_List_Types.Cons(v.value0, acc);
                      var __tco_v = v.value1;
                      acc = __tco_acc;
                      v = __tco_v;
                      continue tco;
                  };
                  return reverse(acc);
              };
          };
      };
      return go(Data_List_Types.Nil.value);
  };

  /**
 * ------------------------------------------------------------------------------
 *  Zipping ---------------------------------------------------------------------
 * ------------------------------------------------------------------------------
 *  | Apply a function to pairs of elements at the same positions in two lists,
 *  | collecting the results in a new list.
 *  |
 *  | If one list is longer, elements will be discarded from the longer list.
 *  |
 *  | For example
 *  |
 *  | ```purescript
 *  | zipWith (*) (1 : 2 : 3 : Nil) (4 : 5 : 6 : 7 Nil) == 4 : 10 : 18 : Nil
 *  | ```
 *  |
 *  | Running time: `O(min(m, n))`
 */  
  var zipWith = function (f) {
      return function (xs) {
          return function (ys) {
              var go = function (__copy_v) {
                  return function (__copy_v1) {
                      return function (__copy_acc) {
                          var v = __copy_v;
                          var v1 = __copy_v1;
                          var acc = __copy_acc;
                          tco: while (true) {
                              if (v instanceof Data_List_Types.Nil) {
                                  return acc;
                              };
                              if (v1 instanceof Data_List_Types.Nil) {
                                  return acc;
                              };
                              if (v instanceof Data_List_Types.Cons && v1 instanceof Data_List_Types.Cons) {
                                  var __tco_v = v.value1;
                                  var __tco_v1 = v1.value1;
                                  var __tco_acc = new Data_List_Types.Cons(f(v.value0)(v1.value0), acc);
                                  v = __tco_v;
                                  v1 = __tco_v1;
                                  acc = __tco_acc;
                                  continue tco;
                              };
                              throw new Error("Failed pattern match at Data.List line 643, column 1 - line 647, column 52: " + [ v.constructor.name, v1.constructor.name, acc.constructor.name ]);
                          };
                      };
                  };
              };
              return reverse(go(xs)(ys)(Data_List_Types.Nil.value));
          };
      };
  };

  /**
 *  | Collect pairs of elements at the same positions in two lists.
 *  |
 *  | Running time: `O(min(m, n))`
 */  
  var zip = zipWith(Data_Tuple.Tuple.create);

  /**
 *  | A generalization of `zipWith` which accumulates results in some `Applicative`
 *  | functor.
 */  
  var zipWithA = function (dictApplicative) {
      return function (f) {
          return function (xs) {
              return function (ys) {
                  return Data_Traversable.sequence(Data_List_Types.traversableList)(dictApplicative)(zipWith(f)(xs)(ys));
              };
          };
      };
  };

  /**
 *  | Create a list containing a range of integers, including both endpoints.
 */  
  var range = function (start) {
      return function (end) {
          if (start === end) {
              return singleton(start);
          };
          if (Data_Boolean.otherwise) {
              var go = function (__copy_s) {
                  return function (__copy_e) {
                      return function (__copy_step) {
                          return function (__copy_rest) {
                              var s = __copy_s;
                              var e = __copy_e;
                              var step = __copy_step;
                              var rest = __copy_rest;
                              tco: while (true) {
                                  if (s === e) {
                                      return new Data_List_Types.Cons(s, rest);
                                  };
                                  if (Data_Boolean.otherwise) {
                                      var __tco_s = s + step | 0;
                                      var __tco_e = e;
                                      var __tco_step = step;
                                      var __tco_rest = new Data_List_Types.Cons(s, rest);
                                      s = __tco_s;
                                      e = __tco_e;
                                      step = __tco_step;
                                      rest = __tco_rest;
                                      continue tco;
                                  };
                                  throw new Error("Failed pattern match at Data.List line 137, column 1 - line 141, column 65: " + [ s.constructor.name, e.constructor.name, step.constructor.name, rest.constructor.name ]);
                              };
                          };
                      };
                  };
              };
              return go(end)(start)((function () {
                  var $184 = start > end;
                  if ($184) {
                      return 1;
                  };
                  if (!$184) {
                      return -1;
                  };
                  throw new Error("Failed pattern match at Data.List line 138, column 45 - line 138, column 74: " + [ $184.constructor.name ]);
              })())(Data_List_Types.Nil.value);
          };
          throw new Error("Failed pattern match at Data.List line 137, column 1 - line 141, column 65: " + [ start.constructor.name, end.constructor.name ]);
      };
  };

  /**
 * ------------------------------------------------------------------------------
 *  List size -------------------------------------------------------------------
 * ------------------------------------------------------------------------------
 *  | Test whether a list is empty.
 *  |
 *  | Running time: `O(1)`
 */  
  var $$null = function (v) {
      if (v instanceof Data_List_Types.Nil) {
          return true;
      };
      return false;
  };

  /**
 *  | Apply a function to each element and its index in a list starting at 0.
 */  
  var mapWithIndex = function (f) {
      return function (lst) {
          var go = function (__copy_v) {
              return function (__copy_v1) {
                  return function (__copy_acc) {
                      var v = __copy_v;
                      var v1 = __copy_v1;
                      var acc = __copy_acc;
                      tco: while (true) {
                          if (v1 instanceof Data_List_Types.Nil) {
                              return acc;
                          };
                          if (v1 instanceof Data_List_Types.Cons) {
                              var __tco_v = v + 1 | 0;
                              var __tco_v1 = v1.value1;
                              var __tco_acc = new Data_List_Types.Cons(f(v1.value0)(v), acc);
                              v = __tco_v;
                              v1 = __tco_v1;
                              acc = __tco_acc;
                              continue tco;
                          };
                          throw new Error("Failed pattern match at Data.List line 417, column 1 - line 420, column 48: " + [ v.constructor.name, v1.constructor.name, acc.constructor.name ]);
                      };
                  };
              };
          };
          return reverse(go(0)(lst)(Data_List_Types.Nil.value));
      };
  };

  /**
 *  | Apply a function to each element in a list, keeping only the results which
 *  | contain a value.
 *  |
 *  | Running time: `O(n)`
 */  
  var mapMaybe = function (f) {
      var go = function (__copy_acc) {
          return function (__copy_v) {
              var acc = __copy_acc;
              var v = __copy_v;
              tco: while (true) {
                  if (v instanceof Data_List_Types.Nil) {
                      return reverse(acc);
                  };
                  if (v instanceof Data_List_Types.Cons) {
                      var $193 = f(v.value0);
                      if ($193 instanceof Data_Maybe.Nothing) {
                          var __tco_acc = acc;
                          var __tco_v = v.value1;
                          acc = __tco_acc;
                          v = __tco_v;
                          continue tco;
                      };
                      if ($193 instanceof Data_Maybe.Just) {
                          var __tco_acc = new Data_List_Types.Cons($193.value0, acc);
                          var __tco_v = v.value1;
                          acc = __tco_acc;
                          v = __tco_v;
                          continue tco;
                      };
                      throw new Error("Failed pattern match at Data.List line 405, column 5 - line 407, column 32: " + [ $193.constructor.name ]);
                  };
                  throw new Error("Failed pattern match at Data.List line 401, column 1 - line 407, column 32: " + [ acc.constructor.name, v.constructor.name ]);
              };
          };
      };
      return go(Data_List_Types.Nil.value);
  };

  /**
 *  | A stack-safe version of `many`, at the cost of a `MonadRec` constraint.
 */  
  var manyRec = function (dictMonadRec) {
      return function (dictAlternative) {
          return function (p) {
              var go = function (acc) {
                  return Control_Bind.bind((dictMonadRec["__superclass_Control.Monad.Monad_0"]())["__superclass_Control.Bind.Bind_1"]())(Control_Alt.alt((dictAlternative["__superclass_Control.Plus.Plus_1"]())["__superclass_Control.Alt.Alt_0"]())(Data_Functor.map(((dictAlternative["__superclass_Control.Plus.Plus_1"]())["__superclass_Control.Alt.Alt_0"]())["__superclass_Data.Functor.Functor_0"]())(Control_Monad_Rec_Class.Loop.create)(p))(Control_Applicative.pure(dictAlternative["__superclass_Control.Applicative.Applicative_0"]())(new Control_Monad_Rec_Class.Done(Data_Unit.unit))))(function (v) {
                      return Control_Applicative.pure(dictAlternative["__superclass_Control.Applicative.Applicative_0"]())(Data_Bifunctor.bimap(Control_Monad_Rec_Class.bifunctorStep)(function (v1) {
                          return new Data_List_Types.Cons(v1, acc);
                      })(function (v1) {
                          return reverse(acc);
                      })(v));
                  });
              };
              return Control_Monad_Rec_Class.tailRecM(dictMonadRec)(go)(Data_List_Types.Nil.value);
          };
      };
  };

  /**
 *  | A stack-safe version of `some`, at the cost of a `MonadRec` constraint.
 */  
  var someRec = function (dictMonadRec) {
      return function (dictAlternative) {
          return function (v) {
              return Control_Apply.apply((dictAlternative["__superclass_Control.Applicative.Applicative_0"]())["__superclass_Control.Apply.Apply_0"]())(Data_Functor.map(((dictAlternative["__superclass_Control.Plus.Plus_1"]())["__superclass_Control.Alt.Alt_0"]())["__superclass_Data.Functor.Functor_0"]())(Data_List_Types.Cons.create)(v))(manyRec(dictMonadRec)(dictAlternative)(v));
          };
      };
  };
  var some = function (dictAlternative) {
      return function (dictLazy) {
          return function (v) {
              return Control_Apply.apply((dictAlternative["__superclass_Control.Applicative.Applicative_0"]())["__superclass_Control.Apply.Apply_0"]())(Data_Functor.map(((dictAlternative["__superclass_Control.Plus.Plus_1"]())["__superclass_Control.Alt.Alt_0"]())["__superclass_Data.Functor.Functor_0"]())(Data_List_Types.Cons.create)(v))(Control_Lazy.defer(dictLazy)(function (v1) {
                  return many(dictAlternative)(dictLazy)(v);
              }));
          };
      };
  };
  var many = function (dictAlternative) {
      return function (dictLazy) {
          return function (v) {
              return Control_Alt.alt((dictAlternative["__superclass_Control.Plus.Plus_1"]())["__superclass_Control.Alt.Alt_0"]())(some(dictAlternative)(dictLazy)(v))(Control_Applicative.pure(dictAlternative["__superclass_Control.Applicative.Applicative_0"]())(Data_List_Types.Nil.value));
          };
      };
  };

  /**
 *  | Get the length of a list
 *  |
 *  | Running time: `O(n)`
 */  
  var length = Data_Foldable.foldl(Data_List_Types.foldableList)(function (acc) {
      return function (v) {
          return acc + 1 | 0;
      };
  })(0);
  var last = function (__copy_v) {
      var v = __copy_v;
      tco: while (true) {
          if (v instanceof Data_List_Types.Cons && v.value1 instanceof Data_List_Types.Nil) {
              return new Data_Maybe.Just(v.value0);
          };
          if (v instanceof Data_List_Types.Cons) {
              var __tco_v = v.value1;
              v = __tco_v;
              continue tco;
          };
          return Data_Maybe.Nothing.value;
      };
  };
  var insertBy = function (v) {
      return function (x) {
          return function (v1) {
              if (v1 instanceof Data_List_Types.Nil) {
                  return singleton(x);
              };
              if (v1 instanceof Data_List_Types.Cons) {
                  var $209 = v(x)(v1.value0);
                  if ($209 instanceof Data_Ordering.GT) {
                      return new Data_List_Types.Cons(v1.value0, insertBy(v)(x)(v1.value1));
                  };
                  return new Data_List_Types.Cons(x, v1);
              };
              throw new Error("Failed pattern match at Data.List line 209, column 1 - line 209, column 31: " + [ v.constructor.name, x.constructor.name, v1.constructor.name ]);
          };
      };
  };
  var insertAt = function (v) {
      return function (v1) {
          return function (v2) {
              if (v === 0) {
                  return new Data_Maybe.Just(new Data_List_Types.Cons(v1, v2));
              };
              if (v2 instanceof Data_List_Types.Cons) {
                  return Data_Functor.map(Data_Maybe.functorMaybe)(function (v3) {
                      return new Data_List_Types.Cons(v2.value0, v3);
                  })(insertAt(v - 1)(v1)(v2.value1));
              };
              return Data_Maybe.Nothing.value;
          };
      };
  };

  /**
 *  | Insert an element into a sorted list.
 *  |
 *  | Running time: `O(n)`
 */  
  var insert = function (dictOrd) {
      return insertBy(Data_Ord.compare(dictOrd));
  };

  /**
 *  | Get all but the last element of a list, or `Nothing` if the list is empty.
 *  |
 *  | Running time: `O(n)`
 */  
  var init = function (v) {
      if (v instanceof Data_List_Types.Nil) {
          return Data_Maybe.Nothing.value;
      };
      var go = function (__copy_v1) {
          return function (__copy_acc) {
              var v1 = __copy_v1;
              var acc = __copy_acc;
              tco: while (true) {
                  if (v1 instanceof Data_List_Types.Cons && v1.value1 instanceof Data_List_Types.Nil) {
                      return acc;
                  };
                  if (v1 instanceof Data_List_Types.Cons) {
                      var __tco_v1 = v1.value1;
                      var __tco_acc = new Data_List_Types.Cons(v1.value0, acc);
                      v1 = __tco_v1;
                      acc = __tco_acc;
                      continue tco;
                  };
                  return acc;
              };
          };
      };
      return Data_Maybe.Just.create(reverse(go(v)(Data_List_Types.Nil.value)));
  };
  var index = function (__copy_v) {
      return function (__copy_v1) {
          var v = __copy_v;
          var v1 = __copy_v1;
          tco: while (true) {
              if (v instanceof Data_List_Types.Nil) {
                  return Data_Maybe.Nothing.value;
              };
              if (v instanceof Data_List_Types.Cons && v1 === 0) {
                  return new Data_Maybe.Just(v.value0);
              };
              if (v instanceof Data_List_Types.Cons) {
                  var __tco_v = v.value1;
                  var __tco_v1 = v1 - 1;
                  v = __tco_v;
                  v1 = __tco_v1;
                  continue tco;
              };
              throw new Error("Failed pattern match at Data.List line 268, column 1 - line 268, column 22: " + [ v.constructor.name, v1.constructor.name ]);
          };
      };
  };

  /**
 * ------------------------------------------------------------------------------
 *  Non-indexed reads -----------------------------------------------------------
 * ------------------------------------------------------------------------------
 *  | Get the first element in a list, or `Nothing` if the list is empty.
 *  |
 *  | Running time: `O(1)`.
 */  
  var head = function (v) {
      if (v instanceof Data_List_Types.Nil) {
          return Data_Maybe.Nothing.value;
      };
      if (v instanceof Data_List_Types.Cons) {
          return new Data_Maybe.Just(v.value0);
      };
      throw new Error("Failed pattern match at Data.List line 223, column 1 - line 223, column 19: " + [ v.constructor.name ]);
  };
  var transpose = function (v) {
      if (v instanceof Data_List_Types.Nil) {
          return Data_List_Types.Nil.value;
      };
      if (v instanceof Data_List_Types.Cons && v.value0 instanceof Data_List_Types.Nil) {
          return transpose(v.value1);
      };
      if (v instanceof Data_List_Types.Cons && v.value0 instanceof Data_List_Types.Cons) {
          return new Data_List_Types.Cons(new Data_List_Types.Cons(v.value0.value0, mapMaybe(head)(v.value1)), transpose(new Data_List_Types.Cons(v.value0.value1, mapMaybe(tail)(v.value1))));
      };
      throw new Error("Failed pattern match at Data.List line 680, column 1 - line 680, column 20: " + [ v.constructor.name ]);
  };
  var groupBy = function (v) {
      return function (v1) {
          if (v1 instanceof Data_List_Types.Nil) {
              return Data_List_Types.Nil.value;
          };
          if (v1 instanceof Data_List_Types.Cons) {
              var $242 = span(v(v1.value0))(v1.value1);
              return new Data_List_Types.Cons(new Data_NonEmpty.NonEmpty(v1.value0, $242.init), groupBy(v)($242.rest));
          };
          throw new Error("Failed pattern match at Data.List line 553, column 1 - line 553, column 20: " + [ v.constructor.name, v1.constructor.name ]);
      };
  };

  /**
 *  | Group equal, consecutive elements of a list into lists.
 *  |
 *  | For example,
 *  |
 *  | ```purescript
 *  | group (1 : 1 : 2 : 2 : 1 : Nil) == (1 : 1 : Nil) : (2 : 2 : Nil) : (1 : Nil) : Nil
 *  | ```
 *  |
 *  | Running time: `O(n)`
 */  
  var group = function (dictEq) {
      return groupBy(Data_Eq.eq(dictEq));
  };

  /**
 *  | Sort and then group the elements of a list into lists.
 *  |
 *  | ```purescript
 *  | group' [1,1,2,2,1] == [[1,1,1],[2,2]]
 *  | ```
 */  
  var group$prime = function (dictOrd) {
      return function ($304) {
          return group(dictOrd["__superclass_Data.Eq.Eq_0"]())(sort(dictOrd)($304));
      };
  };

  /**
 *  | Construct a list from a foldable structure.
 *  |
 *  | Running time: `O(n)`
 */  
  var fromFoldable = function (dictFoldable) {
      return Data_Foldable.foldr(dictFoldable)(Data_List_Types.Cons.create)(Data_List_Types.Nil.value);
  };
  var foldM = function (dictMonad) {
      return function (v) {
          return function (a) {
              return function (v1) {
                  if (v1 instanceof Data_List_Types.Nil) {
                      return Control_Applicative.pure(dictMonad["__superclass_Control.Applicative.Applicative_0"]())(a);
                  };
                  if (v1 instanceof Data_List_Types.Cons) {
                      return Control_Bind.bind(dictMonad["__superclass_Control.Bind.Bind_1"]())(v(a)(v1.value0))(function (a$prime) {
                          return foldM(dictMonad)(v)(a$prime)(v1.value1);
                      });
                  };
                  throw new Error("Failed pattern match at Data.List line 691, column 1 - line 691, column 23: " + [ v.constructor.name, a.constructor.name, v1.constructor.name ]);
              };
          };
      };
  };

  /**
 *  | Find the first index for which a predicate holds.
 */  
  var findIndex = function (fn) {
      var go = function (__copy_v) {
          return function (__copy_v1) {
              var v = __copy_v;
              var v1 = __copy_v1;
              tco: while (true) {
                  if (v1 instanceof Data_List_Types.Cons) {
                      if (fn(v1.value0)) {
                          return new Data_Maybe.Just(v);
                      };
                      if (Data_Boolean.otherwise) {
                          var __tco_v = v + 1 | 0;
                          var __tco_v1 = v1.value1;
                          v = __tco_v;
                          v1 = __tco_v1;
                          continue tco;
                      };
                  };
                  if (v1 instanceof Data_List_Types.Nil) {
                      return Data_Maybe.Nothing.value;
                  };
                  throw new Error("Failed pattern match at Data.List line 288, column 3 - line 289, column 44: " + [ v.constructor.name, v1.constructor.name ]);
              };
          };
      };
      return go(0);
  };

  /**
 *  | Find the last index for which a predicate holds.
 */  
  var findLastIndex = function (fn) {
      return function (xs) {
          return Data_Functor.map(Data_Maybe.functorMaybe)(function (v) {
              return length(xs) - 1 - v;
          })(findIndex(fn)(reverse(xs)));
      };
  };
  var filterM = function (dictMonad) {
      return function (v) {
          return function (v1) {
              if (v1 instanceof Data_List_Types.Nil) {
                  return Control_Applicative.pure(dictMonad["__superclass_Control.Applicative.Applicative_0"]())(Data_List_Types.Nil.value);
              };
              if (v1 instanceof Data_List_Types.Cons) {
                  return Control_Bind.bind(dictMonad["__superclass_Control.Bind.Bind_1"]())(v(v1.value0))(function (v2) {
                      return Control_Bind.bind(dictMonad["__superclass_Control.Bind.Bind_1"]())(filterM(dictMonad)(v)(v1.value1))(function (v3) {
                          return Control_Applicative.pure(dictMonad["__superclass_Control.Applicative.Applicative_0"]())((function () {
                              if (v2) {
                                  return new Data_List_Types.Cons(v1.value0, v3);
                              };
                              if (!v2) {
                                  return v3;
                              };
                              throw new Error("Failed pattern match at Data.List line 394, column 8 - line 394, column 34: " + [ v2.constructor.name ]);
                          })());
                      });
                  });
              };
              throw new Error("Failed pattern match at Data.List line 390, column 1 - line 390, column 25: " + [ v.constructor.name, v1.constructor.name ]);
          };
      };
  };

  /**
 *  | Filter a list, keeping the elements which satisfy a predicate function.
 *  |
 *  | Running time: `O(n)`
 */  
  var filter = function (p) {
      var go = function (__copy_acc) {
          return function (__copy_v) {
              var acc = __copy_acc;
              var v = __copy_v;
              tco: while (true) {
                  if (v instanceof Data_List_Types.Nil) {
                      return reverse(acc);
                  };
                  if (v instanceof Data_List_Types.Cons) {
                      if (p(v.value0)) {
                          var __tco_acc = new Data_List_Types.Cons(v.value0, acc);
                          var __tco_v = v.value1;
                          acc = __tco_acc;
                          v = __tco_v;
                          continue tco;
                      };
                      if (Data_Boolean.otherwise) {
                          var __tco_acc = acc;
                          var __tco_v = v.value1;
                          acc = __tco_acc;
                          v = __tco_v;
                          continue tco;
                      };
                  };
                  throw new Error("Failed pattern match at Data.List line 374, column 1 - line 379, column 28: " + [ acc.constructor.name, v.constructor.name ]);
              };
          };
      };
      return go(Data_List_Types.Nil.value);
  };

  /**
 *  | Calculate the intersection of two lists, using the specified
 *  | function to determine equality of elements.
 *  |
 *  | Running time: `O(n^2)`
 */  
  var intersectBy = function (v) {
      return function (v1) {
          return function (v2) {
              if (v1 instanceof Data_List_Types.Nil) {
                  return Data_List_Types.Nil.value;
              };
              if (v2 instanceof Data_List_Types.Nil) {
                  return Data_List_Types.Nil.value;
              };
              return filter(function (x) {
                  return Data_Foldable.any(Data_List_Types.foldableList)(Data_HeytingAlgebra.heytingAlgebraBoolean)(v(x))(v2);
              })(v1);
          };
      };
  };

  /**
 *  | Calculate the intersection of two lists.
 *  |
 *  | Running time: `O(n^2)`
 */  
  var intersect = function (dictEq) {
      return intersectBy(Data_Eq.eq(dictEq));
  };
  var nubBy = function (v) {
      return function (v1) {
          if (v1 instanceof Data_List_Types.Nil) {
              return Data_List_Types.Nil.value;
          };
          if (v1 instanceof Data_List_Types.Cons) {
              return new Data_List_Types.Cons(v1.value0, nubBy(v)(filter(function (y) {
                  return !v(v1.value0)(y);
              })(v1.value1)));
          };
          throw new Error("Failed pattern match at Data.List line 572, column 1 - line 572, column 22: " + [ v.constructor.name, v1.constructor.name ]);
      };
  };

  /**
 * ------------------------------------------------------------------------------
 *  Set-like operations ---------------------------------------------------------
 * ------------------------------------------------------------------------------
 *  | Remove duplicate elements from a list.
 *  |
 *  | Running time: `O(n^2)`
 */  
  var nub = function (dictEq) {
      return nubBy(Data_Eq.eq(dictEq));
  };

  /**
 *  | Find the index of the last element equal to the specified element.
 */  
  var elemLastIndex = function (dictEq) {
      return function (x) {
          return findLastIndex(function (v) {
              return Data_Eq.eq(dictEq)(v)(x);
          });
      };
  };

  /**
 *  | Find the index of the first element equal to the specified element.
 */  
  var elemIndex = function (dictEq) {
      return function (x) {
          return findIndex(function (v) {
              return Data_Eq.eq(dictEq)(v)(x);
          });
      };
  };

  /**
 *  | Drop those elements from the front of a list which match a predicate.
 *  |
 *  | Running time (worst case): `O(n)`
 */  
  var dropWhile = function (p) {
      var go = function (__copy_v) {
          var v = __copy_v;
          tco: while (true) {
              if (v instanceof Data_List_Types.Cons && p(v.value0)) {
                  var __tco_v = v.value1;
                  v = __tco_v;
                  continue tco;
              };
              return v;
          };
      };
      return go;
  };
  var drop = function (__copy_v) {
      return function (__copy_v1) {
          var v = __copy_v;
          var v1 = __copy_v1;
          tco: while (true) {
              if (v === 0) {
                  return v1;
              };
              if (v1 instanceof Data_List_Types.Nil) {
                  return Data_List_Types.Nil.value;
              };
              if (v1 instanceof Data_List_Types.Cons) {
                  var __tco_v = v - 1;
                  var __tco_v1 = v1.value1;
                  v = __tco_v;
                  v1 = __tco_v1;
                  continue tco;
              };
              throw new Error("Failed pattern match at Data.List line 498, column 1 - line 498, column 15: " + [ v.constructor.name, v1.constructor.name ]);
          };
      };
  };

  /**
 * ------------------------------------------------------------------------------
 *  Sublists --------------------------------------------------------------------
 * ------------------------------------------------------------------------------
 *  | Extract a sublist by a start and end index.
 */  
  var slice = function (start) {
      return function (end) {
          return function (xs) {
              return take(end - start)(drop(start)(xs));
          };
      };
  };
  var deleteBy = function (v) {
      return function (v1) {
          return function (v2) {
              if (v2 instanceof Data_List_Types.Nil) {
                  return Data_List_Types.Nil.value;
              };
              if (v2 instanceof Data_List_Types.Cons && v(v1)(v2.value0)) {
                  return v2.value1;
              };
              if (v2 instanceof Data_List_Types.Cons) {
                  return new Data_List_Types.Cons(v2.value0, deleteBy(v)(v1)(v2.value1));
              };
              throw new Error("Failed pattern match at Data.List line 599, column 1 - line 599, column 23: " + [ v.constructor.name, v1.constructor.name, v2.constructor.name ]);
          };
      };
  };

  /**
 *  | Calculate the union of two lists, using the specified
 *  | function to determine equality of elements.
 *  |
 *  | Running time: `O(n^2)`
 */  
  var unionBy = function (eq) {
      return function (xs) {
          return function (ys) {
              return Data_Semigroup.append(Data_List_Types.semigroupList)(xs)(Data_Foldable.foldl(Data_List_Types.foldableList)(Data_Function.flip(deleteBy(eq)))(nubBy(eq)(ys))(xs));
          };
      };
  };

  /**
 *  | Calculate the union of two lists.
 *  |
 *  | Running time: `O(n^2)`
 */  
  var union = function (dictEq) {
      return unionBy(Data_Eq.eq(dictEq));
  };
  var deleteAt = function (v) {
      return function (v1) {
          if (v === 0 && v1 instanceof Data_List_Types.Cons) {
              return new Data_Maybe.Just(v1.value1);
          };
          if (v1 instanceof Data_List_Types.Cons) {
              return Data_Functor.map(Data_Maybe.functorMaybe)(function (v2) {
                  return new Data_List_Types.Cons(v1.value0, v2);
              })(deleteAt(v - 1)(v1.value1));
          };
          return Data_Maybe.Nothing.value;
      };
  };

  /**
 *  | Delete the first occurrence of an element from a list.
 *  |
 *  | Running time: `O(n)`
 */  
  var $$delete = function (dictEq) {
      return deleteBy(Data_Eq.eq(dictEq));
  };

  /**
 *  | Delete the first occurrence of each element in the second list from the first list.
 *  |
 *  | Running time: `O(n^2)`
 */  
  var difference = function (dictEq) {
      return Data_Foldable.foldl(Data_List_Types.foldableList)(Data_Function.flip($$delete(dictEq)));
  };

  /**
 *  | Apply a function to each element in a list, and flatten the results
 *  | into a single, new list.
 *  |
 *  | Running time: `O(n)`, where `n` is the total number of elements.
 */  
  var concatMap = Data_Function.flip(Control_Bind.bind(Data_List_Types.bindList));

  /**
 *  | Flatten a list of lists.
 *  |
 *  | Running time: `O(n)`, where `n` is the total number of elements.
 */  
  var concat = function (v) {
      return Control_Bind.bind(Data_List_Types.bindList)(v)(Control_Category.id(Control_Category.categoryFn));
  };

  /**
 *  | Filter a list of optional values, keeping only the elements which contain
 *  | a value.
 */  
  var catMaybes = mapMaybe(Control_Category.id(Control_Category.categoryFn));
  var alterAt = function (v) {
      return function (v1) {
          return function (v2) {
              if (v === 0 && v2 instanceof Data_List_Types.Cons) {
                  return Data_Maybe.Just.create((function () {
                      var $297 = v1(v2.value0);
                      if ($297 instanceof Data_Maybe.Nothing) {
                          return v2.value1;
                      };
                      if ($297 instanceof Data_Maybe.Just) {
                          return new Data_List_Types.Cons($297.value0, v2.value1);
                      };
                      throw new Error("Failed pattern match at Data.List line 338, column 3 - line 340, column 23: " + [ $297.constructor.name ]);
                  })());
              };
              if (v2 instanceof Data_List_Types.Cons) {
                  return Data_Functor.map(Data_Maybe.functorMaybe)(function (v3) {
                      return new Data_List_Types.Cons(v2.value0, v3);
                  })(alterAt(v - 1)(v1)(v2.value1));
              };
              return Data_Maybe.Nothing.value;
          };
      };
  };

  /**
 *  | Update the element at the specified index by applying a function to
 *  | the current value, returning a new list or `Nothing` if the index is
 *  | out-of-bounds.
 *  |
 *  | Running time: `O(n)`
 */  
  var modifyAt = function (n) {
      return function (f) {
          return alterAt(n)(function ($305) {
              return Data_Maybe.Just.create(f($305));
          });
      };
  };
  exports["alterAt"] = alterAt;
  exports["catMaybes"] = catMaybes;
  exports["concat"] = concat;
  exports["concatMap"] = concatMap;
  exports["delete"] = $$delete;
  exports["deleteAt"] = deleteAt;
  exports["deleteBy"] = deleteBy;
  exports["difference"] = difference;
  exports["drop"] = drop;
  exports["dropWhile"] = dropWhile;
  exports["elemIndex"] = elemIndex;
  exports["elemLastIndex"] = elemLastIndex;
  exports["filter"] = filter;
  exports["filterM"] = filterM;
  exports["findIndex"] = findIndex;
  exports["findLastIndex"] = findLastIndex;
  exports["foldM"] = foldM;
  exports["fromFoldable"] = fromFoldable;
  exports["group"] = group;
  exports["group'"] = group$prime;
  exports["groupBy"] = groupBy;
  exports["head"] = head;
  exports["index"] = index;
  exports["init"] = init;
  exports["insert"] = insert;
  exports["insertAt"] = insertAt;
  exports["insertBy"] = insertBy;
  exports["intersect"] = intersect;
  exports["intersectBy"] = intersectBy;
  exports["last"] = last;
  exports["length"] = length;
  exports["many"] = many;
  exports["manyRec"] = manyRec;
  exports["mapMaybe"] = mapMaybe;
  exports["mapWithIndex"] = mapWithIndex;
  exports["modifyAt"] = modifyAt;
  exports["nub"] = nub;
  exports["nubBy"] = nubBy;
  exports["null"] = $$null;
  exports["range"] = range;
  exports["reverse"] = reverse;
  exports["singleton"] = singleton;
  exports["slice"] = slice;
  exports["snoc"] = snoc;
  exports["some"] = some;
  exports["someRec"] = someRec;
  exports["sort"] = sort;
  exports["sortBy"] = sortBy;
  exports["span"] = span;
  exports["tail"] = tail;
  exports["take"] = take;
  exports["takeWhile"] = takeWhile;
  exports["toUnfoldable"] = toUnfoldable;
  exports["transpose"] = transpose;
  exports["uncons"] = uncons;
  exports["union"] = union;
  exports["unionBy"] = unionBy;
  exports["unzip"] = unzip;
  exports["updateAt"] = updateAt;
  exports["zip"] = zip;
  exports["zipWith"] = zipWith;
  exports["zipWithA"] = zipWithA;
})(PS["Data.List"] = PS["Data.List"] || {});
(function(exports) {
  
  /**
 *  | This module defines a strict queue.
 *  |
 *  | The queue implementation is based on a pair of lists where all
 *  | operations require `O(1)` amortized time.
 *  |
 *  | However, any single `uncons` operation may run in `O(n)` time.
 *  |
 *  | See [Simple and Efficient Purely Functional Queues and Dequeues](http://www.westpoint.edu/eecs/SiteAssets/SitePages/Faculty%20Publication%20Documents/Okasaki/jfp95queue.pdf) (Okasaki 1995)
 */  
  "use strict";
  var Data_List = PS["Data.List"];
  var Data_Maybe = PS["Data.Maybe"];
  var Data_Semigroup = PS["Data.Semigroup"];
  var Data_Show = PS["Data.Show"];
  var Data_Tuple = PS["Data.Tuple"];
  var Data_List_Types = PS["Data.List.Types"];        

  /**
 *  | A strict queue representated using a pair of lists.
 */  
  var CatQueue = (function () {
      function CatQueue(value0, value1) {
          this.value0 = value0;
          this.value1 = value1;
      };
      CatQueue.create = function (value0) {
          return function (value1) {
              return new CatQueue(value0, value1);
          };
      };
      return CatQueue;
  })();
  var uncons = function (__copy_v) {
      var v = __copy_v;
      tco: while (true) {
          if (v.value0 instanceof Data_List_Types.Nil && v.value1 instanceof Data_List_Types.Nil) {
              return Data_Maybe.Nothing.value;
          };
          if (v.value0 instanceof Data_List_Types.Nil) {
              var __tco_v = new CatQueue(Data_List.reverse(v.value1), Data_List_Types.Nil.value);
              v = __tco_v;
              continue tco;
          };
          if (v.value0 instanceof Data_List_Types.Cons) {
              return new Data_Maybe.Just(new Data_Tuple.Tuple(v.value0.value0, new CatQueue(v.value0.value1, v.value1)));
          };
          throw new Error("Failed pattern match at Data.CatQueue line 51, column 1 - line 51, column 36: " + [ v.constructor.name ]);
      };
  };

  /**
 *  | Append an element to the end of the queue, creating a new queue.
 *  |
 *  | Running time: `O(1)`
 */  
  var snoc = function (v) {
      return function (a) {
          return new CatQueue(v.value0, new Data_List_Types.Cons(a, v.value1));
      };
  };
  var showCatQueue = function (dictShow) {
      return new Data_Show.Show(function (v) {
          return "(CatQueue " + (Data_Show.show(Data_List_Types.showList(dictShow))(v.value0) + (" " + (Data_Show.show(Data_List_Types.showList(dictShow))(v.value1) + ")")));
      });
  };

  /**
 *  | Test whether a queue is empty.
 *  |
 *  | Running time: `O(1)`
 */  
  var $$null = function (v) {
      if (v.value0 instanceof Data_List_Types.Nil && v.value1 instanceof Data_List_Types.Nil) {
          return true;
      };
      return false;
  };

  /**
 *  | Create an empty queue.
 *  |
 *  | Running time: `O(1)`
 */  
  var empty = new CatQueue(Data_List_Types.Nil.value, Data_List_Types.Nil.value);
  exports["CatQueue"] = CatQueue;
  exports["empty"] = empty;
  exports["null"] = $$null;
  exports["snoc"] = snoc;
  exports["uncons"] = uncons;
  exports["showCatQueue"] = showCatQueue;
})(PS["Data.CatQueue"] = PS["Data.CatQueue"] || {});
(function(exports) {
  
  /**
 *  | This module defines a strict catenable list.
 *  |
 *  | The implementation is based on a queue where all operations require
 *  | `O(1)` amortized time.
 *  |
 *  | However, any single `uncons` operation may run in `O(n)` time.
 *  |
 *  | See [Purely Functional Data Structures](http://www.cs.cmu.edu/~rwh/theses/okasaki.pdf) (Okasaki 1996)
 */  
  "use strict";
  var Data_CatQueue = PS["Data.CatQueue"];
  var Data_Foldable = PS["Data.Foldable"];
  var Data_List = PS["Data.List"];
  var Control_Alt = PS["Control.Alt"];
  var Control_Alternative = PS["Control.Alternative"];
  var Control_Applicative = PS["Control.Applicative"];
  var Control_Apply = PS["Control.Apply"];
  var Control_Bind = PS["Control.Bind"];
  var Control_Monad = PS["Control.Monad"];
  var Control_MonadPlus = PS["Control.MonadPlus"];
  var Control_MonadZero = PS["Control.MonadZero"];
  var Control_Plus = PS["Control.Plus"];
  var Data_Function = PS["Data.Function"];
  var Data_Functor = PS["Data.Functor"];
  var Data_Maybe = PS["Data.Maybe"];
  var Data_Monoid = PS["Data.Monoid"];
  var Data_NaturalTransformation = PS["Data.NaturalTransformation"];
  var Data_Semigroup = PS["Data.Semigroup"];
  var Data_Show = PS["Data.Show"];
  var Data_Traversable = PS["Data.Traversable"];
  var Data_Tuple = PS["Data.Tuple"];
  var Data_Unfoldable = PS["Data.Unfoldable"];
  var Data_List_Types = PS["Data.List.Types"];        

  /**
 *  | A strict catenable list.
 *  |
 *  | `CatList` may be empty, represented by `CatNil`.
 *  |
 *  | `CatList` may be non-empty, represented by `CatCons`. The `CatCons`
 *  | data constructor takes the first element of the list and a queue of
 *  | `CatList`.
 */  
  var CatNil = (function () {
      function CatNil() {

      };
      CatNil.value = new CatNil();
      return CatNil;
  })();

  /**
 *  | A strict catenable list.
 *  |
 *  | `CatList` may be empty, represented by `CatNil`.
 *  |
 *  | `CatList` may be non-empty, represented by `CatCons`. The `CatCons`
 *  | data constructor takes the first element of the list and a queue of
 *  | `CatList`.
 */  
  var CatCons = (function () {
      function CatCons(value0, value1) {
          this.value0 = value0;
          this.value1 = value1;
      };
      CatCons.create = function (value0) {
          return function (value1) {
              return new CatCons(value0, value1);
          };
      };
      return CatCons;
  })();
  var showCatList = function (dictShow) {
      return new Data_Show.Show(function (v) {
          if (v instanceof CatNil) {
              return "CatNil";
          };
          if (v instanceof CatCons) {
              return "(CatList " + (Data_Show.show(dictShow)(v.value0) + (" " + (Data_Show.show(Data_CatQueue.showCatQueue(showCatList(dictShow)))(v.value1) + ")")));
          };
          throw new Error("Failed pattern match at Data.CatList line 154, column 3 - line 155, column 3: " + [ v.constructor.name ]);
      });
  };

  /**
 *  | Test whether a catenable list is empty.
 *  |
 *  | Running time: `O(1)`
 */  
  var $$null = function (v) {
      if (v instanceof CatNil) {
          return true;
      };
      return false;
  };

  /**
 *  | Links two catenable lists by making appending the queue in the
 *  | first catenable list to the second catenable list. This operation
 *  | creates a new catenable list.
 *  |
 *  | Running time: `O(1)`
 */  
  var link = function (v) {
      return function (cat) {
          if (v instanceof CatNil) {
              return cat;
          };
          if (v instanceof CatCons) {
              return new CatCons(v.value0, Data_CatQueue.snoc(v.value1)(cat));
          };
          throw new Error("Failed pattern match at Data.CatList line 111, column 1 - line 111, column 22: " + [ v.constructor.name, cat.constructor.name ]);
      };
  };

  /**
 *  | Tail recursive version of foldr on `CatList`.
 *  |
 *  | Ensures foldl on `List` is tail-recursive.
 */  
  var foldr = function (k) {
      return function (b) {
          return function (q) {
              var foldl = function (__copy_v) {
                  return function (__copy_c) {
                      return function (__copy_v1) {
                          var v = __copy_v;
                          var c = __copy_c;
                          var v1 = __copy_v1;
                          tco: while (true) {
                              if (v1 instanceof Data_List_Types.Nil) {
                                  return c;
                              };
                              if (v1 instanceof Data_List_Types.Cons) {
                                  var __tco_v = v;
                                  var __tco_c = v(c)(v1.value0);
                                  var __tco_v1 = v1.value1;
                                  v = __tco_v;
                                  c = __tco_c;
                                  v1 = __tco_v1;
                                  continue tco;
                              };
                              throw new Error("Failed pattern match at Data.CatList line 126, column 3 - line 126, column 22: " + [ v.constructor.name, c.constructor.name, v1.constructor.name ]);
                          };
                      };
                  };
              };
              var go = function (__copy_xs) {
                  return function (__copy_ys) {
                      var xs = __copy_xs;
                      var ys = __copy_ys;
                      tco: while (true) {
                          var $33 = Data_CatQueue.uncons(xs);
                          if ($33 instanceof Data_Maybe.Nothing) {
                              return foldl(function (x) {
                                  return function (i) {
                                      return i(x);
                                  };
                              })(b)(ys);
                          };
                          if ($33 instanceof Data_Maybe.Just) {
                              var __tco_ys = new Data_List_Types.Cons(k($33.value0.value0), ys);
                              xs = $33.value0.value1;
                              ys = __tco_ys;
                              continue tco;
                          };
                          throw new Error("Failed pattern match at Data.CatList line 121, column 14 - line 123, column 67: " + [ $33.constructor.name ]);
                      };
                  };
              };
              return go(q)(Data_List_Types.Nil.value);
          };
      };
  };

  /**
 *  | Decompose a catenable list into a `Tuple` of the first element and
 *  | the rest of the catenable list.
 *  |
 *  | Running time: `O(1)`
 *  |
 *  | Note that any single operation may run in `O(n)`.
 */  
  var uncons = function (v) {
      if (v instanceof CatNil) {
          return Data_Maybe.Nothing.value;
      };
      if (v instanceof CatCons) {
          return new Data_Maybe.Just(new Data_Tuple.Tuple(v.value0, (function () {
              var $38 = Data_CatQueue["null"](v.value1);
              if ($38) {
                  return CatNil.value;
              };
              if (!$38) {
                  return foldr(link)(CatNil.value)(v.value1);
              };
              throw new Error("Failed pattern match at Data.CatList line 103, column 39 - line 103, column 89: " + [ $38.constructor.name ]);
          })()));
      };
      throw new Error("Failed pattern match at Data.CatList line 102, column 1 - line 102, column 24: " + [ v.constructor.name ]);
  };
  var foldMap = function (dictMonoid) {
      return function (f) {
          return function (v) {
              if (v instanceof CatNil) {
                  return Data_Monoid.mempty(dictMonoid);
              };
              if (v instanceof CatCons) {
                  var d = (function () {
                      var $43 = Data_CatQueue["null"](v.value1);
                      if ($43) {
                          return CatNil.value;
                      };
                      if (!$43) {
                          return foldr(link)(CatNil.value)(v.value1);
                      };
                      throw new Error("Failed pattern match at Data.CatList line 144, column 11 - line 144, column 61: " + [ $43.constructor.name ]);
                  })();
                  return Data_Semigroup.append(dictMonoid["__superclass_Data.Semigroup.Semigroup_0"]())(f(v.value0))(foldMap(dictMonoid)(f)(d));
              };
              throw new Error("Failed pattern match at Data.CatList line 142, column 1 - line 142, column 26: " + [ f.constructor.name, v.constructor.name ]);
          };
      };
  };
  var foldableCatList = new Data_Foldable.Foldable(function (dictMonoid) {
      return function (f) {
          return function (l) {
              return foldMap(dictMonoid)(f)(l);
          };
      };
  }, function (f) {
      return function (s) {
          return function (l) {
              return Data_Foldable.foldlDefault(foldableCatList)(f)(s)(l);
          };
      };
  }, function (f) {
      return function (s) {
          return function (l) {
              return Data_Foldable.foldrDefault(foldableCatList)(f)(s)(l);
          };
      };
  });

  /**
 *  | Create an empty catenable list.
 *  |
 *  | Running time: `O(1)`
 */  
  var empty = CatNil.value;

  /**
 *  | Append all elements of a catenable list to the end of another
 *  | catenable list, create a new catenable list.
 *  |
 *  | Running time: `O(1)`
 */  
  var append = function (v) {
      return function (v1) {
          if (v1 instanceof CatNil) {
              return v;
          };
          if (v instanceof CatNil) {
              return v1;
          };
          return link(v)(v1);
      };
  };

  /**
 *  | Append an element to the beginning of the catenable list, creating a new
 *  | catenable list.
 *  |
 *  | Running time: `O(1)`
 */  
  var cons = function (a) {
      return function (cat) {
          return append(new CatCons(a, Data_CatQueue.empty))(cat);
      };
  };
  var map = function (v) {
      return function (v1) {
          if (v1 instanceof CatNil) {
              return CatNil.value;
          };
          if (v1 instanceof CatCons) {
              var d = (function () {
                  var $50 = Data_CatQueue["null"](v1.value1);
                  if ($50) {
                      return CatNil.value;
                  };
                  if (!$50) {
                      return foldr(link)(CatNil.value)(v1.value1);
                  };
                  throw new Error("Failed pattern match at Data.CatList line 138, column 11 - line 138, column 61: " + [ $50.constructor.name ]);
              })();
              return cons(v(v1.value0))(map(v)(d));
          };
          throw new Error("Failed pattern match at Data.CatList line 136, column 1 - line 136, column 22: " + [ v.constructor.name, v1.constructor.name ]);
      };
  };
  var functorCatList = new Data_Functor.Functor(map);

  /**
 *  | Create a catenable list with a single item.
 *  |
 *  | Running time: `O(1)`
 */  
  var singleton = function (a) {
      return cons(a)(CatNil.value);
  };
  var traversableCatList = new Data_Traversable.Traversable(function () {
      return foldableCatList;
  }, function () {
      return functorCatList;
  }, function (dictApplicative) {
      return function (v) {
          if (v instanceof CatNil) {
              return Control_Applicative.pure(dictApplicative)(CatNil.value);
          };
          if (v instanceof CatCons) {
              var d = (function () {
                  var $54 = Data_CatQueue["null"](v.value1);
                  if ($54) {
                      return CatNil.value;
                  };
                  if (!$54) {
                      return foldr(link)(CatNil.value)(v.value1);
                  };
                  throw new Error("Failed pattern match at Data.CatList line 176, column 13 - line 176, column 63: " + [ $54.constructor.name ]);
              })();
              return Control_Apply.apply(dictApplicative["__superclass_Control.Apply.Apply_0"]())(Data_Functor.map((dictApplicative["__superclass_Control.Apply.Apply_0"]())["__superclass_Data.Functor.Functor_0"]())(cons)(v.value0))(Data_Traversable.sequence(traversableCatList)(dictApplicative)(d));
          };
          throw new Error("Failed pattern match at Data.CatList line 174, column 3 - line 174, column 32: " + [ v.constructor.name ]);
      };
  }, function (dictApplicative) {
      return function (v) {
          return function (v1) {
              if (v1 instanceof CatNil) {
                  return Control_Applicative.pure(dictApplicative)(CatNil.value);
              };
              if (v1 instanceof CatCons) {
                  var d = (function () {
                      var $59 = Data_CatQueue["null"](v1.value1);
                      if ($59) {
                          return CatNil.value;
                      };
                      if (!$59) {
                          return foldr(link)(CatNil.value)(v1.value1);
                      };
                      throw new Error("Failed pattern match at Data.CatList line 172, column 13 - line 172, column 63: " + [ $59.constructor.name ]);
                  })();
                  return Control_Apply.apply(dictApplicative["__superclass_Control.Apply.Apply_0"]())(Data_Functor.map((dictApplicative["__superclass_Control.Apply.Apply_0"]())["__superclass_Data.Functor.Functor_0"]())(cons)(v(v1.value0)))(Data_Traversable.traverse(traversableCatList)(dictApplicative)(v)(d));
              };
              throw new Error("Failed pattern match at Data.CatList line 170, column 3 - line 170, column 34: " + [ v.constructor.name, v1.constructor.name ]);
          };
      };
  });
  var semigroupCatList = new Data_Semigroup.Semigroup(append);
  var monoidCatList = new Data_Monoid.Monoid(function () {
      return semigroupCatList;
  }, CatNil.value);
  var monadCatList = new Control_Monad.Monad(function () {
      return applicativeCatList;
  }, function () {
      return bindCatList;
  });
  var bindCatList = new Control_Bind.Bind(function () {
      return applyCatList;
  }, Data_Function.flip(foldMap(monoidCatList)));
  var applyCatList = new Control_Apply.Apply(function () {
      return functorCatList;
  }, Control_Monad.ap(monadCatList));
  var applicativeCatList = new Control_Applicative.Applicative(function () {
      return applyCatList;
  }, singleton);

  /**
 *  | Convert any `Foldable` into a `CatList`.
 *  |
 *  | Running time: `O(n)`
 */  
  var fromFoldable = function (dictFoldable) {
      return function (f) {
          return Data_Foldable.foldMap(dictFoldable)(monoidCatList)(singleton)(f);
      };
  };

  /**
 *  | Append an element to the end of the catenable list, creating a new
 *  | catenable list.
 *  |
 *  | Running time: `O(1)`
 */  
  var snoc = function (cat) {
      return function (a) {
          return append(cat)(new CatCons(a, Data_CatQueue.empty));
      };
  };
  var unfoldableCatList = new Data_Unfoldable.Unfoldable(function (f) {
      return function (b) {
          var go = function (__copy_source) {
              return function (__copy_memo) {
                  var source = __copy_source;
                  var memo = __copy_memo;
                  tco: while (true) {
                      var $62 = f(source);
                      if ($62 instanceof Data_Maybe.Nothing) {
                          return memo;
                      };
                      if ($62 instanceof Data_Maybe.Just) {
                          var __tco_memo = snoc(memo)($62.value0.value0);
                          source = $62.value0.value1;
                          memo = __tco_memo;
                          continue tco;
                      };
                      throw new Error("Failed pattern match at Data.CatList line 165, column 24 - line 167, column 57: " + [ $62.constructor.name ]);
                  };
              };
          };
          return go(b)(CatNil.value);
      };
  });
  var altCatList = new Control_Alt.Alt(function () {
      return functorCatList;
  }, append);
  var plusCatList = new Control_Plus.Plus(function () {
      return altCatList;
  }, empty);
  var alternativeCatList = new Control_Alternative.Alternative(function () {
      return applicativeCatList;
  }, function () {
      return plusCatList;
  });
  var monadZeroCatList = new Control_MonadZero.MonadZero(function () {
      return alternativeCatList;
  }, function () {
      return monadCatList;
  });
  var monadPlusCatList = new Control_MonadPlus.MonadPlus(function () {
      return monadZeroCatList;
  });
  exports["CatNil"] = CatNil;
  exports["CatCons"] = CatCons;
  exports["append"] = append;
  exports["cons"] = cons;
  exports["empty"] = empty;
  exports["fromFoldable"] = fromFoldable;
  exports["null"] = $$null;
  exports["snoc"] = snoc;
  exports["uncons"] = uncons;
  exports["semigroupCatList"] = semigroupCatList;
  exports["monoidCatList"] = monoidCatList;
  exports["showCatList"] = showCatList;
  exports["foldableCatList"] = foldableCatList;
  exports["unfoldableCatList"] = unfoldableCatList;
  exports["traversableCatList"] = traversableCatList;
  exports["functorCatList"] = functorCatList;
  exports["applyCatList"] = applyCatList;
  exports["applicativeCatList"] = applicativeCatList;
  exports["bindCatList"] = bindCatList;
  exports["monadCatList"] = monadCatList;
  exports["altCatList"] = altCatList;
  exports["plusCatList"] = plusCatList;
  exports["alternativeCatList"] = alternativeCatList;
  exports["monadZeroCatList"] = monadZeroCatList;
  exports["monadPlusCatList"] = monadPlusCatList;
})(PS["Data.CatList"] = PS["Data.CatList"] || {});
(function(exports) {
    "use strict";
  var Prelude = PS["Prelude"];
  var Data_Bifunctor = PS["Data.Bifunctor"];
  var Data_Either = PS["Data.Either"];
  var Data_Foldable = PS["Data.Foldable"];
  var Data_Newtype = PS["Data.Newtype"];
  var Data_Traversable = PS["Data.Traversable"];
  var Data_Eq = PS["Data.Eq"];
  var Data_Ord = PS["Data.Ord"];
  var Data_Show = PS["Data.Show"];
  var Data_Semigroup = PS["Data.Semigroup"];
  var Data_Functor = PS["Data.Functor"];
  var Control_Semigroupoid = PS["Control.Semigroupoid"];        

  /**
 *  | `Coproduct f g` is the coproduct of two functors `f` and `g`
 */  
  var Coproduct = function (x) {
      return x;
  };
  var showCoproduct = function (dictShow) {
      return function (dictShow1) {
          return new Data_Show.Show(function (v) {
              if (v instanceof Data_Either.Left) {
                  return "(left " + (Data_Show.show(dictShow)(v.value0) + ")");
              };
              if (v instanceof Data_Either.Right) {
                  return "(right " + (Data_Show.show(dictShow1)(v.value0) + ")");
              };
              throw new Error("Failed pattern match at Data.Functor.Coproduct line 44, column 3 - line 45, column 3: " + [ v.constructor.name ]);
          });
      };
  };

  /**
 *  | Right injection
 */  
  var right = function (ga) {
      return new Data_Either.Right(ga);
  };
  var newtypeCoproduct = new Data_Newtype.Newtype(function (n) {
      return n;
  }, Coproduct);

  /**
 *  | Left injection
 */  
  var left = function (fa) {
      return new Data_Either.Left(fa);
  };
  var functorCoproduct = function (dictFunctor) {
      return function (dictFunctor1) {
          return new Data_Functor.Functor(function (f) {
              return function (v) {
                  return Data_Bifunctor.bimap(Data_Either.bifunctorEither)(Data_Functor.map(dictFunctor)(f))(Data_Functor.map(dictFunctor1)(f))(v);
              };
          });
      };
  };
  var eqCoproduct = function (dictEq) {
      return function (dictEq1) {
          return new Data_Eq.Eq(function (x) {
              return function (y) {
                  return Data_Eq.eq(Data_Either.eqEither(dictEq)(dictEq1))(x)(y);
              };
          });
      };
  };
  var ordCoproduct = function (dictOrd) {
      return function (dictOrd1) {
          return new Data_Ord.Ord(function () {
              return eqCoproduct(dictOrd["__superclass_Data.Eq.Eq_0"]())(dictOrd1["__superclass_Data.Eq.Eq_0"]());
          }, function (x) {
              return function (y) {
                  return Data_Ord.compare(Data_Either.ordEither(dictOrd)(dictOrd1))(x)(y);
              };
          });
      };
  };

  /**
 *  | Eliminate a coproduct by providing eliminators for the left and
 *  | right components
 */  
  var coproduct = function (v) {
      return function (v1) {
          return function (v2) {
              if (v2 instanceof Data_Either.Left) {
                  return v(v2.value0);
              };
              if (v2 instanceof Data_Either.Right) {
                  return v1(v2.value0);
              };
              throw new Error("Failed pattern match at Data.Functor.Coproduct line 25, column 1 - line 25, column 41: " + [ v.constructor.name, v1.constructor.name, v2.constructor.name ]);
          };
      };
  };
  var foldableCoproduct = function (dictFoldable) {
      return function (dictFoldable1) {
          return new Data_Foldable.Foldable(function (dictMonoid) {
              return function (f) {
                  return coproduct(Data_Foldable.foldMap(dictFoldable)(dictMonoid)(f))(Data_Foldable.foldMap(dictFoldable1)(dictMonoid)(f));
              };
          }, function (f) {
              return function (z) {
                  return coproduct(Data_Foldable.foldl(dictFoldable)(f)(z))(Data_Foldable.foldl(dictFoldable1)(f)(z));
              };
          }, function (f) {
              return function (z) {
                  return coproduct(Data_Foldable.foldr(dictFoldable)(f)(z))(Data_Foldable.foldr(dictFoldable1)(f)(z));
              };
          });
      };
  };
  var traversableCoproduct = function (dictTraversable) {
      return function (dictTraversable1) {
          return new Data_Traversable.Traversable(function () {
              return foldableCoproduct(dictTraversable["__superclass_Data.Foldable.Foldable_1"]())(dictTraversable1["__superclass_Data.Foldable.Foldable_1"]());
          }, function () {
              return functorCoproduct(dictTraversable["__superclass_Data.Functor.Functor_0"]())(dictTraversable1["__superclass_Data.Functor.Functor_0"]());
          }, function (dictApplicative) {
              return coproduct(function ($49) {
                  return Data_Functor.map((dictApplicative["__superclass_Control.Apply.Apply_0"]())["__superclass_Data.Functor.Functor_0"]())(function ($50) {
                      return Coproduct(Data_Either.Left.create($50));
                  })(Data_Traversable.sequence(dictTraversable)(dictApplicative)($49));
              })(function ($51) {
                  return Data_Functor.map((dictApplicative["__superclass_Control.Apply.Apply_0"]())["__superclass_Data.Functor.Functor_0"]())(function ($52) {
                      return Coproduct(Data_Either.Right.create($52));
                  })(Data_Traversable.sequence(dictTraversable1)(dictApplicative)($51));
              });
          }, function (dictApplicative) {
              return function (f) {
                  return coproduct(function ($53) {
                      return Data_Functor.map((dictApplicative["__superclass_Control.Apply.Apply_0"]())["__superclass_Data.Functor.Functor_0"]())(function ($54) {
                          return Coproduct(Data_Either.Left.create($54));
                      })(Data_Traversable.traverse(dictTraversable)(dictApplicative)(f)($53));
                  })(function ($55) {
                      return Data_Functor.map((dictApplicative["__superclass_Control.Apply.Apply_0"]())["__superclass_Data.Functor.Functor_0"]())(function ($56) {
                          return Coproduct(Data_Either.Right.create($56));
                      })(Data_Traversable.traverse(dictTraversable1)(dictApplicative)(f)($55));
                  });
              };
          });
      };
  };

  /**
 *  | Change the underlying functors in a coproduct
 */  
  var bihoistCoproduct = function (natF) {
      return function (natG) {
          return function (v) {
              return Data_Bifunctor.bimap(Data_Either.bifunctorEither)(natF)(natG)(v);
          };
      };
  };
  exports["Coproduct"] = Coproduct;
  exports["bihoistCoproduct"] = bihoistCoproduct;
  exports["coproduct"] = coproduct;
  exports["left"] = left;
  exports["right"] = right;
  exports["newtypeCoproduct"] = newtypeCoproduct;
  exports["eqCoproduct"] = eqCoproduct;
  exports["ordCoproduct"] = ordCoproduct;
  exports["showCoproduct"] = showCoproduct;
  exports["functorCoproduct"] = functorCoproduct;
  exports["foldableCoproduct"] = foldableCoproduct;
  exports["traversableCoproduct"] = traversableCoproduct;
})(PS["Data.Functor.Coproduct"] = PS["Data.Functor.Coproduct"] || {});
(function(exports) {
  
  /**
 *  | This module defines a type class `Inject` which is useful
 *  | when working with coproducts of functors.
 */  
  "use strict";
  var Prelude = PS["Prelude"];
  var Data_Either = PS["Data.Either"];
  var Data_Functor_Coproduct = PS["Data.Functor.Coproduct"];
  var Data_Maybe = PS["Data.Maybe"];
  var Control_Category = PS["Control.Category"];
  var Control_Semigroupoid = PS["Control.Semigroupoid"];
  var Data_Function = PS["Data.Function"];        

  /**
 *  | The `Inject` class asserts a coproduct relationship between two functors.
 *  |
 *  | Specifically, an instance `Inject f g` indicates that `g` is isomorphic to
 *  | a coproduct of `f` and some third functor.
 *  |
 *  | Laws:
 *  |
 *  | - `prj g = Just f` if and only if `inj f = g`
 */  
  var Inject = function (inj, prj) {
      this.inj = inj;
      this.prj = prj;
  };

  /**
 *  | The `Inject` class asserts a coproduct relationship between two functors.
 *  |
 *  | Specifically, an instance `Inject f g` indicates that `g` is isomorphic to
 *  | a coproduct of `f` and some third functor.
 *  |
 *  | Laws:
 *  |
 *  | - `prj g = Just f` if and only if `inj f = g`
 */  
  var prj = function (dict) {
      return dict.prj;
  };

  /**
 *  | Any functor is isomorphic to the coproduct of itself with the
 *  | constantly-`Void` functor.
 */  
  var injectReflexive = new Inject(Control_Category.id(Control_Category.categoryFn), Data_Maybe.Just.create);

  /**
 *  | Left injection
 */  
  var injectLeft = new Inject(function ($1) {
      return Data_Functor_Coproduct.Coproduct(Data_Either.Left.create($1));
  }, Data_Functor_Coproduct.coproduct(Data_Maybe.Just.create)(Data_Function["const"](Data_Maybe.Nothing.value)));

  /**
 *  | The `Inject` class asserts a coproduct relationship between two functors.
 *  |
 *  | Specifically, an instance `Inject f g` indicates that `g` is isomorphic to
 *  | a coproduct of `f` and some third functor.
 *  |
 *  | Laws:
 *  |
 *  | - `prj g = Just f` if and only if `inj f = g`
 */  
  var inj = function (dict) {
      return dict.inj;
  };

  /**
 *  | Right injection
 */  
  var injectRight = function (dictInject) {
      return new Inject(function ($2) {
          return Data_Functor_Coproduct.Coproduct(Data_Either.Right.create(inj(dictInject)($2)));
      }, Data_Functor_Coproduct.coproduct(Data_Function["const"](Data_Maybe.Nothing.value))(prj(dictInject)));
  };
  exports["Inject"] = Inject;
  exports["inj"] = inj;
  exports["prj"] = prj;
  exports["injectReflexive"] = injectReflexive;
  exports["injectLeft"] = injectLeft;
  exports["injectRight"] = injectRight;
})(PS["Data.Inject"] = PS["Data.Inject"] || {});
(function(exports) {
    "use strict";

  // module Unsafe.Coerce

  exports.unsafeCoerce = function (x) {
    return x;
  };
})(PS["Unsafe.Coerce"] = PS["Unsafe.Coerce"] || {});
(function(exports) {
    "use strict";
  var $foreign = PS["Unsafe.Coerce"];
  exports["unsafeCoerce"] = $foreign.unsafeCoerce;
})(PS["Unsafe.Coerce"] = PS["Unsafe.Coerce"] || {});
(function(exports) {
    "use strict";
  var Prelude = PS["Prelude"];
  var Control_Monad_Rec_Class = PS["Control.Monad.Rec.Class"];
  var Control_Monad_Trans_Class = PS["Control.Monad.Trans.Class"];
  var Data_CatList = PS["Data.CatList"];
  var Data_Either = PS["Data.Either"];
  var Data_Inject = PS["Data.Inject"];
  var Data_Maybe = PS["Data.Maybe"];
  var Data_Tuple = PS["Data.Tuple"];
  var Unsafe_Coerce = PS["Unsafe.Coerce"];
  var Data_Functor = PS["Data.Functor"];
  var Control_Bind = PS["Control.Bind"];
  var Control_Semigroupoid = PS["Control.Semigroupoid"];
  var Control_Applicative = PS["Control.Applicative"];
  var Control_Apply = PS["Control.Apply"];
  var Control_Monad = PS["Control.Monad"];
  var Data_Semigroup = PS["Data.Semigroup"];        
  var ExpF = function (x) {
      return x;
  };

  /**
 *  | The free monad for a type constructor `f`.
 *  |
 *  | Implemented in the spirit of [Relection without Remorse](http://okmij.org/ftp/Haskell/zseq.pdf),
 *  | the free monad is represented using a sequential data structure in
 *  | order to overcome the quadratic complexity of left-associated binds
 *  | and traversal through the free monad structure.
 */  
  var Free = (function () {
      function Free(value0, value1) {
          this.value0 = value0;
          this.value1 = value1;
      };
      Free.create = function (value0) {
          return function (value1) {
              return new Free(value0, value1);
          };
      };
      return Free;
  })();
  var Return = (function () {
      function Return(value0) {
          this.value0 = value0;
      };
      Return.create = function (value0) {
          return new Return(value0);
      };
      return Return;
  })();
  var Bind = (function () {
      function Bind(value0, value1) {
          this.value0 = value0;
          this.value1 = value1;
      };
      Bind.create = function (value0) {
          return function (value1) {
              return new Bind(value0, value1);
          };
      };
      return Bind;
  })();
  var toView = function (__copy_v) {
      var v = __copy_v;
      tco: while (true) {
          var runExpF = function (v2) {
              return v2;
          };
          var concatF = function (v2) {
              return function (r) {
                  return new Free(v2.value0, Data_Semigroup.append(Data_CatList.semigroupCatList)(v2.value1)(r));
              };
          };
          if (v.value0 instanceof Return) {
              var $21 = Data_CatList.uncons(v.value1);
              if ($21 instanceof Data_Maybe.Nothing) {
                  return new Return(Unsafe_Coerce.unsafeCoerce(v.value0.value0));
              };
              if ($21 instanceof Data_Maybe.Just) {
                  var __tco_v = Unsafe_Coerce.unsafeCoerce(concatF(runExpF($21.value0.value0)(v.value0.value0))($21.value0.value1));
                  v = __tco_v;
                  continue tco;
              };
              throw new Error("Failed pattern match at Control.Monad.Free line 173, column 7 - line 177, column 64: " + [ $21.constructor.name ]);
          };
          if (v.value0 instanceof Bind) {
              return new Bind(v.value0.value0, function (a) {
                  return Unsafe_Coerce.unsafeCoerce(concatF(v.value0.value1(a))(v.value1));
              });
          };
          throw new Error("Failed pattern match at Control.Monad.Free line 171, column 3 - line 179, column 56: " + [ v.value0.constructor.name ]);
      };
  };

  /**
 *  | Run a free monad with a function mapping a functor `f` to a tail-recursive
 *  | monad `m`. See the `MonadRec` type class for more details.
 */  
  var runFreeM = function (dictFunctor) {
      return function (dictMonadRec) {
          return function (k) {
              var go = function (f) {
                  var $30 = toView(f);
                  if ($30 instanceof Return) {
                      return Data_Functor.map((((dictMonadRec["__superclass_Control.Monad.Monad_0"]())["__superclass_Control.Bind.Bind_1"]())["__superclass_Control.Apply.Apply_0"]())["__superclass_Data.Functor.Functor_0"]())(Control_Monad_Rec_Class.Done.create)(Control_Applicative.pure((dictMonadRec["__superclass_Control.Monad.Monad_0"]())["__superclass_Control.Applicative.Applicative_0"]())($30.value0));
                  };
                  if ($30 instanceof Bind) {
                      return Data_Functor.map((((dictMonadRec["__superclass_Control.Monad.Monad_0"]())["__superclass_Control.Bind.Bind_1"]())["__superclass_Control.Apply.Apply_0"]())["__superclass_Data.Functor.Functor_0"]())(Control_Monad_Rec_Class.Loop.create)(k(Data_Functor.map(dictFunctor)($30.value1)($30.value0)));
                  };
                  throw new Error("Failed pattern match at Control.Monad.Free line 149, column 10 - line 151, column 37: " + [ $30.constructor.name ]);
              };
              return Control_Monad_Rec_Class.tailRecM(dictMonadRec)(go);
          };
      };
  };

  /**
 *  | Run a free monad with a function that unwraps a single layer of the functor
 *  | `f` at a time.
 */  
  var runFree = function (dictFunctor) {
      return function (k) {
          var go = function (__copy_f) {
              var f = __copy_f;
              tco: while (true) {
                  var $34 = toView(f);
                  if ($34 instanceof Return) {
                      return $34.value0;
                  };
                  if ($34 instanceof Bind) {
                      var __tco_f = k(Data_Functor.map(dictFunctor)($34.value1)($34.value0));
                      f = __tco_f;
                      continue tco;
                  };
                  throw new Error("Failed pattern match at Control.Monad.Free line 134, column 10 - line 136, column 33: " + [ $34.constructor.name ]);
              };
          };
          return go;
      };
  };

  /**
 *  | Unwraps a single layer of the functor `f`.
 */  
  var resume = function (dictFunctor) {
      return function (f) {
          var $38 = toView(f);
          if ($38 instanceof Return) {
              return new Data_Either.Right($38.value0);
          };
          if ($38 instanceof Bind) {
              return new Data_Either.Left(Data_Functor.map(dictFunctor)($38.value1)($38.value0));
          };
          throw new Error("Failed pattern match at Control.Monad.Free line 159, column 12 - line 161, column 29: " + [ $38.constructor.name ]);
      };
  };
  var fromView = function (f) {
      return new Free(Unsafe_Coerce.unsafeCoerce(f), Data_CatList.empty);
  };

  /**
 *  | Suspend a value given the applicative functor `f` into the free monad.
 */  
  var suspendF = function (dictApplicative) {
      return function (f) {
          return fromView(new Bind(Unsafe_Coerce.unsafeCoerce(Control_Applicative.pure(dictApplicative)(f)), Unsafe_Coerce.unsafeCoerce));
      };
  };
  var freeMonad = new Control_Monad.Monad(function () {
      return freeApplicative;
  }, function () {
      return freeBind;
  });
  var freeFunctor = new Data_Functor.Functor(function (k) {
      return function (f) {
          return Control_Bind.bindFlipped(freeBind)(function ($57) {
              return Control_Applicative.pure(freeApplicative)(k($57));
          })(f);
      };
  });
  var freeBind = new Control_Bind.Bind(function () {
      return freeApply;
  }, function (v) {
      return function (k) {
          return new Free(v.value0, Data_CatList.snoc(v.value1)(Unsafe_Coerce.unsafeCoerce(k)));
      };
  });
  var freeApply = new Control_Apply.Apply(function () {
      return freeFunctor;
  }, Control_Monad.ap(freeMonad));
  var freeApplicative = new Control_Applicative.Applicative(function () {
      return freeApply;
  }, function ($58) {
      return fromView(Return.create($58));
  });
  var freeMonadRec = new Control_Monad_Rec_Class.MonadRec(function () {
      return freeMonad;
  }, function (k) {
      return function (a) {
          return Control_Bind.bind(freeBind)(k(a))(function (v) {
              if (v instanceof Control_Monad_Rec_Class.Loop) {
                  return Control_Monad_Rec_Class.tailRecM(freeMonadRec)(k)(v.value0);
              };
              if (v instanceof Control_Monad_Rec_Class.Done) {
                  return Control_Applicative.pure(freeApplicative)(v.value0);
              };
              throw new Error("Failed pattern match at Control.Monad.Free line 63, column 26 - line 65, column 21: " + [ v.constructor.name ]);
          });
      };
  });

  /**
 *  | Lift an impure value described by the generating type constructor `f` into
 *  | the free monad.
 */  
  var liftF = function (f) {
      return fromView(new Bind(Unsafe_Coerce.unsafeCoerce(f), function ($59) {
          return Control_Applicative.pure(freeApplicative)(Unsafe_Coerce.unsafeCoerce($59));
      }));
  };
  var freeMonadTrans = new Control_Monad_Trans_Class.MonadTrans(function (dictMonad) {
      return liftF;
  });

  /**
 *  | Lift an action described by the generating type constructor `f` into
 *  | `Free g` using `Inject` to go from `f` to `g`.
 */  
  var liftFI = function (dictInject) {
      return function (fa) {
          return liftF(Data_Inject.inj(dictInject)(fa));
      };
  };

  /**
 *  | Like `foldFree`, but for folding into some other Free monad without the
 *  | overhead that `MonadRec` incurs.
 */  
  var substFree = function (k) {
      var go = function (f) {
          var $49 = toView(f);
          if ($49 instanceof Return) {
              return Control_Applicative.pure(freeApplicative)($49.value0);
          };
          if ($49 instanceof Bind) {
              return Control_Bind.bind(freeBind)(k($49.value0))(Data_Functor.map(Data_Functor.functorFn)(go)($49.value1));
          };
          throw new Error("Failed pattern match at Control.Monad.Free line 124, column 10 - line 126, column 33: " + [ $49.constructor.name ]);
      };
      return go;
  };

  /**
 *  | Use a natural transformation to change the generating type constructor of a
 *  | free monad.
 */  
  var hoistFree = function (k) {
      return substFree(function ($60) {
          return liftF(k($60));
      });
  };

  /**
 *  | Embed computations in one `Free` monad as computations in the `Free` monad
 *  | for a coproduct type constructor.
 *  |
 *  | This construction allows us to write computations which are polymorphic in
 *  | the particular `Free` monad we use, allowing us to extend the functionality
 *  | of our monad later.
 */  
  var injF = function (dictInject) {
      return hoistFree(Data_Inject.inj(dictInject));
  };

  /**
 *  | Run a free monad with a natural transformation from the type constructor `f`
 *  | to the tail-recursive monad `m`. See the `MonadRec` type class for more
 *  | details.
 */  
  var foldFree = function (dictMonadRec) {
      return function (k) {
          var go = function (f) {
              var $53 = toView(f);
              if ($53 instanceof Return) {
                  return Data_Functor.map((((dictMonadRec["__superclass_Control.Monad.Monad_0"]())["__superclass_Control.Bind.Bind_1"]())["__superclass_Control.Apply.Apply_0"]())["__superclass_Data.Functor.Functor_0"]())(Control_Monad_Rec_Class.Done.create)(Control_Applicative.pure((dictMonadRec["__superclass_Control.Monad.Monad_0"]())["__superclass_Control.Applicative.Applicative_0"]())($53.value0));
              };
              if ($53 instanceof Bind) {
                  return Data_Functor.map((((dictMonadRec["__superclass_Control.Monad.Monad_0"]())["__superclass_Control.Bind.Bind_1"]())["__superclass_Control.Apply.Apply_0"]())["__superclass_Data.Functor.Functor_0"]())(function ($61) {
                      return Control_Monad_Rec_Class.Loop.create($53.value1($61));
                  })(k($53.value0));
              };
              throw new Error("Failed pattern match at Control.Monad.Free line 114, column 10 - line 116, column 37: " + [ $53.constructor.name ]);
          };
          return Control_Monad_Rec_Class.tailRecM(dictMonadRec)(go);
      };
  };
  exports["foldFree"] = foldFree;
  exports["hoistFree"] = hoistFree;
  exports["injF"] = injF;
  exports["liftF"] = liftF;
  exports["liftFI"] = liftFI;
  exports["resume"] = resume;
  exports["runFree"] = runFree;
  exports["runFreeM"] = runFreeM;
  exports["substFree"] = substFree;
  exports["suspendF"] = suspendF;
  exports["freeFunctor"] = freeFunctor;
  exports["freeBind"] = freeBind;
  exports["freeApplicative"] = freeApplicative;
  exports["freeApply"] = freeApply;
  exports["freeMonad"] = freeMonad;
  exports["freeMonadTrans"] = freeMonadTrans;
  exports["freeMonadRec"] = freeMonadRec;
})(PS["Control.Monad.Free"] = PS["Control.Monad.Free"] || {});
(function(exports) {
  
  /**
 *  | This module defines the list monad transformer, `ListT`.
 */  
  "use strict";
  var Prelude = PS["Prelude"];
  var Control_Alt = PS["Control.Alt"];
  var Control_Alternative = PS["Control.Alternative"];
  var Control_Monad_Eff_Class = PS["Control.Monad.Eff.Class"];
  var Control_Monad_Trans_Class = PS["Control.Monad.Trans.Class"];
  var Control_MonadPlus = PS["Control.MonadPlus"];
  var Control_MonadZero = PS["Control.MonadZero"];
  var Control_Plus = PS["Control.Plus"];
  var Data_Lazy = PS["Data.Lazy"];
  var Data_Maybe = PS["Data.Maybe"];
  var Data_Monoid = PS["Data.Monoid"];
  var Data_Newtype = PS["Data.Newtype"];
  var Data_Tuple = PS["Data.Tuple"];
  var Data_Unfoldable = PS["Data.Unfoldable"];
  var Data_Semigroup = PS["Data.Semigroup"];
  var Data_Functor = PS["Data.Functor"];
  var Control_Applicative = PS["Control.Applicative"];
  var Control_Apply = PS["Control.Apply"];
  var Control_Monad = PS["Control.Monad"];
  var Control_Bind = PS["Control.Bind"];
  var Control_Semigroupoid = PS["Control.Semigroupoid"];
  var Data_Function = PS["Data.Function"];
  var Data_Ring = PS["Data.Ring"];
  var Control_Category = PS["Control.Category"];        

  /**
 *  | The result of a single step in a `ListT` computation. Either:
 *  |
 *  | - Computation has finished (`Done`), or
 *  | - A result has been returned, along with the next part of the computation (`Yield`).
 *  |
 *  | The `Skip` constructor allows us to avoid traversing lists during certain operations.
 */  
  var Yield = (function () {
      function Yield(value0, value1) {
          this.value0 = value0;
          this.value1 = value1;
      };
      Yield.create = function (value0) {
          return function (value1) {
              return new Yield(value0, value1);
          };
      };
      return Yield;
  })();

  /**
 *  | The result of a single step in a `ListT` computation. Either:
 *  |
 *  | - Computation has finished (`Done`), or
 *  | - A result has been returned, along with the next part of the computation (`Yield`).
 *  |
 *  | The `Skip` constructor allows us to avoid traversing lists during certain operations.
 */  
  var Skip = (function () {
      function Skip(value0) {
          this.value0 = value0;
      };
      Skip.create = function (value0) {
          return new Skip(value0);
      };
      return Skip;
  })();

  /**
 *  | The result of a single step in a `ListT` computation. Either:
 *  |
 *  | - Computation has finished (`Done`), or
 *  | - A result has been returned, along with the next part of the computation (`Yield`).
 *  |
 *  | The `Skip` constructor allows us to avoid traversing lists during certain operations.
 */  
  var Done = (function () {
      function Done() {

      };
      Done.value = new Done();
      return Done;
  })();

  /**
 *  | The list monad transformer.
 *  |
 *  | This monad transformer extends the base monad with _non-determinism_.
 *  | That is, the transformed monad supports the same effects as the base monad
 *  | but with multiple return values.
 */  
  var ListT = function (x) {
      return x;
  };

  /**
 *  | Defer evaluation of a list.
 */  
  var wrapLazy = function (dictApplicative) {
      return function (v) {
          return ListT(Control_Applicative.pure(dictApplicative)(new Skip(v)));
      };
  };

  /**
 *  | Lift a computation from the base monad.
 */  
  var wrapEffect = function (dictFunctor) {
      return function (v) {
          return ListT(Data_Functor.map(dictFunctor)(function ($166) {
              return Skip.create(Data_Lazy.defer(Data_Function["const"]($166)));
          })(v));
      };
  };
  var unfold = function (dictMonad) {
      return function (f) {
          return function (z) {
              var g = function (v) {
                  if (v instanceof Data_Maybe.Just) {
                      return new Yield(v.value0.value1, Data_Lazy.defer(function (v1) {
                          return unfold(dictMonad)(f)(v.value0.value0);
                      }));
                  };
                  if (v instanceof Data_Maybe.Nothing) {
                      return Done.value;
                  };
                  throw new Error("Failed pattern match at Control.Monad.List.Trans line 120, column 3 - line 120, column 58: " + [ v.constructor.name ]);
              };
              return ListT(Data_Functor.map(((dictMonad["__superclass_Control.Bind.Bind_1"]())["__superclass_Control.Apply.Apply_0"]())["__superclass_Data.Functor.Functor_0"]())(g)(f(z)));
          };
      };
  };
  var uncons = function (dictMonad) {
      return function (v) {
          var g = function (v1) {
              if (v1 instanceof Yield) {
                  return Control_Applicative.pure(dictMonad["__superclass_Control.Applicative.Applicative_0"]())(Data_Maybe.Just.create(new Data_Tuple.Tuple(v1.value0, Data_Lazy.force(v1.value1))));
              };
              if (v1 instanceof Skip) {
                  return uncons(dictMonad)(Data_Lazy.force(v1.value0));
              };
              if (v1 instanceof Done) {
                  return Control_Applicative.pure(dictMonad["__superclass_Control.Applicative.Applicative_0"]())(Data_Maybe.Nothing.value);
              };
              throw new Error("Failed pattern match at Control.Monad.List.Trans line 185, column 3 - line 185, column 50: " + [ v1.constructor.name ]);
          };
          return Control_Bind.bind(dictMonad["__superclass_Control.Bind.Bind_1"]())(v)(g);
      };
  };

  /**
 *  | Extract all but the first element of a list.
 */  
  var tail = function (dictMonad) {
      return function (l) {
          return Data_Functor.map(((dictMonad["__superclass_Control.Bind.Bind_1"]())["__superclass_Control.Apply.Apply_0"]())["__superclass_Data.Functor.Functor_0"]())(Data_Functor.map(Data_Maybe.functorMaybe)(Data_Tuple.snd))(uncons(dictMonad)(l));
      };
  };

  /**
 *  | Lift a computation on list steps to a computation on whole lists.
 */  
  var stepMap = function (dictFunctor) {
      return function (f) {
          return function (v) {
              return ListT(Data_Functor.map(dictFunctor)(f)(v));
          };
      };
  };
  var takeWhile = function (dictApplicative) {
      return function (f) {
          var g = function (v) {
              if (v instanceof Yield) {
                  var $90 = f(v.value0);
                  if ($90) {
                      return new Yield(v.value0, Data_Functor.map(Data_Lazy.functorLazy)(takeWhile(dictApplicative)(f))(v.value1));
                  };
                  if (!$90) {
                      return Done.value;
                  };
                  throw new Error("Failed pattern match at Control.Monad.List.Trans line 144, column 19 - line 144, column 68: " + [ $90.constructor.name ]);
              };
              if (v instanceof Skip) {
                  return Skip.create(Data_Functor.map(Data_Lazy.functorLazy)(takeWhile(dictApplicative)(f))(v.value0));
              };
              if (v instanceof Done) {
                  return Done.value;
              };
              throw new Error("Failed pattern match at Control.Monad.List.Trans line 144, column 3 - line 144, column 68: " + [ v.constructor.name ]);
          };
          return stepMap((dictApplicative["__superclass_Control.Apply.Apply_0"]())["__superclass_Data.Functor.Functor_0"]())(g);
      };
  };

  /**
 *  | Fold a list from the left, accumulating the list of results using the specified function.
 */  
  var scanl = function (dictMonad) {
      return function (f) {
          return function (b) {
              return function (l) {
                  var g = function (v) {
                      var h = function (v1) {
                          if (v1 instanceof Yield) {
                              var b$prime$prime = f(v.value0)(v1.value0);
                              return Data_Maybe.Just.create(new Data_Tuple.Tuple(new Data_Tuple.Tuple(b$prime$prime, Data_Lazy.force(v1.value1)), v.value0));
                          };
                          if (v1 instanceof Skip) {
                              return Data_Maybe.Just.create(new Data_Tuple.Tuple(new Data_Tuple.Tuple(v.value0, Data_Lazy.force(v1.value0)), v.value0));
                          };
                          if (v1 instanceof Done) {
                              return Data_Maybe.Nothing.value;
                          };
                          throw new Error("Failed pattern match at Control.Monad.List.Trans line 219, column 5 - line 219, column 78: " + [ v1.constructor.name ]);
                      };
                      return Data_Functor.map(((dictMonad["__superclass_Control.Bind.Bind_1"]())["__superclass_Control.Apply.Apply_0"]())["__superclass_Data.Functor.Functor_0"]())(h)(v.value1);
                  };
                  return unfold(dictMonad)(g)(new Data_Tuple.Tuple(b, l));
              };
          };
      };
  };

  /**
 *  | Run a computation in the `ListT` monad.
 */  
  var runListT = function (v) {
      return v;
  };

  /**
 *  | Prepend an element to a lazily-evaluated list.
 */  
  var prepend$prime = function (dictApplicative) {
      return function (h) {
          return function (t) {
              return ListT(Control_Applicative.pure(dictApplicative)(new Yield(h, t)));
          };
      };
  };

  /**
 *  | Prepend an element to a list.
 */  
  var prepend = function (dictApplicative) {
      return function (h) {
          return function (t) {
              return prepend$prime(dictApplicative)(h)(Data_Lazy.defer(Data_Function["const"](t)));
          };
      };
  };

  /**
 *  | The empty list.
 */  
  var nil = function (dictApplicative) {
      return ListT(Control_Applicative.pure(dictApplicative)(Done.value));
  };

  /**
 *  | Create a list with one element.
 */  
  var singleton = function (dictApplicative) {
      return function (a) {
          return prepend(dictApplicative)(a)(nil(dictApplicative));
      };
  };
  var take = function (dictApplicative) {
      return function (v) {
          return function (fa) {
              if (v === 0) {
                  return nil(dictApplicative);
              };
              var f = function (v1) {
                  if (v1 instanceof Yield) {
                      return new Yield(v1.value0, Data_Functor.map(Data_Lazy.functorLazy)(take(dictApplicative)(v - 1))(v1.value1));
                  };
                  if (v1 instanceof Skip) {
                      return new Skip(Data_Functor.map(Data_Lazy.functorLazy)(take(dictApplicative)(v))(v1.value0));
                  };
                  if (v1 instanceof Done) {
                      return Done.value;
                  };
                  throw new Error("Failed pattern match at Control.Monad.List.Trans line 137, column 3 - line 137, column 47: " + [ v1.constructor.name ]);
              };
              return stepMap((dictApplicative["__superclass_Control.Apply.Apply_0"]())["__superclass_Data.Functor.Functor_0"]())(f)(fa);
          };
      };
  };
  var zipWith$prime = function (dictMonad) {
      return function (f) {
          var g = function (v) {
              return function (v1) {
                  if (v1 instanceof Data_Maybe.Nothing) {
                      return Control_Applicative.pure(dictMonad["__superclass_Control.Applicative.Applicative_0"]())(nil(dictMonad["__superclass_Control.Applicative.Applicative_0"]()));
                  };
                  if (v instanceof Data_Maybe.Nothing) {
                      return Control_Applicative.pure(dictMonad["__superclass_Control.Applicative.Applicative_0"]())(nil(dictMonad["__superclass_Control.Applicative.Applicative_0"]()));
                  };
                  if (v instanceof Data_Maybe.Just && v1 instanceof Data_Maybe.Just) {
                      return Data_Functor.map(((dictMonad["__superclass_Control.Bind.Bind_1"]())["__superclass_Control.Apply.Apply_0"]())["__superclass_Data.Functor.Functor_0"]())(Data_Function.flip(prepend$prime(dictMonad["__superclass_Control.Applicative.Applicative_0"]()))(Data_Lazy.defer(function (v2) {
                          return zipWith$prime(dictMonad)(f)(v.value0.value1)(v1.value0.value1);
                      })))(f(v.value0.value0)(v1.value0.value0));
                  };
                  throw new Error("Failed pattern match at Control.Monad.List.Trans line 226, column 3 - line 229, column 12: " + [ v.constructor.name, v1.constructor.name ]);
              };
          };
          var loop = function (fa) {
              return function (fb) {
                  return wrapEffect(((dictMonad["__superclass_Control.Bind.Bind_1"]())["__superclass_Control.Apply.Apply_0"]())["__superclass_Data.Functor.Functor_0"]())(Control_Bind.bind(dictMonad["__superclass_Control.Bind.Bind_1"]())(uncons(dictMonad)(fa))(function (v) {
                      return Control_Bind.bind(dictMonad["__superclass_Control.Bind.Bind_1"]())(uncons(dictMonad)(fb))(function (v1) {
                          return g(v)(v1);
                      });
                  }));
              };
          };
          return loop;
      };
  };

  /**
 *  | Zip the elements of two lists, combining elements at the same position from each list.
 */  
  var zipWith = function (dictMonad) {
      return function (f) {
          var g = function (a) {
              return function (b) {
                  return Control_Applicative.pure(dictMonad["__superclass_Control.Applicative.Applicative_0"]())(f(a)(b));
              };
          };
          return zipWith$prime(dictMonad)(g);
      };
  };
  var newtypeListT = new Data_Newtype.Newtype(function (n) {
      return n;
  }, ListT);
  var mapMaybe = function (dictFunctor) {
      return function (f) {
          var g = function (v) {
              if (v instanceof Yield) {
                  return Data_Maybe.fromMaybe(Skip.create)(Data_Functor.map(Data_Maybe.functorMaybe)(Yield.create)(f(v.value0)))(Data_Functor.map(Data_Lazy.functorLazy)(mapMaybe(dictFunctor)(f))(v.value1));
              };
              if (v instanceof Skip) {
                  return Skip.create(Data_Functor.map(Data_Lazy.functorLazy)(mapMaybe(dictFunctor)(f))(v.value0));
              };
              if (v instanceof Done) {
                  return Done.value;
              };
              throw new Error("Failed pattern match at Control.Monad.List.Trans line 173, column 3 - line 173, column 72: " + [ v.constructor.name ]);
          };
          return stepMap(dictFunctor)(g);
      };
  };

  /**
 *  | Generate an infinite list by iterating a function.
 */  
  var iterate = function (dictMonad) {
      return function (f) {
          return function (a) {
              var g = function (a1) {
                  return Control_Applicative.pure(dictMonad["__superclass_Control.Applicative.Applicative_0"]())(new Data_Maybe.Just(new Data_Tuple.Tuple(f(a1), a1)));
              };
              return unfold(dictMonad)(g)(a);
          };
      };
  };

  /**
 *  | Generate an infinite list by repeating a value.
 */  
  var repeat = function (dictMonad) {
      return iterate(dictMonad)(Control_Category.id(Control_Category.categoryFn));
  };

  /**
 *  | Extract the first element of a list.
 */  
  var head = function (dictMonad) {
      return function (l) {
          return Data_Functor.map(((dictMonad["__superclass_Control.Bind.Bind_1"]())["__superclass_Control.Apply.Apply_0"]())["__superclass_Data.Functor.Functor_0"]())(Data_Functor.map(Data_Maybe.functorMaybe)(Data_Tuple.fst))(uncons(dictMonad)(l));
      };
  };
  var functorListT = function (dictFunctor) {
      return new Data_Functor.Functor(function (f) {
          var g = function (v) {
              if (v instanceof Yield) {
                  return new Yield(f(v.value0), Data_Functor.map(Data_Lazy.functorLazy)(Data_Functor.map(functorListT(dictFunctor))(f))(v.value1));
              };
              if (v instanceof Skip) {
                  return new Skip(Data_Functor.map(Data_Lazy.functorLazy)(Data_Functor.map(functorListT(dictFunctor))(f))(v.value0));
              };
              if (v instanceof Done) {
                  return Done.value;
              };
              throw new Error("Failed pattern match at Control.Monad.List.Trans line 251, column 5 - line 251, column 48: " + [ v.constructor.name ]);
          };
          return stepMap(dictFunctor)(g);
      });
  };

  /**
 *  | Lift a computation from the base functor.
 */  
  var fromEffect = function (dictApplicative) {
      return function (fa) {
          return ListT(Data_Functor.map((dictApplicative["__superclass_Control.Apply.Apply_0"]())["__superclass_Data.Functor.Functor_0"]())(Data_Function.flip(Yield.create)(Data_Lazy.defer(function (v) {
              return nil(dictApplicative);
          })))(fa));
      };
  };
  var monadTransListT = new Control_Monad_Trans_Class.MonadTrans(function (dictMonad) {
      return fromEffect(dictMonad["__superclass_Control.Applicative.Applicative_0"]());
  });

  /**
 *  | Fold a list from the left, accumulating the result (effectfully) using the specified function.
 */  
  var foldl$prime = function (dictMonad) {
      return function (f) {
          var loop = function (b) {
              return function (l) {
                  var g = function (v) {
                      if (v instanceof Data_Maybe.Nothing) {
                          return Control_Applicative.pure(dictMonad["__superclass_Control.Applicative.Applicative_0"]())(b);
                      };
                      if (v instanceof Data_Maybe.Just) {
                          return Control_Bind.bind(dictMonad["__superclass_Control.Bind.Bind_1"]())(f(b)(v.value0.value0))(Data_Function.flip(loop)(v.value0.value1));
                      };
                      throw new Error("Failed pattern match at Control.Monad.List.Trans line 202, column 5 - line 202, column 35: " + [ v.constructor.name ]);
                  };
                  return Control_Bind.bind(dictMonad["__superclass_Control.Bind.Bind_1"]())(uncons(dictMonad)(l))(g);
              };
          };
          return loop;
      };
  };

  /**
 *  | Fold a list from the left, accumulating the result using the specified function.
 */  
  var foldl = function (dictMonad) {
      return function (f) {
          var loop = function (b) {
              return function (l) {
                  var g = function (v) {
                      if (v instanceof Data_Maybe.Nothing) {
                          return Control_Applicative.pure(dictMonad["__superclass_Control.Applicative.Applicative_0"]())(b);
                      };
                      if (v instanceof Data_Maybe.Just) {
                          return loop(f(b)(v.value0.value0))(v.value0.value1);
                      };
                      throw new Error("Failed pattern match at Control.Monad.List.Trans line 210, column 5 - line 210, column 35: " + [ v.constructor.name ]);
                  };
                  return Control_Bind.bind(dictMonad["__superclass_Control.Bind.Bind_1"]())(uncons(dictMonad)(l))(g);
              };
          };
          return loop;
      };
  };
  var filter = function (dictFunctor) {
      return function (f) {
          var g = function (v) {
              if (v instanceof Yield) {
                  var s$prime = Data_Functor.map(Data_Lazy.functorLazy)(filter(dictFunctor)(f))(v.value1);
                  var $138 = f(v.value0);
                  if ($138) {
                      return new Yield(v.value0, s$prime);
                  };
                  if (!$138) {
                      return new Skip(s$prime);
                  };
                  throw new Error("Failed pattern match at Control.Monad.List.Trans line 166, column 19 - line 166, column 54: " + [ $138.constructor.name ]);
              };
              if (v instanceof Skip) {
                  var s$prime = Data_Functor.map(Data_Lazy.functorLazy)(filter(dictFunctor)(f))(v.value0);
                  return new Skip(s$prime);
              };
              if (v instanceof Done) {
                  return Done.value;
              };
              throw new Error("Failed pattern match at Control.Monad.List.Trans line 166, column 3 - line 166, column 80: " + [ v.constructor.name ]);
          };
          return stepMap(dictFunctor)(g);
      };
  };
  var dropWhile = function (dictApplicative) {
      return function (f) {
          var g = function (v) {
              if (v instanceof Yield) {
                  var $143 = f(v.value0);
                  if ($143) {
                      return new Skip(Data_Functor.map(Data_Lazy.functorLazy)(dropWhile(dictApplicative)(f))(v.value1));
                  };
                  if (!$143) {
                      return new Yield(v.value0, v.value1);
                  };
                  throw new Error("Failed pattern match at Control.Monad.List.Trans line 159, column 19 - line 159, column 70: " + [ $143.constructor.name ]);
              };
              if (v instanceof Skip) {
                  return Skip.create(Data_Functor.map(Data_Lazy.functorLazy)(dropWhile(dictApplicative)(f))(v.value0));
              };
              if (v instanceof Done) {
                  return Done.value;
              };
              throw new Error("Failed pattern match at Control.Monad.List.Trans line 159, column 3 - line 159, column 70: " + [ v.constructor.name ]);
          };
          return stepMap((dictApplicative["__superclass_Control.Apply.Apply_0"]())["__superclass_Data.Functor.Functor_0"]())(g);
      };
  };
  var drop = function (dictApplicative) {
      return function (v) {
          return function (fa) {
              if (v === 0) {
                  return fa;
              };
              var f = function (v1) {
                  if (v1 instanceof Yield) {
                      return new Skip(Data_Functor.map(Data_Lazy.functorLazy)(drop(dictApplicative)(v - 1))(v1.value1));
                  };
                  if (v1 instanceof Skip) {
                      return new Skip(Data_Functor.map(Data_Lazy.functorLazy)(drop(dictApplicative)(v))(v1.value0));
                  };
                  if (v1 instanceof Done) {
                      return Done.value;
                  };
                  throw new Error("Failed pattern match at Control.Monad.List.Trans line 152, column 3 - line 152, column 44: " + [ v1.constructor.name ]);
              };
              return stepMap((dictApplicative["__superclass_Control.Apply.Apply_0"]())["__superclass_Data.Functor.Functor_0"]())(f)(fa);
          };
      };
  };

  /**
 *  | Attach an element to the front of a list.
 */  
  var cons = function (dictApplicative) {
      return function (lh) {
          return function (t) {
              return ListT(Control_Applicative.pure(dictApplicative)(new Yield(Data_Lazy.force(lh), t)));
          };
      };
  };
  var unfoldableListT = function (dictMonad) {
      return new Data_Unfoldable.Unfoldable(function (f) {
          return function (b) {
              var go = function (v) {
                  if (v instanceof Data_Maybe.Nothing) {
                      return nil(dictMonad["__superclass_Control.Applicative.Applicative_0"]());
                  };
                  if (v instanceof Data_Maybe.Just) {
                      return cons(dictMonad["__superclass_Control.Applicative.Applicative_0"]())(Control_Applicative.pure(Data_Lazy.applicativeLazy)(v.value0.value0))(Data_Lazy.defer(function (v1) {
                          return go(f(v.value0.value1));
                      }));
                  };
                  throw new Error("Failed pattern match at Control.Monad.List.Trans line 256, column 3 - line 258, column 73: " + [ v.constructor.name ]);
              };
              return go(f(b));
          };
      });
  };
  var semigroupListT = function (dictApplicative) {
      return new Data_Semigroup.Semigroup(concat(dictApplicative));
  };
  var concat = function (dictApplicative) {
      return function (x) {
          return function (y) {
              var f = function (v) {
                  if (v instanceof Yield) {
                      return new Yield(v.value0, Data_Functor.map(Data_Lazy.functorLazy)(function (v1) {
                          return Data_Semigroup.append(semigroupListT(dictApplicative))(v1)(y);
                      })(v.value1));
                  };
                  if (v instanceof Skip) {
                      return new Skip(Data_Functor.map(Data_Lazy.functorLazy)(function (v1) {
                          return Data_Semigroup.append(semigroupListT(dictApplicative))(v1)(y);
                      })(v.value0));
                  };
                  if (v instanceof Done) {
                      return new Skip(Data_Lazy.defer(Data_Function["const"](y)));
                  };
                  throw new Error("Failed pattern match at Control.Monad.List.Trans line 96, column 3 - line 96, column 43: " + [ v.constructor.name ]);
              };
              return stepMap((dictApplicative["__superclass_Control.Apply.Apply_0"]())["__superclass_Data.Functor.Functor_0"]())(f)(x);
          };
      };
  };
  var monoidListT = function (dictApplicative) {
      return new Data_Monoid.Monoid(function () {
          return semigroupListT(dictApplicative);
      }, nil(dictApplicative));
  };

  /**
 *  | Remove elements from a list which do not contain a value.
 */  
  var catMaybes = function (dictFunctor) {
      return mapMaybe(dictFunctor)(Control_Category.id(Control_Category.categoryFn));
  };
  var monadListT = function (dictMonad) {
      return new Control_Monad.Monad(function () {
          return applicativeListT(dictMonad);
      }, function () {
          return bindListT(dictMonad);
      });
  };
  var bindListT = function (dictMonad) {
      return new Control_Bind.Bind(function () {
          return applyListT(dictMonad);
      }, function (fa) {
          return function (f) {
              var g = function (v) {
                  if (v instanceof Yield) {
                      var h = function (s1) {
                          return Data_Semigroup.append(semigroupListT(dictMonad["__superclass_Control.Applicative.Applicative_0"]()))(f(v.value0))(Control_Bind.bind(bindListT(dictMonad))(s1)(f));
                      };
                      return new Skip(Data_Functor.map(Data_Lazy.functorLazy)(h)(v.value1));
                  };
                  if (v instanceof Skip) {
                      return new Skip(Data_Functor.map(Data_Lazy.functorLazy)(function (v1) {
                          return Control_Bind.bind(bindListT(dictMonad))(v1)(f);
                      })(v.value0));
                  };
                  if (v instanceof Done) {
                      return Done.value;
                  };
                  throw new Error("Failed pattern match at Control.Monad.List.Trans line 268, column 5 - line 270, column 29: " + [ v.constructor.name ]);
              };
              return stepMap(((dictMonad["__superclass_Control.Bind.Bind_1"]())["__superclass_Control.Apply.Apply_0"]())["__superclass_Data.Functor.Functor_0"]())(g)(fa);
          };
      });
  };
  var applyListT = function (dictMonad) {
      return new Control_Apply.Apply(function () {
          return functorListT(((dictMonad["__superclass_Control.Bind.Bind_1"]())["__superclass_Control.Apply.Apply_0"]())["__superclass_Data.Functor.Functor_0"]());
      }, Control_Monad.ap(monadListT(dictMonad)));
  };
  var applicativeListT = function (dictMonad) {
      return new Control_Applicative.Applicative(function () {
          return applyListT(dictMonad);
      }, singleton(dictMonad["__superclass_Control.Applicative.Applicative_0"]()));
  };
  var monadEffListT = function (dictMonadEff) {
      return new Control_Monad_Eff_Class.MonadEff(function () {
          return monadListT(dictMonadEff["__superclass_Control.Monad.Monad_0"]());
      }, function ($167) {
          return Control_Monad_Trans_Class.lift(monadTransListT)(dictMonadEff["__superclass_Control.Monad.Monad_0"]())(Control_Monad_Eff_Class.liftEff(dictMonadEff)($167));
      });
  };
  var altListT = function (dictApplicative) {
      return new Control_Alt.Alt(function () {
          return functorListT((dictApplicative["__superclass_Control.Apply.Apply_0"]())["__superclass_Data.Functor.Functor_0"]());
      }, concat(dictApplicative));
  };
  var plusListT = function (dictMonad) {
      return new Control_Plus.Plus(function () {
          return altListT(dictMonad["__superclass_Control.Applicative.Applicative_0"]());
      }, nil(dictMonad["__superclass_Control.Applicative.Applicative_0"]()));
  };
  var alternativeListT = function (dictMonad) {
      return new Control_Alternative.Alternative(function () {
          return applicativeListT(dictMonad);
      }, function () {
          return plusListT(dictMonad);
      });
  };
  var monadZeroListT = function (dictMonad) {
      return new Control_MonadZero.MonadZero(function () {
          return alternativeListT(dictMonad);
      }, function () {
          return monadListT(dictMonad);
      });
  };
  var monadPlusListT = function (dictMonad) {
      return new Control_MonadPlus.MonadPlus(function () {
          return monadZeroListT(dictMonad);
      });
  };
  exports["catMaybes"] = catMaybes;
  exports["cons"] = cons;
  exports["drop"] = drop;
  exports["dropWhile"] = dropWhile;
  exports["filter"] = filter;
  exports["foldl"] = foldl;
  exports["foldl'"] = foldl$prime;
  exports["fromEffect"] = fromEffect;
  exports["head"] = head;
  exports["iterate"] = iterate;
  exports["mapMaybe"] = mapMaybe;
  exports["nil"] = nil;
  exports["prepend"] = prepend;
  exports["prepend'"] = prepend$prime;
  exports["repeat"] = repeat;
  exports["scanl"] = scanl;
  exports["singleton"] = singleton;
  exports["tail"] = tail;
  exports["take"] = take;
  exports["takeWhile"] = takeWhile;
  exports["uncons"] = uncons;
  exports["unfold"] = unfold;
  exports["wrapEffect"] = wrapEffect;
  exports["wrapLazy"] = wrapLazy;
  exports["zipWith"] = zipWith;
  exports["zipWith'"] = zipWith$prime;
  exports["semigroupListT"] = semigroupListT;
  exports["monoidListT"] = monoidListT;
  exports["functorListT"] = functorListT;
  exports["unfoldableListT"] = unfoldableListT;
  exports["applyListT"] = applyListT;
  exports["applicativeListT"] = applicativeListT;
  exports["bindListT"] = bindListT;
  exports["monadListT"] = monadListT;
  exports["monadTransListT"] = monadTransListT;
  exports["altListT"] = altListT;
  exports["plusListT"] = plusListT;
  exports["alternativeListT"] = alternativeListT;
  exports["monadZeroListT"] = monadZeroListT;
  exports["monadPlusListT"] = monadPlusListT;
  exports["monadEffListT"] = monadEffListT;
})(PS["Control.Monad.List.Trans"] = PS["Control.Monad.List.Trans"] || {});
(function(exports) {
  
  /**
 *  | This module defines the `MaybeT` monad transformer.
 */  
  "use strict";
  var Prelude = PS["Prelude"];
  var Control_Alt = PS["Control.Alt"];
  var Control_Alternative = PS["Control.Alternative"];
  var Control_Monad_Cont_Class = PS["Control.Monad.Cont.Class"];
  var Control_Monad_Eff_Class = PS["Control.Monad.Eff.Class"];
  var Control_Monad_Error_Class = PS["Control.Monad.Error.Class"];
  var Control_Monad_Reader_Class = PS["Control.Monad.Reader.Class"];
  var Control_Monad_Rec_Class = PS["Control.Monad.Rec.Class"];
  var Control_Monad_State_Class = PS["Control.Monad.State.Class"];
  var Control_Monad_Trans_Class = PS["Control.Monad.Trans.Class"];
  var Control_Monad_Writer_Class = PS["Control.Monad.Writer.Class"];
  var Control_MonadPlus = PS["Control.MonadPlus"];
  var Control_MonadZero = PS["Control.MonadZero"];
  var Control_Plus = PS["Control.Plus"];
  var Data_Maybe = PS["Data.Maybe"];
  var Data_Newtype = PS["Data.Newtype"];
  var Data_Tuple = PS["Data.Tuple"];
  var Data_Functor = PS["Data.Functor"];
  var Control_Apply = PS["Control.Apply"];
  var Control_Monad = PS["Control.Monad"];
  var Control_Applicative = PS["Control.Applicative"];
  var Control_Semigroupoid = PS["Control.Semigroupoid"];
  var Control_Bind = PS["Control.Bind"];
  var Data_Function = PS["Data.Function"];
  var Control_Category = PS["Control.Category"];        

  /**
 *  | The `MaybeT` monad transformer.
 *  |
 *  | This monad transformer extends the base monad, supporting failure and alternation via
 *  | the `MonadPlus` type class.
 */  
  var MaybeT = function (x) {
      return x;
  };

  /**
 *  | Run a computation in the `MaybeT` monad.
 */  
  var runMaybeT = function (v) {
      return v;
  };
  var newtypeMaybeT = new Data_Newtype.Newtype(function (n) {
      return n;
  }, MaybeT);
  var monadTransMaybeT = new Control_Monad_Trans_Class.MonadTrans(function (dictMonad) {
      return function ($66) {
          return MaybeT(Control_Monad.liftM1(dictMonad)(Data_Maybe.Just.create)($66));
      };
  });

  /**
 *  | Change the result type of a `MaybeT` monad action.
 */  
  var mapMaybeT = function (f) {
      return function (v) {
          return f(v);
      };
  };
  var functorMaybeT = function (dictFunctor) {
      return new Data_Functor.Functor(function (f) {
          return function (v) {
              return Data_Functor.map(dictFunctor)(Data_Functor.map(Data_Maybe.functorMaybe)(f))(v);
          };
      });
  };
  var monadMaybeT = function (dictMonad) {
      return new Control_Monad.Monad(function () {
          return applicativeMaybeT(dictMonad);
      }, function () {
          return bindMaybeT(dictMonad);
      });
  };
  var bindMaybeT = function (dictMonad) {
      return new Control_Bind.Bind(function () {
          return applyMaybeT(dictMonad);
      }, function (v) {
          return function (f) {
              return Control_Bind.bind(dictMonad["__superclass_Control.Bind.Bind_1"]())(v)(function (v1) {
                  if (v1 instanceof Data_Maybe.Nothing) {
                      return Control_Applicative.pure(dictMonad["__superclass_Control.Applicative.Applicative_0"]())(Data_Maybe.Nothing.value);
                  };
                  if (v1 instanceof Data_Maybe.Just) {
                      var $42 = f(v1.value0);
                      return $42;
                  };
                  throw new Error("Failed pattern match at Control.Monad.Maybe.Trans line 55, column 11 - line 57, column 42: " + [ v1.constructor.name ]);
              });
          };
      });
  };
  var applyMaybeT = function (dictMonad) {
      return new Control_Apply.Apply(function () {
          return functorMaybeT(((dictMonad["__superclass_Control.Bind.Bind_1"]())["__superclass_Control.Apply.Apply_0"]())["__superclass_Data.Functor.Functor_0"]());
      }, Control_Monad.ap(monadMaybeT(dictMonad)));
  };
  var applicativeMaybeT = function (dictMonad) {
      return new Control_Applicative.Applicative(function () {
          return applyMaybeT(dictMonad);
      }, function ($67) {
          return MaybeT(Control_Applicative.pure(dictMonad["__superclass_Control.Applicative.Applicative_0"]())(Data_Maybe.Just.create($67)));
      });
  };
  var monadAskMaybeT = function (dictMonadAsk) {
      return new Control_Monad_Reader_Class.MonadAsk(function () {
          return monadMaybeT(dictMonadAsk["__superclass_Control.Monad.Monad_0"]());
      }, Control_Monad_Trans_Class.lift(monadTransMaybeT)(dictMonadAsk["__superclass_Control.Monad.Monad_0"]())(Control_Monad_Reader_Class.ask(dictMonadAsk)));
  };
  var monadReaderMaybeT = function (dictMonadReader) {
      return new Control_Monad_Reader_Class.MonadReader(function () {
          return monadAskMaybeT(dictMonadReader["__superclass_Control.Monad.Reader.Class.MonadAsk_0"]());
      }, function (f) {
          return mapMaybeT(Control_Monad_Reader_Class.local(dictMonadReader)(f));
      });
  };
  var monadContMaybeT = function (dictMonadCont) {
      return new Control_Monad_Cont_Class.MonadCont(function () {
          return monadMaybeT(dictMonadCont["__superclass_Control.Monad.Monad_0"]());
      }, function (f) {
          return MaybeT(Control_Monad_Cont_Class.callCC(dictMonadCont)(function (c) {
              var $44 = f(function (a) {
                  return MaybeT(c(new Data_Maybe.Just(a)));
              });
              return $44;
          }));
      });
  };
  var monadEffMaybe = function (dictMonadEff) {
      return new Control_Monad_Eff_Class.MonadEff(function () {
          return monadMaybeT(dictMonadEff["__superclass_Control.Monad.Monad_0"]());
      }, function ($68) {
          return Control_Monad_Trans_Class.lift(monadTransMaybeT)(dictMonadEff["__superclass_Control.Monad.Monad_0"]())(Control_Monad_Eff_Class.liftEff(dictMonadEff)($68));
      });
  };
  var monadErrorMaybeT = function (dictMonadError) {
      return new Control_Monad_Error_Class.MonadError(function () {
          return monadMaybeT(dictMonadError["__superclass_Control.Monad.Monad_0"]());
      }, function (v) {
          return function (h) {
              return MaybeT(Control_Monad_Error_Class.catchError(dictMonadError)(v)(function (a) {
                  var $47 = h(a);
                  return $47;
              }));
          };
      }, function (e) {
          return Control_Monad_Trans_Class.lift(monadTransMaybeT)(dictMonadError["__superclass_Control.Monad.Monad_0"]())(Control_Monad_Error_Class.throwError(dictMonadError)(e));
      });
  };
  var monadRecMaybeT = function (dictMonadRec) {
      return new Control_Monad_Rec_Class.MonadRec(function () {
          return monadMaybeT(dictMonadRec["__superclass_Control.Monad.Monad_0"]());
      }, function (f) {
          return function ($69) {
              return MaybeT(Control_Monad_Rec_Class.tailRecM(dictMonadRec)(function (a) {
                  return Control_Bind.bind((dictMonadRec["__superclass_Control.Monad.Monad_0"]())["__superclass_Control.Bind.Bind_1"]())((function () {
                      var $48 = f(a);
                      return $48;
                  })())(function (m$prime) {
                      return Control_Applicative.pure((dictMonadRec["__superclass_Control.Monad.Monad_0"]())["__superclass_Control.Applicative.Applicative_0"]())((function () {
                          if (m$prime instanceof Data_Maybe.Nothing) {
                              return new Control_Monad_Rec_Class.Done(Data_Maybe.Nothing.value);
                          };
                          if (m$prime instanceof Data_Maybe.Just && m$prime.value0 instanceof Control_Monad_Rec_Class.Loop) {
                              return new Control_Monad_Rec_Class.Loop(m$prime.value0.value0);
                          };
                          if (m$prime instanceof Data_Maybe.Just && m$prime.value0 instanceof Control_Monad_Rec_Class.Done) {
                              return new Control_Monad_Rec_Class.Done(new Data_Maybe.Just(m$prime.value0.value0));
                          };
                          throw new Error("Failed pattern match at Control.Monad.Maybe.Trans line 85, column 16 - line 88, column 43: " + [ m$prime.constructor.name ]);
                      })());
                  });
              })($69));
          };
      });
  };
  var monadStateMaybeT = function (dictMonadState) {
      return new Control_Monad_State_Class.MonadState(function () {
          return monadMaybeT(dictMonadState["__superclass_Control.Monad.Monad_0"]());
      }, function (f) {
          return Control_Monad_Trans_Class.lift(monadTransMaybeT)(dictMonadState["__superclass_Control.Monad.Monad_0"]())(Control_Monad_State_Class.state(dictMonadState)(f));
      });
  };
  var monadTellMaybeT = function (dictMonadTell) {
      return new Control_Monad_Writer_Class.MonadTell(function () {
          return monadMaybeT(dictMonadTell["__superclass_Control.Monad.Monad_0"]());
      }, function ($70) {
          return Control_Monad_Trans_Class.lift(monadTransMaybeT)(dictMonadTell["__superclass_Control.Monad.Monad_0"]())(Control_Monad_Writer_Class.tell(dictMonadTell)($70));
      });
  };
  var monadWriterMaybeT = function (dictMonadWriter) {
      return new Control_Monad_Writer_Class.MonadWriter(function () {
          return monadTellMaybeT(dictMonadWriter["__superclass_Control.Monad.Writer.Class.MonadTell_0"]());
      }, mapMaybeT(function (m) {
          return Control_Bind.bind(((dictMonadWriter["__superclass_Control.Monad.Writer.Class.MonadTell_0"]())["__superclass_Control.Monad.Monad_0"]())["__superclass_Control.Bind.Bind_1"]())(Control_Monad_Writer_Class.listen(dictMonadWriter)(m))(function (v) {
              return Control_Applicative.pure(((dictMonadWriter["__superclass_Control.Monad.Writer.Class.MonadTell_0"]())["__superclass_Control.Monad.Monad_0"]())["__superclass_Control.Applicative.Applicative_0"]())(Data_Functor.map(Data_Maybe.functorMaybe)(function (r) {
                  return new Data_Tuple.Tuple(r, v.value1);
              })(v.value0));
          });
      }), mapMaybeT(function (m) {
          return Control_Monad_Writer_Class.pass(dictMonadWriter)(Control_Bind.bind(((dictMonadWriter["__superclass_Control.Monad.Writer.Class.MonadTell_0"]())["__superclass_Control.Monad.Monad_0"]())["__superclass_Control.Bind.Bind_1"]())(m)(function (v) {
              return Control_Applicative.pure(((dictMonadWriter["__superclass_Control.Monad.Writer.Class.MonadTell_0"]())["__superclass_Control.Monad.Monad_0"]())["__superclass_Control.Applicative.Applicative_0"]())((function () {
                  if (v instanceof Data_Maybe.Nothing) {
                      return new Data_Tuple.Tuple(Data_Maybe.Nothing.value, Control_Category.id(Control_Category.categoryFn));
                  };
                  if (v instanceof Data_Maybe.Just) {
                      return new Data_Tuple.Tuple(new Data_Maybe.Just(v.value0.value0), v.value0.value1);
                  };
                  throw new Error("Failed pattern match at Control.Monad.Maybe.Trans line 120, column 10 - line 122, column 42: " + [ v.constructor.name ]);
              })());
          }));
      }));
  };
  var altMaybeT = function (dictMonad) {
      return new Control_Alt.Alt(function () {
          return functorMaybeT(((dictMonad["__superclass_Control.Bind.Bind_1"]())["__superclass_Control.Apply.Apply_0"]())["__superclass_Data.Functor.Functor_0"]());
      }, function (v) {
          return function (v1) {
              return Control_Bind.bind(dictMonad["__superclass_Control.Bind.Bind_1"]())(v)(function (v2) {
                  if (v2 instanceof Data_Maybe.Nothing) {
                      return v1;
                  };
                  return Control_Applicative.pure(dictMonad["__superclass_Control.Applicative.Applicative_0"]())(v2);
              });
          };
      });
  };
  var plusMaybeT = function (dictMonad) {
      return new Control_Plus.Plus(function () {
          return altMaybeT(dictMonad);
      }, Control_Applicative.pure(dictMonad["__superclass_Control.Applicative.Applicative_0"]())(Data_Maybe.Nothing.value));
  };
  var alternativeMaybeT = function (dictMonad) {
      return new Control_Alternative.Alternative(function () {
          return applicativeMaybeT(dictMonad);
      }, function () {
          return plusMaybeT(dictMonad);
      });
  };
  var monadZeroMaybeT = function (dictMonad) {
      return new Control_MonadZero.MonadZero(function () {
          return alternativeMaybeT(dictMonad);
      }, function () {
          return monadMaybeT(dictMonad);
      });
  };
  var monadPlusMaybeT = function (dictMonad) {
      return new Control_MonadPlus.MonadPlus(function () {
          return monadZeroMaybeT(dictMonad);
      });
  };
  exports["MaybeT"] = MaybeT;
  exports["mapMaybeT"] = mapMaybeT;
  exports["runMaybeT"] = runMaybeT;
  exports["newtypeMaybeT"] = newtypeMaybeT;
  exports["functorMaybeT"] = functorMaybeT;
  exports["applyMaybeT"] = applyMaybeT;
  exports["applicativeMaybeT"] = applicativeMaybeT;
  exports["bindMaybeT"] = bindMaybeT;
  exports["monadMaybeT"] = monadMaybeT;
  exports["monadTransMaybeT"] = monadTransMaybeT;
  exports["altMaybeT"] = altMaybeT;
  exports["plusMaybeT"] = plusMaybeT;
  exports["alternativeMaybeT"] = alternativeMaybeT;
  exports["monadPlusMaybeT"] = monadPlusMaybeT;
  exports["monadZeroMaybeT"] = monadZeroMaybeT;
  exports["monadRecMaybeT"] = monadRecMaybeT;
  exports["monadEffMaybe"] = monadEffMaybe;
  exports["monadContMaybeT"] = monadContMaybeT;
  exports["monadErrorMaybeT"] = monadErrorMaybeT;
  exports["monadAskMaybeT"] = monadAskMaybeT;
  exports["monadReaderMaybeT"] = monadReaderMaybeT;
  exports["monadStateMaybeT"] = monadStateMaybeT;
  exports["monadTellMaybeT"] = monadTellMaybeT;
  exports["monadWriterMaybeT"] = monadWriterMaybeT;
})(PS["Control.Monad.Maybe.Trans"] = PS["Control.Monad.Maybe.Trans"] || {});
(function(exports) {
  
  /**
 *  | This module defines the reader-writer-state monad transformer, `RWST`.
 */  
  "use strict";
  var Prelude = PS["Prelude"];
  var Control_Monad_Eff_Class = PS["Control.Monad.Eff.Class"];
  var Control_Monad_Error_Class = PS["Control.Monad.Error.Class"];
  var Control_Monad_Reader_Class = PS["Control.Monad.Reader.Class"];
  var Control_Monad_Rec_Class = PS["Control.Monad.Rec.Class"];
  var Control_Monad_State_Class = PS["Control.Monad.State.Class"];
  var Control_Monad_Trans_Class = PS["Control.Monad.Trans.Class"];
  var Control_Monad_Writer_Class = PS["Control.Monad.Writer.Class"];
  var Data_Monoid = PS["Data.Monoid"];
  var Data_Newtype = PS["Data.Newtype"];
  var Data_Tuple = PS["Data.Tuple"];
  var Data_Functor = PS["Data.Functor"];
  var Control_Apply = PS["Control.Apply"];
  var Control_Bind = PS["Control.Bind"];
  var Data_Semigroup = PS["Data.Semigroup"];
  var Control_Applicative = PS["Control.Applicative"];
  var Data_Function = PS["Data.Function"];
  var Control_Monad = PS["Control.Monad"];
  var Control_Semigroupoid = PS["Control.Semigroupoid"];
  var Data_Unit = PS["Data.Unit"];        
  var RWSResult = (function () {
      function RWSResult(value0, value1, value2) {
          this.value0 = value0;
          this.value1 = value1;
          this.value2 = value2;
      };
      RWSResult.create = function (value0) {
          return function (value1) {
              return function (value2) {
                  return new RWSResult(value0, value1, value2);
              };
          };
      };
      return RWSResult;
  })();

  /**
 *  | The reader-writer-state monad transformer, which combines the operations
 *  | of `RWST`, `WriterT` and `StateT` into a single monad transformer.
 */  
  var RWST = function (x) {
      return x;
  };

  /**
 *  | Change the context type in a `RWST` monad action.
 */  
  var withRWST = function (f) {
      return function (m) {
          return function (r) {
              return function (s) {
                  return Data_Tuple.uncurry(m)(f(r)(s));
              };
          };
      };
  };

  /**
 *  | Run a computation in the `RWST` monad.
 */  
  var runRWST = function (v) {
      return v;
  };
  var newtypeRWST = new Data_Newtype.Newtype(function (n) {
      return n;
  }, RWST);
  var monadTransRWST = function (dictMonoid) {
      return new Control_Monad_Trans_Class.MonadTrans(function (dictMonad) {
          return function (m) {
              return function (v) {
                  return function (s) {
                      return Control_Bind.bind(dictMonad["__superclass_Control.Bind.Bind_1"]())(m)(function (a) {
                          return Control_Applicative.pure(dictMonad["__superclass_Control.Applicative.Applicative_0"]())(new RWSResult(s, a, Data_Monoid.mempty(dictMonoid)));
                      });
                  };
              };
          };
      });
  };

  /**
 *  | Change the result and accumulator types in a `RWST` monad action.
 */  
  var mapRWST = function (f) {
      return function (v) {
          return function (r) {
              return function (s) {
                  return f(v(r)(s));
              };
          };
      };
  };
  var functorRWST = function (dictFunctor) {
      return new Data_Functor.Functor(function (f) {
          return function (v) {
              return function (r) {
                  return function (s) {
                      return Data_Functor.map(dictFunctor)(function (v1) {
                          return new RWSResult(v1.value0, f(v1.value1), v1.value2);
                      })(v(r)(s));
                  };
              };
          };
      });
  };

  /**
 *  | Run a computation in the `RWST` monad, discarding the result.
 */  
  var execRWST = function (dictMonad) {
      return function (v) {
          return function (r) {
              return function (s) {
                  return Control_Bind.bind(dictMonad["__superclass_Control.Bind.Bind_1"]())(v(r)(s))(function (v1) {
                      return Control_Applicative.pure(dictMonad["__superclass_Control.Applicative.Applicative_0"]())(new Data_Tuple.Tuple(v1.value0, v1.value2));
                  });
              };
          };
      };
  };

  /**
 *  | Run a computation in the `RWST` monad, discarding the final state.
 */  
  var evalRWST = function (dictMonad) {
      return function (v) {
          return function (r) {
              return function (s) {
                  return Control_Bind.bind(dictMonad["__superclass_Control.Bind.Bind_1"]())(v(r)(s))(function (v1) {
                      return Control_Applicative.pure(dictMonad["__superclass_Control.Applicative.Applicative_0"]())(new Data_Tuple.Tuple(v1.value1, v1.value2));
                  });
              };
          };
      };
  };
  var applyRWST = function (dictBind) {
      return function (dictMonoid) {
          return new Control_Apply.Apply(function () {
              return functorRWST((dictBind["__superclass_Control.Apply.Apply_0"]())["__superclass_Data.Functor.Functor_0"]());
          }, function (v) {
              return function (v1) {
                  return function (r) {
                      return function (s) {
                          return Control_Bind.bind(dictBind)(v(r)(s))(function (v2) {
                              return Data_Functor.mapFlipped((dictBind["__superclass_Control.Apply.Apply_0"]())["__superclass_Data.Functor.Functor_0"]())(v1(r)(v2.value0))(function (v3) {
                                  return new RWSResult(v3.value0, v2.value1(v3.value1), Data_Semigroup.append(dictMonoid["__superclass_Data.Semigroup.Semigroup_0"]())(v2.value2)(v3.value2));
                              });
                          });
                      };
                  };
              };
          });
      };
  };
  var bindRWST = function (dictBind) {
      return function (dictMonoid) {
          return new Control_Bind.Bind(function () {
              return applyRWST(dictBind)(dictMonoid);
          }, function (v) {
              return function (f) {
                  return function (r) {
                      return function (s) {
                          return Control_Bind.bind(dictBind)(v(r)(s))(function (v1) {
                              var $93 = f(v1.value1);
                              return Data_Functor.mapFlipped((dictBind["__superclass_Control.Apply.Apply_0"]())["__superclass_Data.Functor.Functor_0"]())($93(r)(v1.value0))(function (v2) {
                                  return new RWSResult(v2.value0, v2.value1, Data_Semigroup.append(dictMonoid["__superclass_Data.Semigroup.Semigroup_0"]())(v1.value2)(v2.value2));
                              });
                          });
                      };
                  };
              };
          });
      };
  };
  var applicativeRWST = function (dictMonad) {
      return function (dictMonoid) {
          return new Control_Applicative.Applicative(function () {
              return applyRWST(dictMonad["__superclass_Control.Bind.Bind_1"]())(dictMonoid);
          }, function (a) {
              return function (v) {
                  return function (s) {
                      return Control_Applicative.pure(dictMonad["__superclass_Control.Applicative.Applicative_0"]())(new RWSResult(s, a, Data_Monoid.mempty(dictMonoid)));
                  };
              };
          });
      };
  };
  var monadRWST = function (dictMonad) {
      return function (dictMonoid) {
          return new Control_Monad.Monad(function () {
              return applicativeRWST(dictMonad)(dictMonoid);
          }, function () {
              return bindRWST(dictMonad["__superclass_Control.Bind.Bind_1"]())(dictMonoid);
          });
      };
  };
  var monadAskRWST = function (dictMonad) {
      return function (dictMonoid) {
          return new Control_Monad_Reader_Class.MonadAsk(function () {
              return monadRWST(dictMonad)(dictMonoid);
          }, function (r) {
              return function (s) {
                  return Control_Applicative.pure(dictMonad["__superclass_Control.Applicative.Applicative_0"]())(new RWSResult(s, r, Data_Monoid.mempty(dictMonoid)));
              };
          });
      };
  };
  var monadReaderRWST = function (dictMonad) {
      return function (dictMonoid) {
          return new Control_Monad_Reader_Class.MonadReader(function () {
              return monadAskRWST(dictMonad)(dictMonoid);
          }, function (f) {
              return function (m) {
                  return function (r) {
                      return function (s) {
                          return m(f(r))(s);
                      };
                  };
              };
          });
      };
  };
  var monadEffRWS = function (dictMonoid) {
      return function (dictMonadEff) {
          return new Control_Monad_Eff_Class.MonadEff(function () {
              return monadRWST(dictMonadEff["__superclass_Control.Monad.Monad_0"]())(dictMonoid);
          }, function ($135) {
              return Control_Monad_Trans_Class.lift(monadTransRWST(dictMonoid))(dictMonadEff["__superclass_Control.Monad.Monad_0"]())(Control_Monad_Eff_Class.liftEff(dictMonadEff)($135));
          });
      };
  };
  var monadErrorRWST = function (dictMonadError) {
      return function (dictMonoid) {
          return new Control_Monad_Error_Class.MonadError(function () {
              return monadRWST(dictMonadError["__superclass_Control.Monad.Monad_0"]())(dictMonoid);
          }, function (m) {
              return function (h) {
                  return RWST(function (r) {
                      return function (s) {
                          return Control_Monad_Error_Class.catchError(dictMonadError)(m(r)(s))(function (e) {
                              var $104 = h(e);
                              return $104(r)(s);
                          });
                      };
                  });
              };
          }, function (e) {
              return Control_Monad_Trans_Class.lift(monadTransRWST(dictMonoid))(dictMonadError["__superclass_Control.Monad.Monad_0"]())(Control_Monad_Error_Class.throwError(dictMonadError)(e));
          });
      };
  };
  var monadRecRWST = function (dictMonadRec) {
      return function (dictMonoid) {
          return new Control_Monad_Rec_Class.MonadRec(function () {
              return monadRWST(dictMonadRec["__superclass_Control.Monad.Monad_0"]())(dictMonoid);
          }, function (k) {
              return function (a) {
                  var k$prime = function (r) {
                      return function (v) {
                          var $107 = k(v.value1);
                          return Control_Bind.bind((dictMonadRec["__superclass_Control.Monad.Monad_0"]())["__superclass_Control.Bind.Bind_1"]())($107(r)(v.value0))(function (v1) {
                              return Control_Applicative.pure((dictMonadRec["__superclass_Control.Monad.Monad_0"]())["__superclass_Control.Applicative.Applicative_0"]())((function () {
                                  if (v1.value1 instanceof Control_Monad_Rec_Class.Loop) {
                                      return new Control_Monad_Rec_Class.Loop(new RWSResult(v1.value0, v1.value1.value0, Data_Semigroup.append(dictMonoid["__superclass_Data.Semigroup.Semigroup_0"]())(v.value2)(v1.value2)));
                                  };
                                  if (v1.value1 instanceof Control_Monad_Rec_Class.Done) {
                                      return new Control_Monad_Rec_Class.Done(new RWSResult(v1.value0, v1.value1.value0, Data_Semigroup.append(dictMonoid["__superclass_Data.Semigroup.Semigroup_0"]())(v.value2)(v1.value2)));
                                  };
                                  throw new Error("Failed pattern match at Control.Monad.RWS.Trans line 115, column 16 - line 117, column 67: " + [ v1.value1.constructor.name ]);
                              })());
                          });
                      };
                  };
                  return function (r) {
                      return function (s) {
                          return Control_Monad_Rec_Class.tailRecM(dictMonadRec)(k$prime(r))(new RWSResult(s, a, Data_Monoid.mempty(dictMonoid)));
                      };
                  };
              };
          });
      };
  };
  var monadStateRWST = function (dictMonad) {
      return function (dictMonoid) {
          return new Control_Monad_State_Class.MonadState(function () {
              return monadRWST(dictMonad)(dictMonoid);
          }, function (f) {
              return function (v) {
                  return function (s) {
                      var $119 = f(s);
                      return Control_Applicative.pure(dictMonad["__superclass_Control.Applicative.Applicative_0"]())(new RWSResult($119.value1, $119.value0, Data_Monoid.mempty(dictMonoid)));
                  };
              };
          });
      };
  };
  var monadTellRWST = function (dictMonad) {
      return function (dictMonoid) {
          return new Control_Monad_Writer_Class.MonadTell(function () {
              return monadRWST(dictMonad)(dictMonoid);
          }, function (w) {
              return function (v) {
                  return function (s) {
                      return Control_Applicative.pure(dictMonad["__superclass_Control.Applicative.Applicative_0"]())(new RWSResult(s, Data_Unit.unit, w));
                  };
              };
          });
      };
  };
  var monadWriterRWST = function (dictMonad) {
      return function (dictMonoid) {
          return new Control_Monad_Writer_Class.MonadWriter(function () {
              return monadTellRWST(dictMonad)(dictMonoid);
          }, function (m) {
              return function (r) {
                  return function (s) {
                      return Control_Bind.bind(dictMonad["__superclass_Control.Bind.Bind_1"]())(m(r)(s))(function (v) {
                          return Control_Applicative.pure(dictMonad["__superclass_Control.Applicative.Applicative_0"]())(new RWSResult(v.value0, new Data_Tuple.Tuple(v.value1, v.value2), v.value2));
                      });
                  };
              };
          }, function (m) {
              return function (r) {
                  return function (s) {
                      return Control_Bind.bind(dictMonad["__superclass_Control.Bind.Bind_1"]())(m(r)(s))(function (v) {
                          return Control_Applicative.pure(dictMonad["__superclass_Control.Applicative.Applicative_0"]())(new RWSResult(v.value0, v.value1.value0, v.value1.value1(v.value2)));
                      });
                  };
              };
          });
      };
  };
  exports["RWSResult"] = RWSResult;
  exports["RWST"] = RWST;
  exports["evalRWST"] = evalRWST;
  exports["execRWST"] = execRWST;
  exports["mapRWST"] = mapRWST;
  exports["runRWST"] = runRWST;
  exports["withRWST"] = withRWST;
  exports["newtypeRWST"] = newtypeRWST;
  exports["functorRWST"] = functorRWST;
  exports["applyRWST"] = applyRWST;
  exports["bindRWST"] = bindRWST;
  exports["applicativeRWST"] = applicativeRWST;
  exports["monadRWST"] = monadRWST;
  exports["monadTransRWST"] = monadTransRWST;
  exports["monadEffRWS"] = monadEffRWS;
  exports["monadAskRWST"] = monadAskRWST;
  exports["monadReaderRWST"] = monadReaderRWST;
  exports["monadStateRWST"] = monadStateRWST;
  exports["monadTellRWST"] = monadTellRWST;
  exports["monadWriterRWST"] = monadWriterRWST;
  exports["monadErrorRWST"] = monadErrorRWST;
  exports["monadRecRWST"] = monadRecRWST;
})(PS["Control.Monad.RWS.Trans"] = PS["Control.Monad.RWS.Trans"] || {});
(function(exports) {
  
  /**
 *  | This module defines the `RWS` monad.
 */  
  "use strict";
  var Prelude = PS["Prelude"];
  var Control_Monad_Reader_Class = PS["Control.Monad.Reader.Class"];
  var Control_Monad_RWS_Trans = PS["Control.Monad.RWS.Trans"];
  var Control_Monad_State_Class = PS["Control.Monad.State.Class"];
  var Control_Monad_Trans_Class = PS["Control.Monad.Trans.Class"];
  var Control_Monad_Writer_Class = PS["Control.Monad.Writer.Class"];
  var Data_Identity = PS["Data.Identity"];
  var Data_Newtype = PS["Data.Newtype"];
  var Data_Tuple = PS["Data.Tuple"];
  var Data_Function = PS["Data.Function"];
  var Control_Applicative = PS["Control.Applicative"];
  var Control_Semigroupoid = PS["Control.Semigroupoid"];        

  /**
 *  | Change the type of the context in a `RWS` action
 */  
  var withRWS = Control_Monad_RWS_Trans.withRWST;

  /**
 *  | Create an action in the `RWS` monad from a function which uses the
 *  | global context and state explicitly.
 */  
  var rws = function (f) {
      return function (r) {
          return function (s) {
              return Control_Applicative.pure(Data_Identity.applicativeIdentity)(f(r)(s));
          };
      };
  };

  /**
 *  | Run a computation in the `RWS` monad.
 */  
  var runRWS = function (m) {
      return function (r) {
          return function (s) {
              var $1 = m(r)(s);
              return $1;
          };
      };
  };

  /**
 *  | Change the types of the result and accumulator in a `RWS` action
 */  
  var mapRWS = function (f) {
      return Control_Monad_RWS_Trans.mapRWST(function ($2) {
          return Data_Identity.Identity(f(Data_Newtype.unwrap(Data_Identity.newtypeIdentity)($2)));
      });
  };

  /**
 *  | Run a computation in the `RWS` monad, discarding the result
 */  
  var execRWS = function (m) {
      return function (r) {
          return function (s) {
              return Data_Newtype.unwrap(Data_Identity.newtypeIdentity)(Control_Monad_RWS_Trans.execRWST(Data_Identity.monadIdentity)(m)(r)(s));
          };
      };
  };

  /**
 *  | Run a computation in the `RWS` monad, discarding the final state
 */  
  var evalRWS = function (m) {
      return function (r) {
          return function (s) {
              return Data_Newtype.unwrap(Data_Identity.newtypeIdentity)(Control_Monad_RWS_Trans.evalRWST(Data_Identity.monadIdentity)(m)(r)(s));
          };
      };
  };
  exports["evalRWS"] = evalRWS;
  exports["execRWS"] = execRWS;
  exports["mapRWS"] = mapRWS;
  exports["runRWS"] = runRWS;
  exports["rws"] = rws;
  exports["withRWS"] = withRWS;
})(PS["Control.Monad.RWS"] = PS["Control.Monad.RWS"] || {});
(function(exports) {
    "use strict";
  var Prelude = PS["Prelude"];
  var Data_Identity = PS["Data.Identity"];
  var Data_Newtype = PS["Data.Newtype"];
  var Control_Semigroupoid = PS["Control.Semigroupoid"];
  var Data_Functor = PS["Data.Functor"];
  var Data_Function = PS["Data.Function"];
  var Control_Category = PS["Control.Category"];        

  /**
 *  | Categorical dual of `Traversable`:
 *  |
 *  | - `distribute` is the dual of `sequence` - it zips an arbitrary collection
 *  |   of containers.
 *  | - `collect` is the dual of `traverse` - it traverses an arbitrary
 *  |   collection of values.
 */  
  var Distributive = function (__superclass_Data$dotFunctor$dotFunctor_0, collect, distribute) {
      this["__superclass_Data.Functor.Functor_0"] = __superclass_Data$dotFunctor$dotFunctor_0;
      this.collect = collect;
      this.distribute = distribute;
  };
  var distributiveIdentity = new Distributive(function () {
      return Data_Identity.functorIdentity;
  }, function (dictFunctor) {
      return function (f) {
          return function ($11) {
              return Data_Identity.Identity(Data_Functor.map(dictFunctor)(function ($12) {
                  return Data_Newtype.unwrap(Data_Identity.newtypeIdentity)(f($12));
              })($11));
          };
      };
  }, function (dictFunctor) {
      return function ($13) {
          return Data_Identity.Identity(Data_Functor.map(dictFunctor)(Data_Newtype.unwrap(Data_Identity.newtypeIdentity))($13));
      };
  });

  /**
 *  | Categorical dual of `Traversable`:
 *  |
 *  | - `distribute` is the dual of `sequence` - it zips an arbitrary collection
 *  |   of containers.
 *  | - `collect` is the dual of `traverse` - it traverses an arbitrary
 *  |   collection of values.
 */  
  var distribute = function (dict) {
      return dict.distribute;
  };
  var distributiveFunction = new Distributive(function () {
      return Data_Functor.functorFn;
  }, function (dictFunctor) {
      return function (f) {
          return function ($14) {
              return distribute(distributiveFunction)(dictFunctor)(Data_Functor.map(dictFunctor)(f)($14));
          };
      };
  }, function (dictFunctor) {
      return function (a) {
          return function (e) {
              return Data_Functor.map(dictFunctor)(function (v) {
                  return v(e);
              })(a);
          };
      };
  });

  /**
 *  | Zip an arbitrary collection of containers and summarize the results
 */  
  var cotraverse = function (dictDistributive) {
      return function (dictFunctor) {
          return function (f) {
              return function ($15) {
                  return Data_Functor.map(dictDistributive["__superclass_Data.Functor.Functor_0"]())(f)(distribute(dictDistributive)(dictFunctor)($15));
              };
          };
      };
  };

  /**
 *  | A default implementation of `collect`, based on `distribute`.
 */  
  var collectDefault = function (dictDistributive) {
      return function (dictFunctor) {
          return function (f) {
              return function ($16) {
                  return distribute(dictDistributive)(dictFunctor)(Data_Functor.map(dictFunctor)(f)($16));
              };
          };
      };
  };

  /**
 *  | Categorical dual of `Traversable`:
 *  |
 *  | - `distribute` is the dual of `sequence` - it zips an arbitrary collection
 *  |   of containers.
 *  | - `collect` is the dual of `traverse` - it traverses an arbitrary
 *  |   collection of values.
 */  
  var collect = function (dict) {
      return dict.collect;
  };

  /**
 *  | A default implementation of `distribute`, based on `collect`.
 */  
  var distributeDefault = function (dictDistributive) {
      return function (dictFunctor) {
          return collect(dictDistributive)(dictFunctor)(Control_Category.id(Control_Category.categoryFn));
      };
  };
  exports["Distributive"] = Distributive;
  exports["collect"] = collect;
  exports["collectDefault"] = collectDefault;
  exports["cotraverse"] = cotraverse;
  exports["distribute"] = distribute;
  exports["distributeDefault"] = distributeDefault;
  exports["distributiveIdentity"] = distributiveIdentity;
  exports["distributiveFunction"] = distributiveFunction;
})(PS["Data.Distributive"] = PS["Data.Distributive"] || {});
(function(exports) {
  
  /**
 *  | This module defines the reader monad transformer, `ReaderT`.
 */  
  "use strict";
  var Prelude = PS["Prelude"];
  var Control_Alt = PS["Control.Alt"];
  var Control_Alternative = PS["Control.Alternative"];
  var Control_Monad_Cont_Class = PS["Control.Monad.Cont.Class"];
  var Control_Monad_Eff_Class = PS["Control.Monad.Eff.Class"];
  var Control_Monad_Error_Class = PS["Control.Monad.Error.Class"];
  var Control_Monad_Reader_Class = PS["Control.Monad.Reader.Class"];
  var Control_Monad_Rec_Class = PS["Control.Monad.Rec.Class"];
  var Control_Monad_State_Class = PS["Control.Monad.State.Class"];
  var Control_Monad_Trans_Class = PS["Control.Monad.Trans.Class"];
  var Control_Monad_Writer_Class = PS["Control.Monad.Writer.Class"];
  var Control_MonadPlus = PS["Control.MonadPlus"];
  var Control_MonadZero = PS["Control.MonadZero"];
  var Control_Plus = PS["Control.Plus"];
  var Data_Distributive = PS["Data.Distributive"];
  var Data_Newtype = PS["Data.Newtype"];
  var Data_Functor = PS["Data.Functor"];
  var Control_Semigroupoid = PS["Control.Semigroupoid"];
  var Control_Apply = PS["Control.Apply"];
  var Control_Applicative = PS["Control.Applicative"];
  var Data_Function = PS["Data.Function"];
  var Control_Bind = PS["Control.Bind"];
  var Control_Monad = PS["Control.Monad"];        

  /**
 *  | The reader monad transformer.
 *  |
 *  | This monad transformer extends the base monad transformer with a _global context_ of
 *  | type `r`.
 *  |
 *  | The `MonadReader` type class describes the operations supported by this monad.
 */  
  var ReaderT = function (x) {
      return x;
  };

  /**
 *  | Change the type of the context in a `ReaderT` monad action.
 */  
  var withReaderT = function (f) {
      return function (v) {
          return function ($53) {
              return v(f($53));
          };
      };
  };

  /**
 *  | Run a computation in the `ReaderT` monad.
 */  
  var runReaderT = function (v) {
      return v;
  };
  var newtypeReaderT = new Data_Newtype.Newtype(function (n) {
      return n;
  }, ReaderT);
  var monadTransReaderT = new Control_Monad_Trans_Class.MonadTrans(function (dictMonad) {
      return function ($54) {
          return ReaderT(Data_Function["const"]($54));
      };
  });

  /**
 *  | Change the type of the result in a `ReaderT` monad action.
 */  
  var mapReaderT = function (f) {
      return function (v) {
          return function ($55) {
              return f(v($55));
          };
      };
  };
  var functorReaderT = function (dictFunctor) {
      return new Data_Functor.Functor(function ($56) {
          return mapReaderT(Data_Functor.map(dictFunctor)($56));
      });
  };
  var distributiveReaderT = function (dictDistributive) {
      return new Data_Distributive.Distributive(function () {
          return functorReaderT(dictDistributive["__superclass_Data.Functor.Functor_0"]());
      }, function (dictFunctor) {
          return function (f) {
              return function ($57) {
                  return Data_Distributive.distribute(distributiveReaderT(dictDistributive))(dictFunctor)(Data_Functor.map(dictFunctor)(f)($57));
              };
          };
      }, function (dictFunctor) {
          return function (a) {
              return function (e) {
                  return Data_Distributive.collect(dictDistributive)(dictFunctor)(function (r) {
                      return r(e);
                  })(a);
              };
          };
      });
  };
  var applyReaderT = function (dictApply) {
      return new Control_Apply.Apply(function () {
          return functorReaderT(dictApply["__superclass_Data.Functor.Functor_0"]());
      }, function (v) {
          return function (v1) {
              return function (r) {
                  return Control_Apply.apply(dictApply)(v(r))(v1(r));
              };
          };
      });
  };
  var bindReaderT = function (dictBind) {
      return new Control_Bind.Bind(function () {
          return applyReaderT(dictBind["__superclass_Control.Apply.Apply_0"]());
      }, function (v) {
          return function (k) {
              return function (r) {
                  return Control_Bind.bind(dictBind)(v(r))(function (a) {
                      var $45 = k(a);
                      return $45(r);
                  });
              };
          };
      });
  };
  var applicativeReaderT = function (dictApplicative) {
      return new Control_Applicative.Applicative(function () {
          return applyReaderT(dictApplicative["__superclass_Control.Apply.Apply_0"]());
      }, function ($58) {
          return ReaderT(Data_Function["const"](Control_Applicative.pure(dictApplicative)($58)));
      });
  };
  var monadReaderT = function (dictMonad) {
      return new Control_Monad.Monad(function () {
          return applicativeReaderT(dictMonad["__superclass_Control.Applicative.Applicative_0"]());
      }, function () {
          return bindReaderT(dictMonad["__superclass_Control.Bind.Bind_1"]());
      });
  };
  var monadAskReaderT = function (dictMonad) {
      return new Control_Monad_Reader_Class.MonadAsk(function () {
          return monadReaderT(dictMonad);
      }, Control_Applicative.pure(dictMonad["__superclass_Control.Applicative.Applicative_0"]()));
  };
  var monadReaderReaderT = function (dictMonad) {
      return new Control_Monad_Reader_Class.MonadReader(function () {
          return monadAskReaderT(dictMonad);
      }, withReaderT);
  };
  var monadContReaderT = function (dictMonadCont) {
      return new Control_Monad_Cont_Class.MonadCont(function () {
          return monadReaderT(dictMonadCont["__superclass_Control.Monad.Monad_0"]());
      }, function (f) {
          return function (r) {
              return Control_Monad_Cont_Class.callCC(dictMonadCont)(function (c) {
                  var $46 = f(function ($59) {
                      return ReaderT(Data_Function["const"](c($59)));
                  });
                  return $46(r);
              });
          };
      });
  };
  var monadEffReader = function (dictMonadEff) {
      return new Control_Monad_Eff_Class.MonadEff(function () {
          return monadReaderT(dictMonadEff["__superclass_Control.Monad.Monad_0"]());
      }, function ($60) {
          return Control_Monad_Trans_Class.lift(monadTransReaderT)(dictMonadEff["__superclass_Control.Monad.Monad_0"]())(Control_Monad_Eff_Class.liftEff(dictMonadEff)($60));
      });
  };
  var monadErrorReaderT = function (dictMonadError) {
      return new Control_Monad_Error_Class.MonadError(function () {
          return monadReaderT(dictMonadError["__superclass_Control.Monad.Monad_0"]());
      }, function (v) {
          return function (h) {
              return function (r) {
                  return Control_Monad_Error_Class.catchError(dictMonadError)(v(r))(function (e) {
                      var $49 = h(e);
                      return $49(r);
                  });
              };
          };
      }, function ($61) {
          return Control_Monad_Trans_Class.lift(monadTransReaderT)(dictMonadError["__superclass_Control.Monad.Monad_0"]())(Control_Monad_Error_Class.throwError(dictMonadError)($61));
      });
  };
  var monadRecReaderT = function (dictMonadRec) {
      return new Control_Monad_Rec_Class.MonadRec(function () {
          return monadReaderT(dictMonadRec["__superclass_Control.Monad.Monad_0"]());
      }, function (k) {
          return function (a) {
              var k$prime = function (r) {
                  return function (a1) {
                      var $50 = k(a1);
                      return Control_Bind.bindFlipped((dictMonadRec["__superclass_Control.Monad.Monad_0"]())["__superclass_Control.Bind.Bind_1"]())(Control_Applicative.pure((dictMonadRec["__superclass_Control.Monad.Monad_0"]())["__superclass_Control.Applicative.Applicative_0"]()))($50(r));
                  };
              };
              return function (r) {
                  return Control_Monad_Rec_Class.tailRecM(dictMonadRec)(k$prime(r))(a);
              };
          };
      });
  };
  var monadStateReaderT = function (dictMonadState) {
      return new Control_Monad_State_Class.MonadState(function () {
          return monadReaderT(dictMonadState["__superclass_Control.Monad.Monad_0"]());
      }, function ($62) {
          return Control_Monad_Trans_Class.lift(monadTransReaderT)(dictMonadState["__superclass_Control.Monad.Monad_0"]())(Control_Monad_State_Class.state(dictMonadState)($62));
      });
  };
  var monadTellReaderT = function (dictMonadTell) {
      return new Control_Monad_Writer_Class.MonadTell(function () {
          return monadReaderT(dictMonadTell["__superclass_Control.Monad.Monad_0"]());
      }, function ($63) {
          return Control_Monad_Trans_Class.lift(monadTransReaderT)(dictMonadTell["__superclass_Control.Monad.Monad_0"]())(Control_Monad_Writer_Class.tell(dictMonadTell)($63));
      });
  };
  var monadWriterReaderT = function (dictMonadWriter) {
      return new Control_Monad_Writer_Class.MonadWriter(function () {
          return monadTellReaderT(dictMonadWriter["__superclass_Control.Monad.Writer.Class.MonadTell_0"]());
      }, mapReaderT(Control_Monad_Writer_Class.listen(dictMonadWriter)), mapReaderT(Control_Monad_Writer_Class.pass(dictMonadWriter)));
  };
  var altReaderT = function (dictAlt) {
      return new Control_Alt.Alt(function () {
          return functorReaderT(dictAlt["__superclass_Data.Functor.Functor_0"]());
      }, function (v) {
          return function (v1) {
              return function (r) {
                  return Control_Alt.alt(dictAlt)(v(r))(v1(r));
              };
          };
      });
  };
  var plusReaderT = function (dictPlus) {
      return new Control_Plus.Plus(function () {
          return altReaderT(dictPlus["__superclass_Control.Alt.Alt_0"]());
      }, Data_Function["const"](Control_Plus.empty(dictPlus)));
  };
  var alternativeReaderT = function (dictAlternative) {
      return new Control_Alternative.Alternative(function () {
          return applicativeReaderT(dictAlternative["__superclass_Control.Applicative.Applicative_0"]());
      }, function () {
          return plusReaderT(dictAlternative["__superclass_Control.Plus.Plus_1"]());
      });
  };
  var monadZeroReaderT = function (dictMonadZero) {
      return new Control_MonadZero.MonadZero(function () {
          return alternativeReaderT(dictMonadZero["__superclass_Control.Alternative.Alternative_1"]());
      }, function () {
          return monadReaderT(dictMonadZero["__superclass_Control.Monad.Monad_0"]());
      });
  };
  var monadPlusReaderT = function (dictMonadPlus) {
      return new Control_MonadPlus.MonadPlus(function () {
          return monadZeroReaderT(dictMonadPlus["__superclass_Control.MonadZero.MonadZero_0"]());
      });
  };
  exports["ReaderT"] = ReaderT;
  exports["mapReaderT"] = mapReaderT;
  exports["runReaderT"] = runReaderT;
  exports["withReaderT"] = withReaderT;
  exports["newtypeReaderT"] = newtypeReaderT;
  exports["functorReaderT"] = functorReaderT;
  exports["applyReaderT"] = applyReaderT;
  exports["applicativeReaderT"] = applicativeReaderT;
  exports["altReaderT"] = altReaderT;
  exports["plusReaderT"] = plusReaderT;
  exports["alternativeReaderT"] = alternativeReaderT;
  exports["bindReaderT"] = bindReaderT;
  exports["monadReaderT"] = monadReaderT;
  exports["monadZeroReaderT"] = monadZeroReaderT;
  exports["monadPlusReaderT"] = monadPlusReaderT;
  exports["monadTransReaderT"] = monadTransReaderT;
  exports["monadEffReader"] = monadEffReader;
  exports["monadContReaderT"] = monadContReaderT;
  exports["monadErrorReaderT"] = monadErrorReaderT;
  exports["monadAskReaderT"] = monadAskReaderT;
  exports["monadReaderReaderT"] = monadReaderReaderT;
  exports["monadStateReaderT"] = monadStateReaderT;
  exports["monadTellReaderT"] = monadTellReaderT;
  exports["monadWriterReaderT"] = monadWriterReaderT;
  exports["distributiveReaderT"] = distributiveReaderT;
  exports["monadRecReaderT"] = monadRecReaderT;
})(PS["Control.Monad.Reader.Trans"] = PS["Control.Monad.Reader.Trans"] || {});
(function(exports) {
  
  /**
 *  | This module defines the `Reader` monad.
 */  
  "use strict";
  var Prelude = PS["Prelude"];
  var Control_Monad_Reader_Class = PS["Control.Monad.Reader.Class"];
  var Control_Monad_Reader_Trans = PS["Control.Monad.Reader.Trans"];
  var Data_Identity = PS["Data.Identity"];
  var Data_Newtype = PS["Data.Newtype"];
  var Control_Semigroupoid = PS["Control.Semigroupoid"];
  var Data_Function = PS["Data.Function"];        

  /**
 *  | Change the type of the context in a `Reader` monad action.
 */  
  var withReader = Control_Monad_Reader_Trans.withReaderT;

  /**
 *  | Run a computation in the `Reader` monad.
 */  
  var runReader = function (v) {
      return function ($2) {
          return Data_Newtype.unwrap(Data_Identity.newtypeIdentity)(v($2));
      };
  };

  /**
 *  | Change the type of the result in a `Reader` monad action.
 */  
  var mapReader = function (f) {
      return Control_Monad_Reader_Trans.mapReaderT(function ($3) {
          return Data_Identity.Identity(f(Data_Newtype.unwrap(Data_Identity.newtypeIdentity)($3)));
      });
  };
  exports["mapReader"] = mapReader;
  exports["runReader"] = runReader;
  exports["withReader"] = withReader;
})(PS["Control.Monad.Reader"] = PS["Control.Monad.Reader"] || {});
(function(exports) {
  
  /**
 *  | This module defines the state monad transformer, `StateT`.
 */  
  "use strict";
  var Prelude = PS["Prelude"];
  var Control_Alt = PS["Control.Alt"];
  var Control_Alternative = PS["Control.Alternative"];
  var Control_Lazy = PS["Control.Lazy"];
  var Control_Monad_Cont_Class = PS["Control.Monad.Cont.Class"];
  var Control_Monad_Eff_Class = PS["Control.Monad.Eff.Class"];
  var Control_Monad_Error_Class = PS["Control.Monad.Error.Class"];
  var Control_Monad_Reader_Class = PS["Control.Monad.Reader.Class"];
  var Control_Monad_Rec_Class = PS["Control.Monad.Rec.Class"];
  var Control_Monad_State_Class = PS["Control.Monad.State.Class"];
  var Control_Monad_Trans_Class = PS["Control.Monad.Trans.Class"];
  var Control_Monad_Writer_Class = PS["Control.Monad.Writer.Class"];
  var Control_MonadPlus = PS["Control.MonadPlus"];
  var Control_MonadZero = PS["Control.MonadZero"];
  var Control_Plus = PS["Control.Plus"];
  var Data_Newtype = PS["Data.Newtype"];
  var Data_Tuple = PS["Data.Tuple"];
  var Data_Functor = PS["Data.Functor"];
  var Control_Apply = PS["Control.Apply"];
  var Control_Monad = PS["Control.Monad"];
  var Control_Applicative = PS["Control.Applicative"];
  var Data_Function = PS["Data.Function"];
  var Control_Bind = PS["Control.Bind"];
  var Data_Unit = PS["Data.Unit"];
  var Control_Semigroupoid = PS["Control.Semigroupoid"];        

  /**
 *  | The state monad transformer.
 *  |
 *  | This monad transformer extends the base monad with the operations `get`
 *  | and `put` which can be used to model a single piece of mutable state.
 *  |
 *  | The `MonadState` type class describes the operations supported by this monad.
 */  
  var StateT = function (x) {
      return x;
  };

  /**
 *  | Modify the final state in a `StateT` monad action.
 */  
  var withStateT = function (f) {
      return function (v) {
          return function ($97) {
              return v(f($97));
          };
      };
  };

  /**
 *  | Run a computation in the `StateT` monad.
 */  
  var runStateT = function (v) {
      return v;
  };
  var newtypeStateT = new Data_Newtype.Newtype(function (n) {
      return n;
  }, StateT);
  var monadTransStateT = new Control_Monad_Trans_Class.MonadTrans(function (dictMonad) {
      return function (m) {
          return function (s) {
              return Control_Bind.bind(dictMonad["__superclass_Control.Bind.Bind_1"]())(m)(function (v) {
                  return Control_Applicative.pure(dictMonad["__superclass_Control.Applicative.Applicative_0"]())(new Data_Tuple.Tuple(v, s));
              });
          };
      };
  });

  /**
 *  | Change the result type in a `StateT` monad action.
 */  
  var mapStateT = function (f) {
      return function (v) {
          return function ($98) {
              return f(v($98));
          };
      };
  };
  var lazyStateT = new Control_Lazy.Lazy(function (f) {
      return function (s) {
          var $52 = f(Data_Unit.unit);
          return $52(s);
      };
  });
  var functorStateT = function (dictFunctor) {
      return new Data_Functor.Functor(function (f) {
          return function (v) {
              return function (s) {
                  return Data_Functor.map(dictFunctor)(function (v1) {
                      return new Data_Tuple.Tuple(f(v1.value0), v1.value1);
                  })(v(s));
              };
          };
      });
  };

  /**
 *  | Run a computation in the `StateT` monad discarding the result.
 */  
  var execStateT = function (dictFunctor) {
      return function (v) {
          return function (s) {
              return Data_Functor.map(dictFunctor)(Data_Tuple.snd)(v(s));
          };
      };
  };

  /**
 *  | Run a computation in the `StateT` monad, discarding the final state.
 */  
  var evalStateT = function (dictFunctor) {
      return function (v) {
          return function (s) {
              return Data_Functor.map(dictFunctor)(Data_Tuple.fst)(v(s));
          };
      };
  };
  var monadStateT = function (dictMonad) {
      return new Control_Monad.Monad(function () {
          return applicativeStateT(dictMonad);
      }, function () {
          return bindStateT(dictMonad);
      });
  };
  var bindStateT = function (dictMonad) {
      return new Control_Bind.Bind(function () {
          return applyStateT(dictMonad);
      }, function (v) {
          return function (f) {
              return function (s) {
                  return Control_Bind.bind(dictMonad["__superclass_Control.Bind.Bind_1"]())(v(s))(function (v1) {
                      var $65 = f(v1.value0);
                      return $65(v1.value1);
                  });
              };
          };
      });
  };
  var applyStateT = function (dictMonad) {
      return new Control_Apply.Apply(function () {
          return functorStateT(((dictMonad["__superclass_Control.Bind.Bind_1"]())["__superclass_Control.Apply.Apply_0"]())["__superclass_Data.Functor.Functor_0"]());
      }, Control_Monad.ap(monadStateT(dictMonad)));
  };
  var applicativeStateT = function (dictMonad) {
      return new Control_Applicative.Applicative(function () {
          return applyStateT(dictMonad);
      }, function (a) {
          return function (s) {
              return Control_Applicative.pure(dictMonad["__superclass_Control.Applicative.Applicative_0"]())(new Data_Tuple.Tuple(a, s));
          };
      });
  };
  var monadAskStateT = function (dictMonadAsk) {
      return new Control_Monad_Reader_Class.MonadAsk(function () {
          return monadStateT(dictMonadAsk["__superclass_Control.Monad.Monad_0"]());
      }, Control_Monad_Trans_Class.lift(monadTransStateT)(dictMonadAsk["__superclass_Control.Monad.Monad_0"]())(Control_Monad_Reader_Class.ask(dictMonadAsk)));
  };
  var monadReaderStateT = function (dictMonadReader) {
      return new Control_Monad_Reader_Class.MonadReader(function () {
          return monadAskStateT(dictMonadReader["__superclass_Control.Monad.Reader.Class.MonadAsk_0"]());
      }, function ($99) {
          return mapStateT(Control_Monad_Reader_Class.local(dictMonadReader)($99));
      });
  };
  var monadContStateT = function (dictMonadCont) {
      return new Control_Monad_Cont_Class.MonadCont(function () {
          return monadStateT(dictMonadCont["__superclass_Control.Monad.Monad_0"]());
      }, function (f) {
          return function (s) {
              return Control_Monad_Cont_Class.callCC(dictMonadCont)(function (c) {
                  var $68 = f(function (a) {
                      return function (s$prime) {
                          return c(new Data_Tuple.Tuple(a, s$prime));
                      };
                  });
                  return $68(s);
              });
          };
      });
  };
  var monadEffState = function (dictMonadEff) {
      return new Control_Monad_Eff_Class.MonadEff(function () {
          return monadStateT(dictMonadEff["__superclass_Control.Monad.Monad_0"]());
      }, function ($100) {
          return Control_Monad_Trans_Class.lift(monadTransStateT)(dictMonadEff["__superclass_Control.Monad.Monad_0"]())(Control_Monad_Eff_Class.liftEff(dictMonadEff)($100));
      });
  };
  var monadErrorStateT = function (dictMonadError) {
      return new Control_Monad_Error_Class.MonadError(function () {
          return monadStateT(dictMonadError["__superclass_Control.Monad.Monad_0"]());
      }, function (v) {
          return function (h) {
              return function (s) {
                  return Control_Monad_Error_Class.catchError(dictMonadError)(v(s))(function (e) {
                      var $71 = h(e);
                      return $71(s);
                  });
              };
          };
      }, function (e) {
          return Control_Monad_Trans_Class.lift(monadTransStateT)(dictMonadError["__superclass_Control.Monad.Monad_0"]())(Control_Monad_Error_Class.throwError(dictMonadError)(e));
      });
  };
  var monadRecStateT = function (dictMonadRec) {
      return new Control_Monad_Rec_Class.MonadRec(function () {
          return monadStateT(dictMonadRec["__superclass_Control.Monad.Monad_0"]());
      }, function (f) {
          return function (a) {
              var f$prime = function (v) {
                  return Control_Bind.bind((dictMonadRec["__superclass_Control.Monad.Monad_0"]())["__superclass_Control.Bind.Bind_1"]())((function () {
                      var $73 = f(v.value0);
                      return $73;
                  })()(v.value1))(function (v1) {
                      return Control_Applicative.pure((dictMonadRec["__superclass_Control.Monad.Monad_0"]())["__superclass_Control.Applicative.Applicative_0"]())((function () {
                          if (v1.value0 instanceof Control_Monad_Rec_Class.Loop) {
                              return new Control_Monad_Rec_Class.Loop(new Data_Tuple.Tuple(v1.value0.value0, v1.value1));
                          };
                          if (v1.value0 instanceof Control_Monad_Rec_Class.Done) {
                              return new Control_Monad_Rec_Class.Done(new Data_Tuple.Tuple(v1.value0.value0, v1.value1));
                          };
                          throw new Error("Failed pattern match at Control.Monad.State.Trans line 88, column 16 - line 90, column 40: " + [ v1.value0.constructor.name ]);
                      })());
                  });
              };
              return function (s) {
                  return Control_Monad_Rec_Class.tailRecM(dictMonadRec)(f$prime)(new Data_Tuple.Tuple(a, s));
              };
          };
      });
  };
  var monadStateStateT = function (dictMonad) {
      return new Control_Monad_State_Class.MonadState(function () {
          return monadStateT(dictMonad);
      }, function (f) {
          return StateT(function ($101) {
              return Control_Applicative.pure(dictMonad["__superclass_Control.Applicative.Applicative_0"]())(f($101));
          });
      });
  };
  var monadTellStateT = function (dictMonadTell) {
      return new Control_Monad_Writer_Class.MonadTell(function () {
          return monadStateT(dictMonadTell["__superclass_Control.Monad.Monad_0"]());
      }, function ($102) {
          return Control_Monad_Trans_Class.lift(monadTransStateT)(dictMonadTell["__superclass_Control.Monad.Monad_0"]())(Control_Monad_Writer_Class.tell(dictMonadTell)($102));
      });
  };
  var monadWriterStateT = function (dictMonadWriter) {
      return new Control_Monad_Writer_Class.MonadWriter(function () {
          return monadTellStateT(dictMonadWriter["__superclass_Control.Monad.Writer.Class.MonadTell_0"]());
      }, function (m) {
          return function (s) {
              return Control_Bind.bind(((dictMonadWriter["__superclass_Control.Monad.Writer.Class.MonadTell_0"]())["__superclass_Control.Monad.Monad_0"]())["__superclass_Control.Bind.Bind_1"]())(Control_Monad_Writer_Class.listen(dictMonadWriter)(m(s)))(function (v) {
                  return Control_Applicative.pure(((dictMonadWriter["__superclass_Control.Monad.Writer.Class.MonadTell_0"]())["__superclass_Control.Monad.Monad_0"]())["__superclass_Control.Applicative.Applicative_0"]())(new Data_Tuple.Tuple(new Data_Tuple.Tuple(v.value0.value0, v.value1), v.value0.value1));
              });
          };
      }, function (m) {
          return function (s) {
              return Control_Monad_Writer_Class.pass(dictMonadWriter)(Control_Bind.bind(((dictMonadWriter["__superclass_Control.Monad.Writer.Class.MonadTell_0"]())["__superclass_Control.Monad.Monad_0"]())["__superclass_Control.Bind.Bind_1"]())(m(s))(function (v) {
                  return Control_Applicative.pure(((dictMonadWriter["__superclass_Control.Monad.Writer.Class.MonadTell_0"]())["__superclass_Control.Monad.Monad_0"]())["__superclass_Control.Applicative.Applicative_0"]())(new Data_Tuple.Tuple(new Data_Tuple.Tuple(v.value0.value0, v.value1), v.value0.value1));
              }));
          };
      });
  };
  var altStateT = function (dictMonad) {
      return function (dictAlt) {
          return new Control_Alt.Alt(function () {
              return functorStateT(dictAlt["__superclass_Data.Functor.Functor_0"]());
          }, function (v) {
              return function (v1) {
                  return function (s) {
                      return Control_Alt.alt(dictAlt)(v(s))(v1(s));
                  };
              };
          });
      };
  };
  var plusStateT = function (dictMonad) {
      return function (dictPlus) {
          return new Control_Plus.Plus(function () {
              return altStateT(dictMonad)(dictPlus["__superclass_Control.Alt.Alt_0"]());
          }, function (v) {
              return Control_Plus.empty(dictPlus);
          });
      };
  };
  var alternativeStateT = function (dictMonad) {
      return function (dictAlternative) {
          return new Control_Alternative.Alternative(function () {
              return applicativeStateT(dictMonad);
          }, function () {
              return plusStateT(dictMonad)(dictAlternative["__superclass_Control.Plus.Plus_1"]());
          });
      };
  };
  var monadZeroStateT = function (dictMonadZero) {
      return new Control_MonadZero.MonadZero(function () {
          return alternativeStateT(dictMonadZero["__superclass_Control.Monad.Monad_0"]())(dictMonadZero["__superclass_Control.Alternative.Alternative_1"]());
      }, function () {
          return monadStateT(dictMonadZero["__superclass_Control.Monad.Monad_0"]());
      });
  };
  var monadPlusStateT = function (dictMonadPlus) {
      return new Control_MonadPlus.MonadPlus(function () {
          return monadZeroStateT(dictMonadPlus["__superclass_Control.MonadZero.MonadZero_0"]());
      });
  };
  exports["StateT"] = StateT;
  exports["evalStateT"] = evalStateT;
  exports["execStateT"] = execStateT;
  exports["mapStateT"] = mapStateT;
  exports["runStateT"] = runStateT;
  exports["withStateT"] = withStateT;
  exports["newtypeStateT"] = newtypeStateT;
  exports["functorStateT"] = functorStateT;
  exports["applyStateT"] = applyStateT;
  exports["applicativeStateT"] = applicativeStateT;
  exports["altStateT"] = altStateT;
  exports["plusStateT"] = plusStateT;
  exports["alternativeStateT"] = alternativeStateT;
  exports["bindStateT"] = bindStateT;
  exports["monadStateT"] = monadStateT;
  exports["monadRecStateT"] = monadRecStateT;
  exports["monadZeroStateT"] = monadZeroStateT;
  exports["monadPlusStateT"] = monadPlusStateT;
  exports["monadTransStateT"] = monadTransStateT;
  exports["lazyStateT"] = lazyStateT;
  exports["monadEffState"] = monadEffState;
  exports["monadContStateT"] = monadContStateT;
  exports["monadErrorStateT"] = monadErrorStateT;
  exports["monadAskStateT"] = monadAskStateT;
  exports["monadReaderStateT"] = monadReaderStateT;
  exports["monadStateStateT"] = monadStateStateT;
  exports["monadTellStateT"] = monadTellStateT;
  exports["monadWriterStateT"] = monadWriterStateT;
})(PS["Control.Monad.State.Trans"] = PS["Control.Monad.State.Trans"] || {});
(function(exports) {
  
  /**
 *  | This module defines the `State` monad.
 */  
  "use strict";
  var Prelude = PS["Prelude"];
  var Control_Monad_State_Class = PS["Control.Monad.State.Class"];
  var Control_Monad_State_Trans = PS["Control.Monad.State.Trans"];
  var Data_Identity = PS["Data.Identity"];
  var Data_Newtype = PS["Data.Newtype"];
  var Data_Tuple = PS["Data.Tuple"];
  var Control_Semigroupoid = PS["Control.Semigroupoid"];        

  /**
 *  | Modify the state in a `State` action
 */  
  var withState = Control_Monad_State_Trans.withStateT;

  /**
 *  | Run a computation in the `State` monad
 */  
  var runState = function (v) {
      return function ($14) {
          return Data_Newtype.unwrap(Data_Identity.newtypeIdentity)(v($14));
      };
  };

  /**
 *  | Change the type of the result in a `State` action
 */  
  var mapState = function (f) {
      return Control_Monad_State_Trans.mapStateT(function ($15) {
          return Data_Identity.Identity(f(Data_Newtype.unwrap(Data_Identity.newtypeIdentity)($15)));
      });
  };

  /**
 *  | Run a computation in the `State` monad, discarding the result
 */  
  var execState = function (v) {
      return function (s) {
          var $6 = v(s);
          return $6.value1;
      };
  };

  /**
 *  | Run a computation in the `State` monad, discarding the final state
 */  
  var evalState = function (v) {
      return function (s) {
          var $11 = v(s);
          return $11.value0;
      };
  };
  exports["evalState"] = evalState;
  exports["execState"] = execState;
  exports["mapState"] = mapState;
  exports["runState"] = runState;
  exports["withState"] = withState;
})(PS["Control.Monad.State"] = PS["Control.Monad.State"] || {});
(function(exports) {
  
  /**
 *  | A _trampoline_ monad, which can be used at the bottom of
 *  | a monad transformer stack to avoid stack overflows in large
 *  | monadic computations.
 */  
  "use strict";
  var Prelude = PS["Prelude"];
  var Control_Monad_Free = PS["Control.Monad.Free"];
  var Data_Lazy = PS["Data.Lazy"];
  var Control_Applicative = PS["Control.Applicative"];
  var Control_Semigroupoid = PS["Control.Semigroupoid"];        

  /**
 *  | Suspend a computation by one step.
 */  
  var suspend = Control_Monad_Free.suspendF(Data_Lazy.applicativeLazy);

  /**
 *  | Run a computation in the `Trampoline` monad.
 */  
  var runTrampoline = Control_Monad_Free.runFree(Data_Lazy.functorLazy)(Data_Lazy.force);

  /**
 *  | Return a value immediately
 */  
  var done = Control_Applicative.pure(Control_Monad_Free.freeApplicative);

  /**
 *  | Use the `Trampoline` monad to represent a `Lazy` value.
 */  
  var delay$prime = Control_Monad_Free.liftF;

  /**
 *  | Use the `Trampoline` monad to represent the delayed evaluation of a value.
 */  
  var delay = function ($0) {
      return delay$prime(Data_Lazy.defer($0));
  };
  exports["delay"] = delay;
  exports["delay'"] = delay$prime;
  exports["done"] = done;
  exports["runTrampoline"] = runTrampoline;
  exports["suspend"] = suspend;
})(PS["Control.Monad.Trampoline"] = PS["Control.Monad.Trampoline"] || {});
(function(exports) {
  
  /**
 *  | This module defines the writer monad transformer, `WriterT`.
 */  
  "use strict";
  var Prelude = PS["Prelude"];
  var Control_Alt = PS["Control.Alt"];
  var Control_Alternative = PS["Control.Alternative"];
  var Control_Monad_Cont_Class = PS["Control.Monad.Cont.Class"];
  var Control_Monad_Eff_Class = PS["Control.Monad.Eff.Class"];
  var Control_Monad_Error_Class = PS["Control.Monad.Error.Class"];
  var Control_Monad_Reader_Class = PS["Control.Monad.Reader.Class"];
  var Control_Monad_Rec_Class = PS["Control.Monad.Rec.Class"];
  var Control_Monad_State_Class = PS["Control.Monad.State.Class"];
  var Control_Monad_Trans_Class = PS["Control.Monad.Trans.Class"];
  var Control_Monad_Writer_Class = PS["Control.Monad.Writer.Class"];
  var Control_MonadPlus = PS["Control.MonadPlus"];
  var Control_MonadZero = PS["Control.MonadZero"];
  var Control_Plus = PS["Control.Plus"];
  var Data_Monoid = PS["Data.Monoid"];
  var Data_Newtype = PS["Data.Newtype"];
  var Data_Tuple = PS["Data.Tuple"];
  var Data_Functor = PS["Data.Functor"];
  var Data_Function = PS["Data.Function"];
  var Control_Apply = PS["Control.Apply"];
  var Data_Semigroup = PS["Data.Semigroup"];
  var Control_Applicative = PS["Control.Applicative"];
  var Control_Bind = PS["Control.Bind"];
  var Control_Monad = PS["Control.Monad"];
  var Control_Semigroupoid = PS["Control.Semigroupoid"];
  var Data_Unit = PS["Data.Unit"];        

  /**
 *  | The writer monad transformer.
 *  |
 *  | This monad transformer extends the base monad with a monoidal accumulator of
 *  | type `w`.
 *  |
 *  | The `MonadWriter` type class describes the operations supported by this monad.
 */  
  var WriterT = function (x) {
      return x;
  };

  /**
 *  | Run a computation in the `WriterT` monad.
 */  
  var runWriterT = function (v) {
      return v;
  };
  var newtypeWriterT = new Data_Newtype.Newtype(function (n) {
      return n;
  }, WriterT);
  var monadTransWriterT = function (dictMonoid) {
      return new Control_Monad_Trans_Class.MonadTrans(function (dictMonad) {
          return function (m) {
              return Control_Bind.bind(dictMonad["__superclass_Control.Bind.Bind_1"]())(m)(function (v) {
                  return Control_Applicative.pure(dictMonad["__superclass_Control.Applicative.Applicative_0"]())(new Data_Tuple.Tuple(v, Data_Monoid.mempty(dictMonoid)));
              });
          };
      });
  };

  /**
 *  | Change the accumulator and base monad types in a `WriterT` monad action.
 */  
  var mapWriterT = function (f) {
      return function (v) {
          return f(v);
      };
  };
  var functorWriterT = function (dictFunctor) {
      return new Data_Functor.Functor(function (f) {
          return mapWriterT(Data_Functor.map(dictFunctor)(function (v) {
              return new Data_Tuple.Tuple(f(v.value0), v.value1);
          }));
      });
  };

  /**
 *  | Run a computation in the `WriterT` monad, discarding the result.
 */  
  var execWriterT = function (dictFunctor) {
      return function (v) {
          return Data_Functor.map(dictFunctor)(Data_Tuple.snd)(v);
      };
  };
  var applyWriterT = function (dictSemigroup) {
      return function (dictApply) {
          return new Control_Apply.Apply(function () {
              return functorWriterT(dictApply["__superclass_Data.Functor.Functor_0"]());
          }, function (v) {
              return function (v1) {
                  var k = function (v3) {
                      return function (v4) {
                          return new Data_Tuple.Tuple(v3.value0(v4.value0), Data_Semigroup.append(dictSemigroup)(v3.value1)(v4.value1));
                      };
                  };
                  return Control_Apply.apply(dictApply)(Data_Functor.map(dictApply["__superclass_Data.Functor.Functor_0"]())(k)(v))(v1);
              };
          });
      };
  };
  var bindWriterT = function (dictSemigroup) {
      return function (dictBind) {
          return new Control_Bind.Bind(function () {
              return applyWriterT(dictSemigroup)(dictBind["__superclass_Control.Apply.Apply_0"]());
          }, function (v) {
              return function (k) {
                  return WriterT(Control_Bind.bind(dictBind)(v)(function (v1) {
                      var $81 = k(v1.value0);
                      return Data_Functor.map((dictBind["__superclass_Control.Apply.Apply_0"]())["__superclass_Data.Functor.Functor_0"]())(function (v2) {
                          return new Data_Tuple.Tuple(v2.value0, Data_Semigroup.append(dictSemigroup)(v1.value1)(v2.value1));
                      })($81);
                  }));
              };
          });
      };
  };
  var applicativeWriterT = function (dictMonoid) {
      return function (dictApplicative) {
          return new Control_Applicative.Applicative(function () {
              return applyWriterT(dictMonoid["__superclass_Data.Semigroup.Semigroup_0"]())(dictApplicative["__superclass_Control.Apply.Apply_0"]());
          }, function (a) {
              return WriterT(Control_Applicative.pure(dictApplicative)(new Data_Tuple.Tuple(a, Data_Monoid.mempty(dictMonoid))));
          });
      };
  };
  var monadWriterT = function (dictMonoid) {
      return function (dictMonad) {
          return new Control_Monad.Monad(function () {
              return applicativeWriterT(dictMonoid)(dictMonad["__superclass_Control.Applicative.Applicative_0"]());
          }, function () {
              return bindWriterT(dictMonoid["__superclass_Data.Semigroup.Semigroup_0"]())(dictMonad["__superclass_Control.Bind.Bind_1"]());
          });
      };
  };
  var monadAskWriterT = function (dictMonoid) {
      return function (dictMonadAsk) {
          return new Control_Monad_Reader_Class.MonadAsk(function () {
              return monadWriterT(dictMonoid)(dictMonadAsk["__superclass_Control.Monad.Monad_0"]());
          }, Control_Monad_Trans_Class.lift(monadTransWriterT(dictMonoid))(dictMonadAsk["__superclass_Control.Monad.Monad_0"]())(Control_Monad_Reader_Class.ask(dictMonadAsk)));
      };
  };
  var monadReaderWriterT = function (dictMonoid) {
      return function (dictMonadReader) {
          return new Control_Monad_Reader_Class.MonadReader(function () {
              return monadAskWriterT(dictMonoid)(dictMonadReader["__superclass_Control.Monad.Reader.Class.MonadAsk_0"]());
          }, function (f) {
              return mapWriterT(Control_Monad_Reader_Class.local(dictMonadReader)(f));
          });
      };
  };
  var monadContWriterT = function (dictMonoid) {
      return function (dictMonadCont) {
          return new Control_Monad_Cont_Class.MonadCont(function () {
              return monadWriterT(dictMonoid)(dictMonadCont["__superclass_Control.Monad.Monad_0"]());
          }, function (f) {
              return WriterT(Control_Monad_Cont_Class.callCC(dictMonadCont)(function (c) {
                  var $87 = f(function (a) {
                      return WriterT(c(new Data_Tuple.Tuple(a, Data_Monoid.mempty(dictMonoid))));
                  });
                  return $87;
              }));
          });
      };
  };
  var monadEffWriter = function (dictMonoid) {
      return function (dictMonadEff) {
          return new Control_Monad_Eff_Class.MonadEff(function () {
              return monadWriterT(dictMonoid)(dictMonadEff["__superclass_Control.Monad.Monad_0"]());
          }, function ($113) {
              return Control_Monad_Trans_Class.lift(monadTransWriterT(dictMonoid))(dictMonadEff["__superclass_Control.Monad.Monad_0"]())(Control_Monad_Eff_Class.liftEff(dictMonadEff)($113));
          });
      };
  };
  var monadErrorWriterT = function (dictMonoid) {
      return function (dictMonadError) {
          return new Control_Monad_Error_Class.MonadError(function () {
              return monadWriterT(dictMonoid)(dictMonadError["__superclass_Control.Monad.Monad_0"]());
          }, function (v) {
              return function (h) {
                  return WriterT(Control_Monad_Error_Class.catchError(dictMonadError)(v)(function (e) {
                      var $90 = h(e);
                      return $90;
                  }));
              };
          }, function (e) {
              return Control_Monad_Trans_Class.lift(monadTransWriterT(dictMonoid))(dictMonadError["__superclass_Control.Monad.Monad_0"]())(Control_Monad_Error_Class.throwError(dictMonadError)(e));
          });
      };
  };
  var monadRecWriterT = function (dictMonoid) {
      return function (dictMonadRec) {
          return new Control_Monad_Rec_Class.MonadRec(function () {
              return monadWriterT(dictMonoid)(dictMonadRec["__superclass_Control.Monad.Monad_0"]());
          }, function (f) {
              return function (a) {
                  var f$prime = function (v) {
                      return Control_Bind.bind((dictMonadRec["__superclass_Control.Monad.Monad_0"]())["__superclass_Control.Bind.Bind_1"]())((function () {
                          var $92 = f(v.value0);
                          return $92;
                      })())(function (v1) {
                          return Control_Applicative.pure((dictMonadRec["__superclass_Control.Monad.Monad_0"]())["__superclass_Control.Applicative.Applicative_0"]())((function () {
                              if (v1.value0 instanceof Control_Monad_Rec_Class.Loop) {
                                  return new Control_Monad_Rec_Class.Loop(new Data_Tuple.Tuple(v1.value0.value0, Data_Semigroup.append(dictMonoid["__superclass_Data.Semigroup.Semigroup_0"]())(v.value1)(v1.value1)));
                              };
                              if (v1.value0 instanceof Control_Monad_Rec_Class.Done) {
                                  return new Control_Monad_Rec_Class.Done(new Data_Tuple.Tuple(v1.value0.value0, Data_Semigroup.append(dictMonoid["__superclass_Data.Semigroup.Semigroup_0"]())(v.value1)(v1.value1)));
                              };
                              throw new Error("Failed pattern match at Control.Monad.Writer.Trans line 85, column 16 - line 87, column 47: " + [ v1.value0.constructor.name ]);
                          })());
                      });
                  };
                  return WriterT(Control_Monad_Rec_Class.tailRecM(dictMonadRec)(f$prime)(new Data_Tuple.Tuple(a, Data_Monoid.mempty(dictMonoid))));
              };
          });
      };
  };
  var monadStateWriterT = function (dictMonoid) {
      return function (dictMonadState) {
          return new Control_Monad_State_Class.MonadState(function () {
              return monadWriterT(dictMonoid)(dictMonadState["__superclass_Control.Monad.Monad_0"]());
          }, function (f) {
              return Control_Monad_Trans_Class.lift(monadTransWriterT(dictMonoid))(dictMonadState["__superclass_Control.Monad.Monad_0"]())(Control_Monad_State_Class.state(dictMonadState)(f));
          });
      };
  };
  var monadTellWriterT = function (dictMonoid) {
      return function (dictMonad) {
          return new Control_Monad_Writer_Class.MonadTell(function () {
              return monadWriterT(dictMonoid)(dictMonad);
          }, function ($114) {
              return WriterT(Control_Applicative.pure(dictMonad["__superclass_Control.Applicative.Applicative_0"]())(Data_Tuple.Tuple.create(Data_Unit.unit)($114)));
          });
      };
  };
  var monadWriterWriterT = function (dictMonoid) {
      return function (dictMonad) {
          return new Control_Monad_Writer_Class.MonadWriter(function () {
              return monadTellWriterT(dictMonoid)(dictMonad);
          }, function (v) {
              return Control_Bind.bind(dictMonad["__superclass_Control.Bind.Bind_1"]())(v)(function (v1) {
                  return Control_Applicative.pure(dictMonad["__superclass_Control.Applicative.Applicative_0"]())(new Data_Tuple.Tuple(new Data_Tuple.Tuple(v1.value0, v1.value1), v1.value1));
              });
          }, function (v) {
              return Control_Bind.bind(dictMonad["__superclass_Control.Bind.Bind_1"]())(v)(function (v1) {
                  return Control_Applicative.pure(dictMonad["__superclass_Control.Applicative.Applicative_0"]())(new Data_Tuple.Tuple(v1.value0.value0, v1.value0.value1(v1.value1)));
              });
          });
      };
  };
  var altWriterT = function (dictAlt) {
      return new Control_Alt.Alt(function () {
          return functorWriterT(dictAlt["__superclass_Data.Functor.Functor_0"]());
      }, function (v) {
          return function (v1) {
              return Control_Alt.alt(dictAlt)(v)(v1);
          };
      });
  };
  var plusWriterT = function (dictPlus) {
      return new Control_Plus.Plus(function () {
          return altWriterT(dictPlus["__superclass_Control.Alt.Alt_0"]());
      }, Control_Plus.empty(dictPlus));
  };
  var alternativeWriterT = function (dictMonoid) {
      return function (dictAlternative) {
          return new Control_Alternative.Alternative(function () {
              return applicativeWriterT(dictMonoid)(dictAlternative["__superclass_Control.Applicative.Applicative_0"]());
          }, function () {
              return plusWriterT(dictAlternative["__superclass_Control.Plus.Plus_1"]());
          });
      };
  };
  var monadZeroWriterT = function (dictMonoid) {
      return function (dictMonadZero) {
          return new Control_MonadZero.MonadZero(function () {
              return alternativeWriterT(dictMonoid)(dictMonadZero["__superclass_Control.Alternative.Alternative_1"]());
          }, function () {
              return monadWriterT(dictMonoid)(dictMonadZero["__superclass_Control.Monad.Monad_0"]());
          });
      };
  };
  var monadPlusWriterT = function (dictMonoid) {
      return function (dictMonadPlus) {
          return new Control_MonadPlus.MonadPlus(function () {
              return monadZeroWriterT(dictMonoid)(dictMonadPlus["__superclass_Control.MonadZero.MonadZero_0"]());
          });
      };
  };
  exports["WriterT"] = WriterT;
  exports["execWriterT"] = execWriterT;
  exports["mapWriterT"] = mapWriterT;
  exports["runWriterT"] = runWriterT;
  exports["newtypeWriterT"] = newtypeWriterT;
  exports["functorWriterT"] = functorWriterT;
  exports["applyWriterT"] = applyWriterT;
  exports["applicativeWriterT"] = applicativeWriterT;
  exports["altWriterT"] = altWriterT;
  exports["plusWriterT"] = plusWriterT;
  exports["alternativeWriterT"] = alternativeWriterT;
  exports["bindWriterT"] = bindWriterT;
  exports["monadWriterT"] = monadWriterT;
  exports["monadRecWriterT"] = monadRecWriterT;
  exports["monadZeroWriterT"] = monadZeroWriterT;
  exports["monadPlusWriterT"] = monadPlusWriterT;
  exports["monadTransWriterT"] = monadTransWriterT;
  exports["monadEffWriter"] = monadEffWriter;
  exports["monadContWriterT"] = monadContWriterT;
  exports["monadErrorWriterT"] = monadErrorWriterT;
  exports["monadAskWriterT"] = monadAskWriterT;
  exports["monadReaderWriterT"] = monadReaderWriterT;
  exports["monadStateWriterT"] = monadStateWriterT;
  exports["monadTellWriterT"] = monadTellWriterT;
  exports["monadWriterWriterT"] = monadWriterWriterT;
})(PS["Control.Monad.Writer.Trans"] = PS["Control.Monad.Writer.Trans"] || {});
(function(exports) {
  
  /**
 *  | This module defines the `Writer` monad.
 */  
  "use strict";
  var Prelude = PS["Prelude"];
  var Control_Monad_Writer_Class = PS["Control.Monad.Writer.Class"];
  var Control_Monad_Writer_Trans = PS["Control.Monad.Writer.Trans"];
  var Data_Identity = PS["Data.Identity"];
  var Data_Newtype = PS["Data.Newtype"];
  var Data_Tuple = PS["Data.Tuple"];
  var Control_Semigroupoid = PS["Control.Semigroupoid"];        

  /**
 *  | Run a computation in the `Writer` monad
 */  
  var runWriter = function ($0) {
      return Data_Newtype.unwrap(Data_Identity.newtypeIdentity)(Control_Monad_Writer_Trans.runWriterT($0));
  };

  /**
 *  | Change the result and accumulator types in a `Writer` monad action
 */  
  var mapWriter = function (f) {
      return Control_Monad_Writer_Trans.mapWriterT(function ($1) {
          return Data_Identity.Identity(f(Data_Newtype.unwrap(Data_Identity.newtypeIdentity)($1)));
      });
  };

  /**
 *  | Run a computation in the `Writer` monad, discarding the result
 */  
  var execWriter = function (m) {
      return Data_Tuple.snd(runWriter(m));
  };
  exports["execWriter"] = execWriter;
  exports["mapWriter"] = mapWriter;
  exports["runWriter"] = runWriter;
})(PS["Control.Monad.Writer"] = PS["Control.Monad.Writer"] || {});
(function(exports) {
  
  /**
 *  | Partial helper functions for working with immutable arrays.
 */  
  "use strict";
  var Prelude = PS["Prelude"];
  var Data_Array = PS["Data.Array"];
  var Data_Ring = PS["Data.Ring"];        

  /**
 *  | Get all but the first element of a non-empty array.
 *  |
 *  | Running time: `O(n)`, where `n` is the length of the array.
 */  
  var tail = function (dictPartial) {
      return function (xs) {
          return Data_Array.slice(1)(Data_Array.length(xs))(xs);
      };
  };

  /**
 *  | Get the last element of a non-empty array.
 *  |
 *  | Running time: `O(1)`.
 */  
  var last = function (dictPartial) {
      return function (xs) {
          return xs[Data_Array.length(xs) - 1];
      };
  };

  /**
 *  | Get all but the last element of a non-empty array.
 *  |
 *  | Running time: `O(n)`, where `n` is the length of the array.
 */  
  var init = function (dictPartial) {
      return function (xs) {
          return Data_Array.slice(0)(Data_Array.length(xs) - 1)(xs);
      };
  };

  /**
 *  | Get the first element of a non-empty array.
 *  |
 *  | Running time: `O(1)`.
 */  
  var head = function (dictPartial) {
      return function (xs) {
          return xs[0];
      };
  };
  exports["head"] = head;
  exports["init"] = init;
  exports["last"] = last;
  exports["tail"] = tail;
})(PS["Data.Array.Partial"] = PS["Data.Array.Partial"] || {});
(function(exports) {
    "use strict";

  exports.runSTArray = function (f) {
    return f;
  };

  exports.emptySTArray = function () {
    return [];
  };

  exports.peekSTArrayImpl = function (just) {
    return function (nothing) {
      return function (xs) {
        return function (i) {
          return function () {
            return i >= 0 && i < xs.length ? just(xs[i]) : nothing;
          };
        };
      };
    };
  };

  exports.pokeSTArray = function (xs) {
    return function (i) {
      return function (a) {
        return function () {
          var ret = i >= 0 && i < xs.length;
          if (ret) xs[i] = a;
          return ret;
        };
      };
    };
  };

  exports.pushAllSTArray = function (xs) {
    return function (as) {
      return function () {
        return xs.push.apply(xs, as);
      };
    };
  };

  exports.spliceSTArray = function (xs) {
    return function (i) {
      return function (howMany) {
        return function (bs) {
          return function () {
            return xs.splice.apply(xs, [i, howMany].concat(bs));
          };
        };
      };
    };
  };

  exports.copyImpl = function (xs) {
    return function () {
      return xs.slice();
    };
  };

  exports.toAssocArray = function (xs) {
    return function () {
      var n = xs.length;
      var as = new Array(n);
      for (var i = 0; i < n; i++) as[i] = { value: xs[i], index: i };
      return as;
    };
  };
})(PS["Data.Array.ST"] = PS["Data.Array.ST"] || {});
(function(exports) {
  
  /**
 *  | Helper functions for working with mutable arrays using the `ST` effect.
 *  |
 *  | This module can be used when performance is important and mutation is a local effect.
 */  
  "use strict";
  var $foreign = PS["Data.Array.ST"];
  var Control_Monad_Eff = PS["Control.Monad.Eff"];
  var Control_Monad_ST = PS["Control.Monad.ST"];
  var Data_Maybe = PS["Data.Maybe"];        

  /**
 *  | Create a mutable copy of an immutable array.
 */  
  var thaw = $foreign.copyImpl;

  /**
 *  | Append an element to the end of a mutable array.
 */  
  var pushSTArray = function (arr) {
      return function (a) {
          return $foreign.pushAllSTArray(arr)([ a ]);
      };
  };

  /**
 *  | Read the value at the specified index in a mutable array.
 */  
  var peekSTArray = $foreign.peekSTArrayImpl(Data_Maybe.Just.create)(Data_Maybe.Nothing.value);

  /**
 *  | Create an immutable copy of a mutable array.
 */  
  var freeze = $foreign.copyImpl;
  exports["freeze"] = freeze;
  exports["peekSTArray"] = peekSTArray;
  exports["pushSTArray"] = pushSTArray;
  exports["thaw"] = thaw;
  exports["emptySTArray"] = $foreign.emptySTArray;
  exports["pokeSTArray"] = $foreign.pokeSTArray;
  exports["pushAllSTArray"] = $foreign.pushAllSTArray;
  exports["runSTArray"] = $foreign.runSTArray;
  exports["spliceSTArray"] = $foreign.spliceSTArray;
  exports["toAssocArray"] = $foreign.toAssocArray;
})(PS["Data.Array.ST"] = PS["Data.Array.ST"] || {});
(function(exports) {
    "use strict";
  var Prelude = PS["Prelude"];
  var Control_Biapplicative = PS["Control.Biapplicative"];
  var Control_Biapply = PS["Control.Biapply"];
  var Data_Bifunctor = PS["Data.Bifunctor"];
  var Data_Newtype = PS["Data.Newtype"];
  var Data_Eq = PS["Data.Eq"];
  var Data_Ord = PS["Data.Ord"];
  var Data_Show = PS["Data.Show"];
  var Data_Semigroup = PS["Data.Semigroup"];
  var Data_Functor = PS["Data.Functor"];
  var Control_Apply = PS["Control.Apply"];
  var Control_Applicative = PS["Control.Applicative"];        

  /**
 *  | Make a `Functor` over the first argument of a `Bifunctor`
 */  
  var Clown = function (x) {
      return x;
  };
  var showClown = function (dictShow) {
      return new Data_Show.Show(function (v) {
          return "(Clown " + (Data_Show.show(dictShow)(v) + ")");
      });
  };
  var ordClown = function (dictOrd) {
      return dictOrd;
  };
  var newtypeClown = new Data_Newtype.Newtype(function (n) {
      return n;
  }, Clown);
  var functorClown = new Data_Functor.Functor(function (v) {
      return function (v1) {
          return v1;
      };
  });
  var eqClown = function (dictEq) {
      return dictEq;
  };
  var bifunctorClown = function (dictFunctor) {
      return new Data_Bifunctor.Bifunctor(function (f) {
          return function (v) {
              return function (v1) {
                  return Data_Functor.map(dictFunctor)(f)(v1);
              };
          };
      });
  };
  var biapplyClown = function (dictApply) {
      return new Control_Biapply.Biapply(function () {
          return bifunctorClown(dictApply["__superclass_Data.Functor.Functor_0"]());
      }, function (v) {
          return function (v1) {
              return Control_Apply.apply(dictApply)(v)(v1);
          };
      });
  };
  var biapplicativeClown = function (dictApplicative) {
      return new Control_Biapplicative.Biapplicative(function () {
          return biapplyClown(dictApplicative["__superclass_Control.Apply.Apply_0"]());
      }, function (a) {
          return function (v) {
              return Control_Applicative.pure(dictApplicative)(a);
          };
      });
  };
  exports["Clown"] = Clown;
  exports["newtypeClown"] = newtypeClown;
  exports["eqClown"] = eqClown;
  exports["ordClown"] = ordClown;
  exports["showClown"] = showClown;
  exports["functorClown"] = functorClown;
  exports["bifunctorClown"] = bifunctorClown;
  exports["biapplyClown"] = biapplyClown;
  exports["biapplicativeClown"] = biapplicativeClown;
})(PS["Data.Bifunctor.Clown"] = PS["Data.Bifunctor.Clown"] || {});
(function(exports) {
    "use strict";
  var Prelude = PS["Prelude"];
  var Control_Biapplicative = PS["Control.Biapplicative"];
  var Control_Biapply = PS["Control.Biapply"];
  var Data_Bifunctor = PS["Data.Bifunctor"];
  var Data_Newtype = PS["Data.Newtype"];
  var Data_Eq = PS["Data.Eq"];
  var Data_Ord = PS["Data.Ord"];
  var Data_Show = PS["Data.Show"];
  var Data_Semigroup = PS["Data.Semigroup"];
  var Data_Functor = PS["Data.Functor"];        

  /**
 *  | Flips the order of the type arguments of a `Bifunctor`.
 */  
  var Flip = function (x) {
      return x;
  };
  var showFlip = function (dictShow) {
      return new Data_Show.Show(function (v) {
          return "(Flip " + (Data_Show.show(dictShow)(v) + ")");
      });
  };
  var ordFlip = function (dictOrd) {
      return dictOrd;
  };
  var newtypeFlip = new Data_Newtype.Newtype(function (n) {
      return n;
  }, Flip);
  var functorFlip = function (dictBifunctor) {
      return new Data_Functor.Functor(function (f) {
          return function (v) {
              return Data_Bifunctor.lmap(dictBifunctor)(f)(v);
          };
      });
  };
  var eqFlip = function (dictEq) {
      return dictEq;
  };
  var bifunctorFlip = function (dictBifunctor) {
      return new Data_Bifunctor.Bifunctor(function (f) {
          return function (g) {
              return function (v) {
                  return Data_Bifunctor.bimap(dictBifunctor)(g)(f)(v);
              };
          };
      });
  };
  var biapplyFlip = function (dictBiapply) {
      return new Control_Biapply.Biapply(function () {
          return bifunctorFlip(dictBiapply["__superclass_Data.Bifunctor.Bifunctor_0"]());
      }, function (v) {
          return function (v1) {
              return Control_Biapply.biapply(dictBiapply)(v)(v1);
          };
      });
  };
  var biapplicativeFlip = function (dictBiapplicative) {
      return new Control_Biapplicative.Biapplicative(function () {
          return biapplyFlip(dictBiapplicative["__superclass_Control.Biapply.Biapply_0"]());
      }, function (a) {
          return function (b) {
              return Control_Biapplicative.bipure(dictBiapplicative)(b)(a);
          };
      });
  };
  exports["Flip"] = Flip;
  exports["newtypeFlip"] = newtypeFlip;
  exports["eqFlip"] = eqFlip;
  exports["ordFlip"] = ordFlip;
  exports["showFlip"] = showFlip;
  exports["functorFlip"] = functorFlip;
  exports["bifunctorFlip"] = bifunctorFlip;
  exports["biapplyFlip"] = biapplyFlip;
  exports["biapplicativeFlip"] = biapplicativeFlip;
})(PS["Data.Bifunctor.Flip"] = PS["Data.Bifunctor.Flip"] || {});
(function(exports) {
    "use strict";
  var Prelude = PS["Prelude"];
  var Control_Biapplicative = PS["Control.Biapplicative"];
  var Control_Biapply = PS["Control.Biapply"];
  var Data_Bifunctor = PS["Data.Bifunctor"];
  var Data_Newtype = PS["Data.Newtype"];
  var Data_Eq = PS["Data.Eq"];
  var Data_Ord = PS["Data.Ord"];
  var Data_Show = PS["Data.Show"];
  var Data_Semigroup = PS["Data.Semigroup"];
  var Data_Functor = PS["Data.Functor"];
  var Control_Apply = PS["Control.Apply"];
  var Control_Applicative = PS["Control.Applicative"];        

  /**
 *  | Turns a `Bifunctor` into a `Functor` by equating the two type arguments.
 */  
  var Join = function (x) {
      return x;
  };
  var showJoin = function (dictShow) {
      return new Data_Show.Show(function (v) {
          return "(Join " + (Data_Show.show(dictShow)(v) + ")");
      });
  };
  var ordJoin = function (dictOrd) {
      return dictOrd;
  };
  var newtypeJoin = new Data_Newtype.Newtype(function (n) {
      return n;
  }, Join);
  var eqJoin = function (dictEq) {
      return dictEq;
  };
  var bifunctorJoin = function (dictBifunctor) {
      return new Data_Functor.Functor(function (f) {
          return function (v) {
              return Data_Bifunctor.bimap(dictBifunctor)(f)(f)(v);
          };
      });
  };
  var biapplyJoin = function (dictBiapply) {
      return new Control_Apply.Apply(function () {
          return bifunctorJoin(dictBiapply["__superclass_Data.Bifunctor.Bifunctor_0"]());
      }, function (v) {
          return function (v1) {
              return Control_Biapply.biapply(dictBiapply)(v)(v1);
          };
      });
  };
  var biapplicativeJoin = function (dictBiapplicative) {
      return new Control_Applicative.Applicative(function () {
          return biapplyJoin(dictBiapplicative["__superclass_Control.Biapply.Biapply_0"]());
      }, function (a) {
          return Control_Biapplicative.bipure(dictBiapplicative)(a)(a);
      });
  };
  exports["Join"] = Join;
  exports["newtypeJoin"] = newtypeJoin;
  exports["eqJoin"] = eqJoin;
  exports["ordJoin"] = ordJoin;
  exports["showJoin"] = showJoin;
  exports["bifunctorJoin"] = bifunctorJoin;
  exports["biapplyJoin"] = biapplyJoin;
  exports["biapplicativeJoin"] = biapplicativeJoin;
})(PS["Data.Bifunctor.Join"] = PS["Data.Bifunctor.Join"] || {});
(function(exports) {
    "use strict";
  var Prelude = PS["Prelude"];
  var Control_Biapplicative = PS["Control.Biapplicative"];
  var Control_Biapply = PS["Control.Biapply"];
  var Data_Bifunctor = PS["Data.Bifunctor"];
  var Data_Newtype = PS["Data.Newtype"];
  var Data_Eq = PS["Data.Eq"];
  var Data_Ord = PS["Data.Ord"];
  var Data_Show = PS["Data.Show"];
  var Data_Semigroup = PS["Data.Semigroup"];
  var Data_Functor = PS["Data.Functor"];
  var Control_Apply = PS["Control.Apply"];
  var Control_Applicative = PS["Control.Applicative"];        

  /**
 *  | Make a `Functor` over the second argument of a `Bifunctor`
 */  
  var Joker = function (x) {
      return x;
  };
  var showJoker = function (dictShow) {
      return new Data_Show.Show(function (v) {
          return "(Joker " + (Data_Show.show(dictShow)(v) + ")");
      });
  };
  var ordJoker = function (dictOrd) {
      return dictOrd;
  };
  var newtypeJoker = new Data_Newtype.Newtype(function (n) {
      return n;
  }, Joker);
  var functorJoker = function (dictFunctor) {
      return new Data_Functor.Functor(function (g) {
          return function (v) {
              return Data_Functor.map(dictFunctor)(g)(v);
          };
      });
  };
  var eqJoker = function (dictEq) {
      return dictEq;
  };
  var bifunctorJoker = function (dictFunctor) {
      return new Data_Bifunctor.Bifunctor(function (v) {
          return function (g) {
              return function (v1) {
                  return Data_Functor.map(dictFunctor)(g)(v1);
              };
          };
      });
  };
  var biapplyJoker = function (dictApply) {
      return new Control_Biapply.Biapply(function () {
          return bifunctorJoker(dictApply["__superclass_Data.Functor.Functor_0"]());
      }, function (v) {
          return function (v1) {
              return Control_Apply.apply(dictApply)(v)(v1);
          };
      });
  };
  var biapplicativeJoker = function (dictApplicative) {
      return new Control_Biapplicative.Biapplicative(function () {
          return biapplyJoker(dictApplicative["__superclass_Control.Apply.Apply_0"]());
      }, function (v) {
          return function (b) {
              return Control_Applicative.pure(dictApplicative)(b);
          };
      });
  };
  exports["Joker"] = Joker;
  exports["newtypeJoker"] = newtypeJoker;
  exports["eqJoker"] = eqJoker;
  exports["ordJoker"] = ordJoker;
  exports["showJoker"] = showJoker;
  exports["functorJoker"] = functorJoker;
  exports["bifunctorJoker"] = bifunctorJoker;
  exports["biapplyJoker"] = biapplyJoker;
  exports["biapplicativeJoker"] = biapplicativeJoker;
})(PS["Data.Bifunctor.Joker"] = PS["Data.Bifunctor.Joker"] || {});
(function(exports) {
    "use strict";
  var Prelude = PS["Prelude"];
  var Control_Biapplicative = PS["Control.Biapplicative"];
  var Control_Biapply = PS["Control.Biapply"];
  var Data_Bifunctor = PS["Data.Bifunctor"];
  var Data_Eq = PS["Data.Eq"];
  var Data_HeytingAlgebra = PS["Data.HeytingAlgebra"];
  var Data_Ord = PS["Data.Ord"];
  var Data_Ordering = PS["Data.Ordering"];
  var Data_Show = PS["Data.Show"];
  var Data_Semigroup = PS["Data.Semigroup"];        

  /**
 *  | The product of two `Bifunctor`s.
 */  
  var Product = (function () {
      function Product(value0, value1) {
          this.value0 = value0;
          this.value1 = value1;
      };
      Product.create = function (value0) {
          return function (value1) {
              return new Product(value0, value1);
          };
      };
      return Product;
  })();
  var showProduct = function (dictShow) {
      return function (dictShow1) {
          return new Data_Show.Show(function (v) {
              return "(Product " + (Data_Show.show(dictShow)(v.value0) + (" " + (Data_Show.show(dictShow1)(v.value1) + ")")));
          });
      };
  };
  var eqProduct = function (dictEq) {
      return function (dictEq1) {
          return new Data_Eq.Eq(function (x) {
              return function (y) {
                  return Data_Eq.eq(dictEq)(x.value0)(y.value0) && Data_Eq.eq(dictEq1)(x.value1)(y.value1);
              };
          });
      };
  };
  var ordProduct = function (dictOrd) {
      return function (dictOrd1) {
          return new Data_Ord.Ord(function () {
              return eqProduct(dictOrd["__superclass_Data.Eq.Eq_0"]())(dictOrd1["__superclass_Data.Eq.Eq_0"]());
          }, function (x) {
              return function (y) {
                  var $39 = Data_Ord.compare(dictOrd)(x.value0)(y.value0);
                  if ($39 instanceof Data_Ordering.LT) {
                      return Data_Ordering.LT.value;
                  };
                  if ($39 instanceof Data_Ordering.GT) {
                      return Data_Ordering.GT.value;
                  };
                  return Data_Ord.compare(dictOrd1)(x.value1)(y.value1);
              };
          });
      };
  };
  var bifunctorProduct = function (dictBifunctor) {
      return function (dictBifunctor1) {
          return new Data_Bifunctor.Bifunctor(function (f) {
              return function (g) {
                  return function (v) {
                      return new Product(Data_Bifunctor.bimap(dictBifunctor)(f)(g)(v.value0), Data_Bifunctor.bimap(dictBifunctor1)(f)(g)(v.value1));
                  };
              };
          });
      };
  };
  var biapplyProduct = function (dictBiapply) {
      return function (dictBiapply1) {
          return new Control_Biapply.Biapply(function () {
              return bifunctorProduct(dictBiapply["__superclass_Data.Bifunctor.Bifunctor_0"]())(dictBiapply1["__superclass_Data.Bifunctor.Bifunctor_0"]());
          }, function (v) {
              return function (v1) {
                  return new Product(Control_Biapply.biapply(dictBiapply)(v.value0)(v1.value0), Control_Biapply.biapply(dictBiapply1)(v.value1)(v1.value1));
              };
          });
      };
  };
  var biapplicativeProduct = function (dictBiapplicative) {
      return function (dictBiapplicative1) {
          return new Control_Biapplicative.Biapplicative(function () {
              return biapplyProduct(dictBiapplicative["__superclass_Control.Biapply.Biapply_0"]())(dictBiapplicative1["__superclass_Control.Biapply.Biapply_0"]());
          }, function (a) {
              return function (b) {
                  return new Product(Control_Biapplicative.bipure(dictBiapplicative)(a)(b), Control_Biapplicative.bipure(dictBiapplicative1)(a)(b));
              };
          });
      };
  };
  exports["Product"] = Product;
  exports["eqProduct"] = eqProduct;
  exports["ordProduct"] = ordProduct;
  exports["showProduct"] = showProduct;
  exports["bifunctorProduct"] = bifunctorProduct;
  exports["biapplyProduct"] = biapplyProduct;
  exports["biapplicativeProduct"] = biapplicativeProduct;
})(PS["Data.Bifunctor.Product"] = PS["Data.Bifunctor.Product"] || {});
(function(exports) {
    "use strict";
  var Prelude = PS["Prelude"];
  var Control_Biapplicative = PS["Control.Biapplicative"];
  var Control_Biapply = PS["Control.Biapply"];
  var Data_Bifunctor = PS["Data.Bifunctor"];
  var Data_Newtype = PS["Data.Newtype"];
  var Data_Eq = PS["Data.Eq"];
  var Data_Ord = PS["Data.Ord"];
  var Data_Show = PS["Data.Show"];
  var Data_Semigroup = PS["Data.Semigroup"];
  var Data_Functor = PS["Data.Functor"];        

  /**
 *  | Provides a `Functor` over the second argument of a `Bifunctor`.
 */  
  var Wrap = function (x) {
      return x;
  };
  var showWrap = function (dictShow) {
      return new Data_Show.Show(function (v) {
          return "(Wrap " + (Data_Show.show(dictShow)(v) + ")");
      });
  };
  var ordWrap = function (dictOrd) {
      return dictOrd;
  };
  var newtypeWrap = new Data_Newtype.Newtype(function (n) {
      return n;
  }, Wrap);
  var functorWrap = function (dictBifunctor) {
      return new Data_Functor.Functor(function (f) {
          return function (v) {
              return Data_Bifunctor.rmap(dictBifunctor)(f)(v);
          };
      });
  };
  var eqWrap = function (dictEq) {
      return dictEq;
  };
  var bifunctorWrap = function (dictBifunctor) {
      return new Data_Bifunctor.Bifunctor(function (f) {
          return function (g) {
              return function (v) {
                  return Data_Bifunctor.bimap(dictBifunctor)(f)(g)(v);
              };
          };
      });
  };
  var biapplyWrap = function (dictBiapply) {
      return new Control_Biapply.Biapply(function () {
          return bifunctorWrap(dictBiapply["__superclass_Data.Bifunctor.Bifunctor_0"]());
      }, function (v) {
          return function (v1) {
              return Control_Biapply.biapply(dictBiapply)(v)(v1);
          };
      });
  };
  var biapplicativeWrap = function (dictBiapplicative) {
      return new Control_Biapplicative.Biapplicative(function () {
          return biapplyWrap(dictBiapplicative["__superclass_Control.Biapply.Biapply_0"]());
      }, function (a) {
          return function (b) {
              return Control_Biapplicative.bipure(dictBiapplicative)(a)(b);
          };
      });
  };
  exports["Wrap"] = Wrap;
  exports["newtypeWrap"] = newtypeWrap;
  exports["eqWrap"] = eqWrap;
  exports["ordWrap"] = ordWrap;
  exports["showWrap"] = showWrap;
  exports["functorWrap"] = functorWrap;
  exports["bifunctorWrap"] = bifunctorWrap;
  exports["biapplyWrap"] = biapplyWrap;
  exports["biapplicativeWrap"] = biapplicativeWrap;
})(PS["Data.Bifunctor.Wrap"] = PS["Data.Bifunctor.Wrap"] || {});
(function(exports) {
    "use strict";

  exports.toCharCode = function (c) {
    return c.charCodeAt(0);
  };

  exports.fromCharCode = function (c) {
    return String.fromCharCode(c);
  };

  exports.toLower = function (c) {
    return c.toLowerCase();
  };

  exports.toUpper = function (c) {
    return c.toUpperCase();
  };
})(PS["Data.Char"] = PS["Data.Char"] || {});
(function(exports) {
  
  /**
 *  | A type and functions for single characters.
 */  
  "use strict";
  var $foreign = PS["Data.Char"];
  exports["fromCharCode"] = $foreign.fromCharCode;
  exports["toCharCode"] = $foreign.toCharCode;
  exports["toLower"] = $foreign.toLower;
  exports["toUpper"] = $foreign.toUpper;
})(PS["Data.Char"] = PS["Data.Char"] || {});
(function(exports) {
    "use strict";
  var Prelude = PS["Prelude"];
  var Data_Functor = PS["Data.Functor"];
  var Data_Void = PS["Data.Void"];        

  /**
 *  | A `Contravariant` functor can be seen as a way of changing the input type
 *  | of a consumer of input, in contrast to the standard covariant `Functor`
 *  | that can be seen as a way of changing the output type of a producer of
 *  | output.
 *  |
 *  | `Contravariant` instances should satisfy the following laws:
 *  |
 *  | - Identity `(>$<) id = id`
 *  | - Composition `(f >$<) <<< (g >$<) = (>$<) (g <<< f)`
 */  
  var Contravariant = function (cmap) {
      this.cmap = cmap;
  };

  /**
 *  | A `Contravariant` functor can be seen as a way of changing the input type
 *  | of a consumer of input, in contrast to the standard covariant `Functor`
 *  | that can be seen as a way of changing the output type of a producer of
 *  | output.
 *  |
 *  | `Contravariant` instances should satisfy the following laws:
 *  |
 *  | - Identity `(>$<) id = id`
 *  | - Composition `(f >$<) <<< (g >$<) = (>$<) (g <<< f)`
 */  
  var cmap = function (dict) {
      return dict.cmap;
  };

  /**
 *  | `cmapFlipped` is `cmap` with its arguments reversed.
 */  
  var cmapFlipped = function (dictContravariant) {
      return function (x) {
          return function (f) {
              return cmap(dictContravariant)(f)(x);
          };
      };
  };
  var coerce = function (dictContravariant) {
      return function (dictFunctor) {
          return function (a) {
              return Data_Functor.map(dictFunctor)(Data_Void.absurd)(cmap(dictContravariant)(Data_Void.absurd)(a));
          };
      };
  };
  exports["Contravariant"] = Contravariant;
  exports["cmap"] = cmap;
  exports["cmapFlipped"] = cmapFlipped;
  exports["coerce"] = coerce;
})(PS["Data.Functor.Contravariant"] = PS["Data.Functor.Contravariant"] || {});
(function(exports) {
    "use strict";
  var Prelude = PS["Prelude"];
  var Data_Function = PS["Data.Function"];
  var Data_Functor_Contravariant = PS["Data.Functor.Contravariant"];
  var Data_Monoid = PS["Data.Monoid"];
  var Data_Newtype = PS["Data.Newtype"];
  var Data_Semigroup = PS["Data.Semigroup"];
  var Data_Ordering = PS["Data.Ordering"];
  var Data_Ord = PS["Data.Ord"];        

  /**
 *  | An adaptor allowing `>$<` to map over the inputs of a comparison function.
 */  
  var Comparison = function (x) {
      return x;
  };
  var semigroupComparison = new Data_Semigroup.Semigroup(function (v) {
      return function (v1) {
          return Data_Semigroup.append(Data_Semigroup.semigroupFn(Data_Semigroup.semigroupFn(Data_Ordering.semigroupOrdering)))(v)(v1);
      };
  });
  var newtypeComparison = new Data_Newtype.Newtype(function (n) {
      return n;
  }, Comparison);
  var monoidComparison = new Data_Monoid.Monoid(function () {
      return semigroupComparison;
  }, function (v) {
      return function (v1) {
          return Data_Ordering.EQ.value;
      };
  });

  /**
 *  | The default comparison for any values with an `Ord` instance.
 */  
  var defaultComparison = function (dictOrd) {
      return Data_Ord.compare(dictOrd);
  };
  var contravariantComparison = new Data_Functor_Contravariant.Contravariant(function (f) {
      return function (v) {
          return Data_Function.on(v)(f);
      };
  });
  exports["Comparison"] = Comparison;
  exports["defaultComparison"] = defaultComparison;
  exports["newtypeComparison"] = newtypeComparison;
  exports["contravariantComparison"] = contravariantComparison;
  exports["semigroupComparison"] = semigroupComparison;
  exports["monoidComparison"] = monoidComparison;
})(PS["Data.Comparison"] = PS["Data.Comparison"] || {});
(function(exports) {
    "use strict";
  var Prelude = PS["Prelude"];
  var Data_Foldable = PS["Data.Foldable"];
  var Data_Functor_Contravariant = PS["Data.Functor.Contravariant"];
  var Data_Functor_Invariant = PS["Data.Functor.Invariant"];
  var Data_Monoid = PS["Data.Monoid"];
  var Data_Newtype = PS["Data.Newtype"];
  var Data_Traversable = PS["Data.Traversable"];
  var Data_Eq = PS["Data.Eq"];
  var Data_Ord = PS["Data.Ord"];
  var Data_Bounded = PS["Data.Bounded"];
  var Data_Show = PS["Data.Show"];
  var Data_Semigroup = PS["Data.Semigroup"];
  var Control_Semigroupoid = PS["Control.Semigroupoid"];
  var Data_Semiring = PS["Data.Semiring"];
  var Data_Ring = PS["Data.Ring"];
  var Data_EuclideanRing = PS["Data.EuclideanRing"];
  var Data_CommutativeRing = PS["Data.CommutativeRing"];
  var Data_Field = PS["Data.Field"];
  var Data_HeytingAlgebra = PS["Data.HeytingAlgebra"];
  var Data_BooleanAlgebra = PS["Data.BooleanAlgebra"];
  var Data_Functor = PS["Data.Functor"];
  var Control_Apply = PS["Control.Apply"];
  var Control_Bind = PS["Control.Bind"];
  var Control_Applicative = PS["Control.Applicative"];        

  /**
 *  | The `Const` type constructor, which wraps its first type argument
 *  | and ignores its second. That is, `Const a b` is isomorphic to `a`
 *  | for any `b`.
 *  |
 *  | `Const` has some useful instances. For example, the `Applicative`
 *  | instance allows us to collect results using a `Monoid` while
 *  | ignoring return values.
 */  
  var Const = function (x) {
      return x;
  };
  var showConst = function (dictShow) {
      return new Data_Show.Show(function (v) {
          return "(Const " + (Data_Show.show(dictShow)(v) + ")");
      });
  };
  var semiringConst = function (dictSemiring) {
      return dictSemiring;
  };
  var semigroupoidConst = new Control_Semigroupoid.Semigroupoid(function (v) {
      return function (v1) {
          return v1;
      };
  });
  var semigroupConst = function (dictSemigroup) {
      return dictSemigroup;
  };
  var ringConst = function (dictRing) {
      return dictRing;
  };
  var ordConst = function (dictOrd) {
      return dictOrd;
  };
  var newtypeConst = new Data_Newtype.Newtype(function (n) {
      return n;
  }, Const);
  var monoidConst = function (dictMonoid) {
      return dictMonoid;
  };
  var heytingAlgebraConst = function (dictHeytingAlgebra) {
      return dictHeytingAlgebra;
  };
  var functorConst = new Data_Functor.Functor(function (v) {
      return function (v1) {
          return v1;
      };
  });
  var invariantConst = new Data_Functor_Invariant.Invariant(Data_Functor_Invariant.imapF(functorConst));
  var foldableConst = new Data_Foldable.Foldable(function (dictMonoid) {
      return function (v) {
          return function (v1) {
              return Data_Monoid.mempty(dictMonoid);
          };
      };
  }, function (v) {
      return function (z) {
          return function (v1) {
              return z;
          };
      };
  }, function (v) {
      return function (z) {
          return function (v1) {
              return z;
          };
      };
  });
  var traversableConst = new Data_Traversable.Traversable(function () {
      return foldableConst;
  }, function () {
      return functorConst;
  }, function (dictApplicative) {
      return function (v) {
          return Control_Applicative.pure(dictApplicative)(v);
      };
  }, function (dictApplicative) {
      return function (v) {
          return function (v1) {
              return Control_Applicative.pure(dictApplicative)(v1);
          };
      };
  });
  var fieldConst = function (dictField) {
      return dictField;
  };
  var euclideanRingConst = function (dictEuclideanRing) {
      return dictEuclideanRing;
  };
  var eqConst = function (dictEq) {
      return dictEq;
  };
  var contravariantConst = new Data_Functor_Contravariant.Contravariant(function (v) {
      return function (v1) {
          return v1;
      };
  });
  var commutativeRingConst = function (dictCommutativeRing) {
      return dictCommutativeRing;
  };
  var boundedConst = function (dictBounded) {
      return dictBounded;
  };
  var booleanAlgebraConst = function (dictBooleanAlgebra) {
      return dictBooleanAlgebra;
  };
  var applyConst = function (dictSemigroup) {
      return new Control_Apply.Apply(function () {
          return functorConst;
      }, function (v) {
          return function (v1) {
              return Data_Semigroup.append(dictSemigroup)(v)(v1);
          };
      });
  };
  var bindConst = function (dictSemigroup) {
      return new Control_Bind.Bind(function () {
          return applyConst(dictSemigroup);
      }, function (v) {
          return function (v1) {
              return v;
          };
      });
  };
  var applicativeConst = function (dictMonoid) {
      return new Control_Applicative.Applicative(function () {
          return applyConst(dictMonoid["__superclass_Data.Semigroup.Semigroup_0"]());
      }, function (v) {
          return Data_Monoid.mempty(dictMonoid);
      });
  };
  exports["Const"] = Const;
  exports["newtypeConst"] = newtypeConst;
  exports["eqConst"] = eqConst;
  exports["ordConst"] = ordConst;
  exports["boundedConst"] = boundedConst;
  exports["showConst"] = showConst;
  exports["semigroupoidConst"] = semigroupoidConst;
  exports["semigroupConst"] = semigroupConst;
  exports["monoidConst"] = monoidConst;
  exports["semiringConst"] = semiringConst;
  exports["ringConst"] = ringConst;
  exports["euclideanRingConst"] = euclideanRingConst;
  exports["commutativeRingConst"] = commutativeRingConst;
  exports["fieldConst"] = fieldConst;
  exports["heytingAlgebraConst"] = heytingAlgebraConst;
  exports["booleanAlgebraConst"] = booleanAlgebraConst;
  exports["functorConst"] = functorConst;
  exports["invariantConst"] = invariantConst;
  exports["contravariantConst"] = contravariantConst;
  exports["applyConst"] = applyConst;
  exports["bindConst"] = bindConst;
  exports["applicativeConst"] = applicativeConst;
  exports["foldableConst"] = foldableConst;
  exports["traversableConst"] = traversableConst;
})(PS["Data.Const"] = PS["Data.Const"] || {});
(function(exports) {
    "use strict";
  var Unsafe_Coerce = PS["Unsafe.Coerce"];        

  /**
 *  | The `runExists` function is used to eliminate a value of type `Exists f`. The rank 2 type ensures
 *  | that the existentially-quantified type does not escape its scope. Since the function is required
 *  | to work for _any_ type `a`, it will work for the existentially-quantified type.
 *  |
 *  | For example, we can write a function to obtain the head of a stream by using `runExists` as follows:
 *  |
 *  | ```purescript
 *  | head :: forall a. Stream a -> a
 *  | head = runExists head'
 *  |   where
 *  |   head' :: forall s. StreamF a s -> a
 *  |   head' (StreamF s f) = snd (f s)
 *  | ```
 */  
  var runExists = Unsafe_Coerce.unsafeCoerce;

  /**
 *  | The `mkExists` function is used to introduce a value of type `Exists f`, by providing a value of
 *  | type `f a`, for some type `a` which will be hidden in the existentially-quantified type.
 *  |
 *  | For example, to create a value of type `Stream Number`, we might use `mkExists` as follows:
 *  |
 *  | ```purescript
 *  | nats :: Stream Number
 *  | nats = mkExists $ StreamF 0 (\n -> Tuple (n + 1) n)
 *  | ```
 */  
  var mkExists = Unsafe_Coerce.unsafeCoerce;
  exports["mkExists"] = mkExists;
  exports["runExists"] = runExists;
})(PS["Data.Exists"] = PS["Data.Exists"] || {});
(function(exports) {
    "use strict";
  var Prelude = PS["Prelude"];
  var Data_Exists = PS["Data.Exists"];
  var Control_Comonad = PS["Control.Comonad"];
  var Control_Extend = PS["Control.Extend"];
  var Control_Monad_Trans_Class = PS["Control.Monad.Trans.Class"];
  var Data_Functor = PS["Data.Functor"];
  var Control_Semigroupoid = PS["Control.Semigroupoid"];
  var Control_Apply = PS["Control.Apply"];
  var Data_Function = PS["Data.Function"];
  var Control_Applicative = PS["Control.Applicative"];
  var Control_Bind = PS["Control.Bind"];
  var Control_Monad = PS["Control.Monad"];
  var Control_Category = PS["Control.Category"];        

  /**
 *  | `Coyoneda` is encoded as an existential type using `Data.Exists`.
 *  |
 *  | This type constructor encodes the contents of the existential package.
 */  
  var CoyonedaF = function (x) {
      return x;
  };

  /**
 *  | The `Coyoneda` `Functor`.
 *  |
 *  | `Coyoneda f` is a `Functor` for any type constructor `f`. In fact,
 *  | it is the _free_ `Functor` for `f`.
 */  
  var Coyoneda = function (x) {
      return x;
  };

  /**
 *  | Lower a value of type `Coyoneda f a` to the `Functor` `f`.
 */  
  var lowerCoyoneda = function (dictFunctor) {
      return function (v) {
          return Data_Exists.runExists(function (v1) {
              return Data_Functor.map(dictFunctor)(v1.k)(v1.fi);
          })(v);
      };
  };

  /**
 *  | Lift a value described by the type constructor `f` to `Coyoneda f`.
 */  
  var liftCoyoneda = function (fa) {
      return Coyoneda(Data_Exists.mkExists({
          k: Control_Category.id(Control_Category.categoryFn), 
          fi: fa
      }));
  };
  var monadTransCoyoneda = new Control_Monad_Trans_Class.MonadTrans(function (dictMonad) {
      return liftCoyoneda;
  });

  /**
 *  | Construct a value of type `Coyoneda f b` from a mapping function and a
 *  | value of type `f a`.
 */  
  var coyoneda = function (k) {
      return function (fi) {
          return Coyoneda(Data_Exists.mkExists({
              k: k, 
              fi: fi
          }));
      };
  };
  var functorCoyoneda = new Data_Functor.Functor(function (f) {
      return function (v) {
          return Data_Exists.runExists(function (v1) {
              return coyoneda(function ($36) {
                  return f(v1.k($36));
              })(v1.fi);
          })(v);
      };
  });
  var extendCoyoneda = function (dictExtend) {
      return new Control_Extend.Extend(function () {
          return functorCoyoneda;
      }, function (f) {
          return function (v) {
              return Data_Exists.runExists(function (v1) {
                  return liftCoyoneda(Control_Extend.extend(dictExtend)(function ($37) {
                      return f(coyoneda(v1.k)($37));
                  })(v1.fi));
              })(v);
          };
      });
  };

  /**
 *  | Use a natural transformation to change the generating type constructor of a
 *  | `Coyoneda`.
 */  
  var hoistCoyoneda = function (nat) {
      return function (v) {
          return Data_Exists.runExists(function (v1) {
              return coyoneda(v1.k)(nat(v1.fi));
          })(v);
      };
  };
  var comonadCoyoneda = function (dictComonad) {
      return new Control_Comonad.Comonad(function () {
          return extendCoyoneda(dictComonad["__superclass_Control.Extend.Extend_0"]());
      }, function (v) {
          return Data_Exists.runExists(function (v1) {
              return v1.k(Control_Comonad.extract(dictComonad)(v1.fi));
          })(v);
      });
  };
  var applyCoyoneda = function (dictApply) {
      return new Control_Apply.Apply(function () {
          return functorCoyoneda;
      }, function (f) {
          return function (g) {
              return liftCoyoneda(Control_Apply.apply(dictApply)(lowerCoyoneda(dictApply["__superclass_Data.Functor.Functor_0"]())(f))(lowerCoyoneda(dictApply["__superclass_Data.Functor.Functor_0"]())(g)));
          };
      });
  };
  var bindCoyoneda = function (dictBind) {
      return new Control_Bind.Bind(function () {
          return applyCoyoneda(dictBind["__superclass_Control.Apply.Apply_0"]());
      }, function (v) {
          return function (k) {
              return liftCoyoneda(Data_Exists.runExists(function (v1) {
                  return Control_Bind.bind(dictBind)(v1.fi)(function ($38) {
                      return lowerCoyoneda((dictBind["__superclass_Control.Apply.Apply_0"]())["__superclass_Data.Functor.Functor_0"]())(k(v1.k($38)));
                  });
              })(v));
          };
      });
  };
  var applicativeCoyoneda = function (dictApplicative) {
      return new Control_Applicative.Applicative(function () {
          return applyCoyoneda(dictApplicative["__superclass_Control.Apply.Apply_0"]());
      }, function ($39) {
          return liftCoyoneda(Control_Applicative.pure(dictApplicative)($39));
      });
  };
  var monadCoyoneda = function (dictMonad) {
      return new Control_Monad.Monad(function () {
          return applicativeCoyoneda(dictMonad["__superclass_Control.Applicative.Applicative_0"]());
      }, function () {
          return bindCoyoneda(dictMonad["__superclass_Control.Bind.Bind_1"]());
      });
  };
  exports["Coyoneda"] = Coyoneda;
  exports["coyoneda"] = coyoneda;
  exports["hoistCoyoneda"] = hoistCoyoneda;
  exports["liftCoyoneda"] = liftCoyoneda;
  exports["lowerCoyoneda"] = lowerCoyoneda;
  exports["functorCoyoneda"] = functorCoyoneda;
  exports["applyCoyoneda"] = applyCoyoneda;
  exports["applicativeCoyoneda"] = applicativeCoyoneda;
  exports["bindCoyoneda"] = bindCoyoneda;
  exports["monadCoyoneda"] = monadCoyoneda;
  exports["monadTransCoyoneda"] = monadTransCoyoneda;
  exports["extendCoyoneda"] = extendCoyoneda;
  exports["comonadCoyoneda"] = comonadCoyoneda;
})(PS["Data.Coyoneda"] = PS["Data.Coyoneda"] || {});
(function(exports) {
    "use strict";
  var Prelude = PS["Prelude"];
  var Data_Comparison = PS["Data.Comparison"];
  var Data_Function = PS["Data.Function"];
  var Data_Functor_Contravariant = PS["Data.Functor.Contravariant"];
  var Data_Monoid = PS["Data.Monoid"];
  var Data_Newtype = PS["Data.Newtype"];
  var Data_Semigroup = PS["Data.Semigroup"];
  var Data_HeytingAlgebra = PS["Data.HeytingAlgebra"];
  var Data_Eq = PS["Data.Eq"];
  var Data_Ordering = PS["Data.Ordering"];        

  /**
 *  | An adaptor allowing `>$<` to map over the inputs of an equivalence
 *  | relation.
 */  
  var Equivalence = function (x) {
      return x;
  };
  var semigroupEquivalence = new Data_Semigroup.Semigroup(function (v) {
      return function (v1) {
          return function (a) {
              return function (b) {
                  return v(a)(b) && v1(a)(b);
              };
          };
      };
  });
  var newtypeEquivalence = new Data_Newtype.Newtype(function (n) {
      return n;
  }, Equivalence);
  var monoidEquivalence = new Data_Monoid.Monoid(function () {
      return semigroupEquivalence;
  }, function (v) {
      return function (v1) {
          return true;
      };
  });

  /**
 *  | The default equivalence relation for any values with an `Eq` instance.
 */  
  var defaultEquivalence = function (dictEq) {
      return Data_Eq.eq(dictEq);
  };
  var contravariantEquivalence = new Data_Functor_Contravariant.Contravariant(function (f) {
      return function (v) {
          return Data_Function.on(v)(f);
      };
  });

  /**
 *  | An equivalence relation for any `Comparison`.
 */  
  var comparisonEquivalence = function (v) {
      return function (a) {
          return function (b) {
              return Data_Eq.eq(Data_Ordering.eqOrdering)(v(a)(b))(Data_Ordering.EQ.value);
          };
      };
  };
  exports["Equivalence"] = Equivalence;
  exports["comparisonEquivalence"] = comparisonEquivalence;
  exports["defaultEquivalence"] = defaultEquivalence;
  exports["newtypeEquivalence"] = newtypeEquivalence;
  exports["contravariantEquivalence"] = contravariantEquivalence;
  exports["semigroupEquivalence"] = semigroupEquivalence;
  exports["monoidEquivalence"] = monoidEquivalence;
})(PS["Data.Equivalence"] = PS["Data.Equivalence"] || {});
(function(exports) {
    "use strict";
  var Prelude = PS["Prelude"];
  var Data_Functor_Contravariant = PS["Data.Functor.Contravariant"];
  var Data_Newtype = PS["Data.Newtype"];
  var Control_Semigroupoid = PS["Control.Semigroupoid"];
  var Control_Category = PS["Control.Category"];        

  /**
 *  | The opposite of the function category.
 */  
  var Op = function (x) {
      return x;
  };
  var semigroupoidOp = new Control_Semigroupoid.Semigroupoid(function (v) {
      return function (v1) {
          return function ($10) {
              return v1(v($10));
          };
      };
  });
  var newtypeOp = new Data_Newtype.Newtype(function (n) {
      return n;
  }, Op);
  var contravariantOp = new Data_Functor_Contravariant.Contravariant(function (f) {
      return function (v) {
          return function ($11) {
              return v(f($11));
          };
      };
  });
  var categoryOp = new Control_Category.Category(function () {
      return semigroupoidOp;
  }, Control_Category.id(Control_Category.categoryFn));
  exports["Op"] = Op;
  exports["newtypeOp"] = newtypeOp;
  exports["semigroupoidOp"] = semigroupoidOp;
  exports["categoryOp"] = categoryOp;
  exports["contravariantOp"] = contravariantOp;
})(PS["Data.Op"] = PS["Data.Op"] || {});
(function(exports) {
    "use strict";
  var Prelude = PS["Prelude"];
  var Data_Functor_Contravariant = PS["Data.Functor.Contravariant"];
  var Data_Newtype = PS["Data.Newtype"];
  var Control_Semigroupoid = PS["Control.Semigroupoid"];        

  /**
 *  | An adaptor allowing `>$<` to map over the inputs of a predicate.
 */  
  var Predicate = function (x) {
      return x;
  };
  var newtypePredicate = new Data_Newtype.Newtype(function (n) {
      return n;
  }, Predicate);
  var contravariantPredicate = new Data_Functor_Contravariant.Contravariant(function (f) {
      return function (v) {
          return function ($6) {
              return v(f($6));
          };
      };
  });
  exports["Predicate"] = Predicate;
  exports["newtypePredicate"] = newtypePredicate;
  exports["contravariantPredicate"] = contravariantPredicate;
})(PS["Data.Predicate"] = PS["Data.Predicate"] || {});
(function(exports) {
    "use strict";
  var Prelude = PS["Prelude"];
  var Data_Comparison = PS["Data.Comparison"];
  var Data_Equivalence = PS["Data.Equivalence"];
  var Data_Functor_Contravariant = PS["Data.Functor.Contravariant"];
  var Data_Op = PS["Data.Op"];
  var Data_Predicate = PS["Data.Predicate"];
  var Data_Tuple = PS["Data.Tuple"];
  var Data_Semigroup = PS["Data.Semigroup"];
  var Data_HeytingAlgebra = PS["Data.HeytingAlgebra"];
  var Data_Ordering = PS["Data.Ordering"];
  var Control_Category = PS["Control.Category"];        

  /**
 *  | `Divide` is the contravariant analogue of `Apply`.
 *  |
 *  | For example, to test equality of `Point`s, we can use the `Divide` instance
 *  | for `Equivalence`:
 *  |
 *  | ```purescript
 *  | type Point = Tuple Int Int
 *  |
 *  | pointEquiv :: Equivalence Point
 *  | pointEquiv = divided defaultEquivalence defaultEquivalence
 *  | ```
 */  
  var Divide = function (__superclass_Data$dotFunctor$dotContravariant$dotContravariant_0, divide) {
      this["__superclass_Data.Functor.Contravariant.Contravariant_0"] = __superclass_Data$dotFunctor$dotContravariant$dotContravariant_0;
      this.divide = divide;
  };
  var dividePredicate = new Divide(function () {
      return Data_Predicate.contravariantPredicate;
  }, function (f) {
      return function (v) {
          return function (v1) {
              return function (a) {
                  var $13 = f(a);
                  return v($13.value0) && v1($13.value1);
              };
          };
      };
  });
  var divideOp = function (dictSemigroup) {
      return new Divide(function () {
          return Data_Op.contravariantOp;
      }, function (f) {
          return function (v) {
              return function (v1) {
                  return function (a) {
                      var $19 = f(a);
                      return Data_Semigroup.append(dictSemigroup)(v($19.value0))(v1($19.value1));
                  };
              };
          };
      });
  };
  var divideEquivalence = new Divide(function () {
      return Data_Equivalence.contravariantEquivalence;
  }, function (f) {
      return function (v) {
          return function (v1) {
              return function (a) {
                  return function (b) {
                      var $25 = f(a);
                      var $26 = f(b);
                      return v($25.value0)($26.value0) && v1($25.value1)($26.value1);
                  };
              };
          };
      };
  });
  var divideComparison = new Divide(function () {
      return Data_Comparison.contravariantComparison;
  }, function (f) {
      return function (v) {
          return function (v1) {
              return function (a) {
                  return function (b) {
                      var $34 = f(a);
                      var $35 = f(b);
                      return Data_Semigroup.append(Data_Ordering.semigroupOrdering)(v($34.value0)($35.value0))(v1($34.value1)($35.value1));
                  };
              };
          };
      };
  });

  /**
 *  | `Divide` is the contravariant analogue of `Apply`.
 *  |
 *  | For example, to test equality of `Point`s, we can use the `Divide` instance
 *  | for `Equivalence`:
 *  |
 *  | ```purescript
 *  | type Point = Tuple Int Int
 *  |
 *  | pointEquiv :: Equivalence Point
 *  | pointEquiv = divided defaultEquivalence defaultEquivalence
 *  | ```
 */  
  var divide = function (dict) {
      return dict.divide;
  };

  /**
 *  | `divided = divide id`
 */  
  var divided = function (dictDivide) {
      return divide(dictDivide)(Control_Category.id(Control_Category.categoryFn));
  };
  exports["Divide"] = Divide;
  exports["divide"] = divide;
  exports["divided"] = divided;
  exports["divideComparison"] = divideComparison;
  exports["divideEquivalence"] = divideEquivalence;
  exports["dividePredicate"] = dividePredicate;
  exports["divideOp"] = divideOp;
})(PS["Data.Divide"] = PS["Data.Divide"] || {});
(function(exports) {
    "use strict";
  var Prelude = PS["Prelude"];
  var Data_Comparison = PS["Data.Comparison"];
  var Data_Divide = PS["Data.Divide"];
  var Data_Either = PS["Data.Either"];
  var Data_Equivalence = PS["Data.Equivalence"];
  var Data_Op = PS["Data.Op"];
  var Data_Predicate = PS["Data.Predicate"];
  var Data_Ordering = PS["Data.Ordering"];
  var Control_Semigroupoid = PS["Control.Semigroupoid"];
  var Control_Category = PS["Control.Category"];        

  /**
 *  | `Decide` is the contravariant analogue of `Alt`.
 */  
  var Decide = function (__superclass_Data$dotDivide$dotDivide_0, choose) {
      this["__superclass_Data.Divide.Divide_0"] = __superclass_Data$dotDivide$dotDivide_0;
      this.choose = choose;
  };
  var choosePredicate = new Decide(function () {
      return Data_Divide.dividePredicate;
  }, function (f) {
      return function (v) {
          return function (v1) {
              return function ($40) {
                  return Data_Either.either(v)(v1)(f($40));
              };
          };
      };
  });
  var chooseOp = function (dictSemigroup) {
      return new Decide(function () {
          return Data_Divide.divideOp(dictSemigroup);
      }, function (f) {
          return function (v) {
              return function (v1) {
                  return function ($41) {
                      return Data_Either.either(v)(v1)(f($41));
                  };
              };
          };
      });
  };
  var chooseEquivalence = new Decide(function () {
      return Data_Divide.divideEquivalence;
  }, function (f) {
      return function (v) {
          return function (v1) {
              return function (a) {
                  return function (b) {
                      var $19 = f(a);
                      if ($19 instanceof Data_Either.Left) {
                          var $20 = f(b);
                          if ($20 instanceof Data_Either.Left) {
                              return v($19.value0)($20.value0);
                          };
                          if ($20 instanceof Data_Either.Right) {
                              return false;
                          };
                          throw new Error("Failed pattern match at Data.Decide line 27, column 15 - line 29, column 23: " + [ $20.constructor.name ]);
                      };
                      if ($19 instanceof Data_Either.Right) {
                          var $24 = f(b);
                          if ($24 instanceof Data_Either.Left) {
                              return false;
                          };
                          if ($24 instanceof Data_Either.Right) {
                              return v1($19.value0)($24.value0);
                          };
                          throw new Error("Failed pattern match at Data.Decide line 30, column 16 - line 32, column 23: " + [ $24.constructor.name ]);
                      };
                      throw new Error("Failed pattern match at Data.Decide line 26, column 66 - line 32, column 23: " + [ $19.constructor.name ]);
                  };
              };
          };
      };
  });
  var chooseComparison = new Decide(function () {
      return Data_Divide.divideComparison;
  }, function (f) {
      return function (v) {
          return function (v1) {
              return function (a) {
                  return function (b) {
                      var $31 = f(a);
                      if ($31 instanceof Data_Either.Left) {
                          var $32 = f(b);
                          if ($32 instanceof Data_Either.Left) {
                              return v($31.value0)($32.value0);
                          };
                          if ($32 instanceof Data_Either.Right) {
                              return Data_Ordering.LT.value;
                          };
                          throw new Error("Failed pattern match at Data.Decide line 18, column 15 - line 20, column 20: " + [ $32.constructor.name ]);
                      };
                      if ($31 instanceof Data_Either.Right) {
                          var $36 = f(b);
                          if ($36 instanceof Data_Either.Left) {
                              return Data_Ordering.GT.value;
                          };
                          if ($36 instanceof Data_Either.Right) {
                              return v1($31.value0)($36.value0);
                          };
                          throw new Error("Failed pattern match at Data.Decide line 21, column 16 - line 23, column 23: " + [ $36.constructor.name ]);
                      };
                      throw new Error("Failed pattern match at Data.Decide line 17, column 63 - line 23, column 23: " + [ $31.constructor.name ]);
                  };
              };
          };
      };
  });

  /**
 *  | `Decide` is the contravariant analogue of `Alt`.
 */  
  var choose = function (dict) {
      return dict.choose;
  };

  /**
 *  | `chosen = choose id`
 */  
  var chosen = function (dictDecide) {
      return choose(dictDecide)(Control_Category.id(Control_Category.categoryFn));
  };
  exports["Decide"] = Decide;
  exports["choose"] = choose;
  exports["chosen"] = chosen;
  exports["chooseComparison"] = chooseComparison;
  exports["chooseEquivalence"] = chooseEquivalence;
  exports["choosePredicate"] = choosePredicate;
  exports["chooseOp"] = chooseOp;
})(PS["Data.Decide"] = PS["Data.Decide"] || {});
(function(exports) {
    "use strict";
  var Prelude = PS["Prelude"];
  var Data_Comparison = PS["Data.Comparison"];
  var Data_Divide = PS["Data.Divide"];
  var Data_Equivalence = PS["Data.Equivalence"];
  var Data_Monoid = PS["Data.Monoid"];
  var Data_Op = PS["Data.Op"];
  var Data_Predicate = PS["Data.Predicate"];
  var Data_Function = PS["Data.Function"];
  var Data_Ordering = PS["Data.Ordering"];        

  /**
 *  | `Divisible` is the contravariant analogue of `Applicative`.
 */  
  var Divisible = function (__superclass_Data$dotDivide$dotDivide_0, conquer) {
      this["__superclass_Data.Divide.Divide_0"] = __superclass_Data$dotDivide$dotDivide_0;
      this.conquer = conquer;
  };
  var divisiblePredicate = new Divisible(function () {
      return Data_Divide.dividePredicate;
  }, Data_Function["const"](true));
  var divisibleOp = function (dictMonoid) {
      return new Divisible(function () {
          return Data_Divide.divideOp(dictMonoid["__superclass_Data.Semigroup.Semigroup_0"]());
      }, Data_Op.Op(Data_Function["const"](Data_Monoid.mempty(dictMonoid))));
  };
  var divisibleEquivalence = new Divisible(function () {
      return Data_Divide.divideEquivalence;
  }, Data_Equivalence.Equivalence(function (v) {
      return function (v1) {
          return true;
      };
  }));
  var divisibleComparison = new Divisible(function () {
      return Data_Divide.divideComparison;
  }, Data_Comparison.Comparison(function (v) {
      return function (v1) {
          return Data_Ordering.EQ.value;
      };
  }));

  /**
 *  | `Divisible` is the contravariant analogue of `Applicative`.
 */  
  var conquer = function (dict) {
      return dict.conquer;
  };
  exports["Divisible"] = Divisible;
  exports["conquer"] = conquer;
  exports["divisibleComparison"] = divisibleComparison;
  exports["divisibleEquivalence"] = divisibleEquivalence;
  exports["divisiblePredicate"] = divisiblePredicate;
  exports["divisibleOp"] = divisibleOp;
})(PS["Data.Divisible"] = PS["Data.Divisible"] || {});
(function(exports) {
    "use strict";
  var Prelude = PS["Prelude"];
  var Data_Comparison = PS["Data.Comparison"];
  var Data_Decide = PS["Data.Decide"];
  var Data_Divisible = PS["Data.Divisible"];
  var Data_Equivalence = PS["Data.Equivalence"];
  var Data_Monoid = PS["Data.Monoid"];
  var Data_Op = PS["Data.Op"];
  var Data_Predicate = PS["Data.Predicate"];
  var Data_Void = PS["Data.Void"];
  var Control_Category = PS["Control.Category"];        

  /**
 *  | `Decidable` is the contravariant analogue of `Alternative`.
 */  
  var Decidable = function (__superclass_Data$dotDecide$dotDecide_0, __superclass_Data$dotDivisible$dotDivisible_1, lose) {
      this["__superclass_Data.Decide.Decide_0"] = __superclass_Data$dotDecide$dotDecide_0;
      this["__superclass_Data.Divisible.Divisible_1"] = __superclass_Data$dotDivisible$dotDivisible_1;
      this.lose = lose;
  };

  /**
 *  | `Decidable` is the contravariant analogue of `Alternative`.
 */  
  var lose = function (dict) {
      return dict.lose;
  };
  var lost = function (dictDecidable) {
      return lose(dictDecidable)(Control_Category.id(Control_Category.categoryFn));
  };
  var decidablePredicate = new Decidable(function () {
      return Data_Decide.choosePredicate;
  }, function () {
      return Data_Divisible.divisiblePredicate;
  }, function (f) {
      return function (a) {
          return Data_Void.absurd(f(a));
      };
  });
  var decidableOp = function (dictMonoid) {
      return new Decidable(function () {
          return Data_Decide.chooseOp(dictMonoid["__superclass_Data.Semigroup.Semigroup_0"]());
      }, function () {
          return Data_Divisible.divisibleOp(dictMonoid);
      }, function (f) {
          return function (a) {
              return Data_Void.absurd(f(a));
          };
      });
  };
  var decidableEquivalence = new Decidable(function () {
      return Data_Decide.chooseEquivalence;
  }, function () {
      return Data_Divisible.divisibleEquivalence;
  }, function (f) {
      return function (a) {
          return Data_Void.absurd(f(a));
      };
  });
  var decidableComparison = new Decidable(function () {
      return Data_Decide.chooseComparison;
  }, function () {
      return Data_Divisible.divisibleComparison;
  }, function (f) {
      return function (a) {
          return function (v) {
              return Data_Void.absurd(f(a));
          };
      };
  });
  exports["Decidable"] = Decidable;
  exports["lose"] = lose;
  exports["lost"] = lost;
  exports["decidableComparison"] = decidableComparison;
  exports["decidableEquivalence"] = decidableEquivalence;
  exports["decidablePredicate"] = decidablePredicate;
  exports["decidableOp"] = decidableOp;
})(PS["Data.Decidable"] = PS["Data.Decidable"] || {});
(function(exports) {
  
  /**
 *  | Utilities for n-eithers: sums types with more than two terms built from nested eithers.
 *  |
 *  | Nested eithers arise naturally in sum combinators. You shouldn't
 *  | represent sum data using nested eithers, but if combinators you're working with
 *  | create them, utilities in this module will allow to to more easily work
 *  | with them, including translating to and from more traditional sum types.
 *  |
 *  | ```purescript
 *  | data Color = Red Number | Green Number | Blue Number
 *  |
 *  | toEither3 :: Either3 Number Number Number -> Color
 *  | toEither3 = either3 Red Green Blue
 *  |
 *  | fromEither3 :: Color -> Either3 Number Number Number
 *  | fromEither3 (Red   v) = in1 v
 *  | fromEither3 (Green v) = in2 v
 *  | fromEither3 (Blue  v) = in3 v
 *  | ```
 */  
  "use strict";
  var Data_Either = PS["Data.Either"];
  var Data_Void = PS["Data.Void"];        
  var in9 = function (v) {
      return new Data_Either.Right(new Data_Either.Right(new Data_Either.Right(new Data_Either.Right(new Data_Either.Right(new Data_Either.Right(new Data_Either.Right(new Data_Either.Right(new Data_Either.Left(v)))))))));
  };
  var in8 = function (v) {
      return new Data_Either.Right(new Data_Either.Right(new Data_Either.Right(new Data_Either.Right(new Data_Either.Right(new Data_Either.Right(new Data_Either.Right(new Data_Either.Left(v))))))));
  };
  var in7 = function (v) {
      return new Data_Either.Right(new Data_Either.Right(new Data_Either.Right(new Data_Either.Right(new Data_Either.Right(new Data_Either.Right(new Data_Either.Left(v)))))));
  };
  var in6 = function (v) {
      return new Data_Either.Right(new Data_Either.Right(new Data_Either.Right(new Data_Either.Right(new Data_Either.Right(new Data_Either.Left(v))))));
  };
  var in5 = function (v) {
      return new Data_Either.Right(new Data_Either.Right(new Data_Either.Right(new Data_Either.Right(new Data_Either.Left(v)))));
  };
  var in4 = function (v) {
      return new Data_Either.Right(new Data_Either.Right(new Data_Either.Right(new Data_Either.Left(v))));
  };
  var in3 = function (v) {
      return new Data_Either.Right(new Data_Either.Right(new Data_Either.Left(v)));
  };
  var in2 = function (v) {
      return new Data_Either.Right(new Data_Either.Left(v));
  };
  var in10 = function (v) {
      return new Data_Either.Right(new Data_Either.Right(new Data_Either.Right(new Data_Either.Right(new Data_Either.Right(new Data_Either.Right(new Data_Either.Right(new Data_Either.Right(new Data_Either.Right(new Data_Either.Left(v))))))))));
  };
  var in1 = Data_Either.Left.create;
  var either9 = function (a) {
      return function (b) {
          return function (c) {
              return function (d) {
                  return function (e) {
                      return function (f) {
                          return function (g) {
                              return function (h) {
                                  return function (i) {
                                      return function (y) {
                                          if (y instanceof Data_Either.Left) {
                                              return a(y.value0);
                                          };
                                          if (y instanceof Data_Either.Right) {
                                              if (y.value0 instanceof Data_Either.Left) {
                                                  return b(y.value0.value0);
                                              };
                                              if (y.value0 instanceof Data_Either.Right) {
                                                  if (y.value0.value0 instanceof Data_Either.Left) {
                                                      return c(y.value0.value0.value0);
                                                  };
                                                  if (y.value0.value0 instanceof Data_Either.Right) {
                                                      if (y.value0.value0.value0 instanceof Data_Either.Left) {
                                                          return d(y.value0.value0.value0.value0);
                                                      };
                                                      if (y.value0.value0.value0 instanceof Data_Either.Right) {
                                                          if (y.value0.value0.value0.value0 instanceof Data_Either.Left) {
                                                              return e(y.value0.value0.value0.value0.value0);
                                                          };
                                                          if (y.value0.value0.value0.value0 instanceof Data_Either.Right) {
                                                              if (y.value0.value0.value0.value0.value0 instanceof Data_Either.Left) {
                                                                  return f(y.value0.value0.value0.value0.value0.value0);
                                                              };
                                                              if (y.value0.value0.value0.value0.value0 instanceof Data_Either.Right) {
                                                                  if (y.value0.value0.value0.value0.value0.value0 instanceof Data_Either.Left) {
                                                                      return g(y.value0.value0.value0.value0.value0.value0.value0);
                                                                  };
                                                                  if (y.value0.value0.value0.value0.value0.value0 instanceof Data_Either.Right) {
                                                                      if (y.value0.value0.value0.value0.value0.value0.value0 instanceof Data_Either.Left) {
                                                                          return h(y.value0.value0.value0.value0.value0.value0.value0.value0);
                                                                      };
                                                                      if (y.value0.value0.value0.value0.value0.value0.value0 instanceof Data_Either.Right) {
                                                                          if (y.value0.value0.value0.value0.value0.value0.value0.value0 instanceof Data_Either.Left) {
                                                                              return i(y.value0.value0.value0.value0.value0.value0.value0.value0.value0);
                                                                          };
                                                                          if (y.value0.value0.value0.value0.value0.value0.value0.value0 instanceof Data_Either.Right) {
                                                                              return Data_Void.absurd(y.value0.value0.value0.value0.value0.value0.value0.value0.value0);
                                                                          };
                                                                          throw new Error("Failed pattern match at Data.Either.Nested line 245, column 29 - line 247, column 40: " + [ y.value0.value0.value0.value0.value0.value0.value0.value0.constructor.name ]);
                                                                      };
                                                                      throw new Error("Failed pattern match at Data.Either.Nested line 243, column 27 - line 247, column 40: " + [ y.value0.value0.value0.value0.value0.value0.value0.constructor.name ]);
                                                                  };
                                                                  throw new Error("Failed pattern match at Data.Either.Nested line 241, column 25 - line 247, column 40: " + [ y.value0.value0.value0.value0.value0.value0.constructor.name ]);
                                                              };
                                                              throw new Error("Failed pattern match at Data.Either.Nested line 239, column 23 - line 247, column 40: " + [ y.value0.value0.value0.value0.value0.constructor.name ]);
                                                          };
                                                          throw new Error("Failed pattern match at Data.Either.Nested line 237, column 21 - line 247, column 40: " + [ y.value0.value0.value0.value0.constructor.name ]);
                                                      };
                                                      throw new Error("Failed pattern match at Data.Either.Nested line 235, column 19 - line 247, column 40: " + [ y.value0.value0.value0.constructor.name ]);
                                                  };
                                                  throw new Error("Failed pattern match at Data.Either.Nested line 233, column 17 - line 247, column 40: " + [ y.value0.value0.constructor.name ]);
                                              };
                                              throw new Error("Failed pattern match at Data.Either.Nested line 231, column 15 - line 247, column 40: " + [ y.value0.constructor.name ]);
                                          };
                                          throw new Error("Failed pattern match at Data.Either.Nested line 229, column 31 - line 247, column 40: " + [ y.constructor.name ]);
                                      };
                                  };
                              };
                          };
                      };
                  };
              };
          };
      };
  };
  var either8 = function (a) {
      return function (b) {
          return function (c) {
              return function (d) {
                  return function (e) {
                      return function (f) {
                          return function (g) {
                              return function (h) {
                                  return function (y) {
                                      if (y instanceof Data_Either.Left) {
                                          return a(y.value0);
                                      };
                                      if (y instanceof Data_Either.Right) {
                                          if (y.value0 instanceof Data_Either.Left) {
                                              return b(y.value0.value0);
                                          };
                                          if (y.value0 instanceof Data_Either.Right) {
                                              if (y.value0.value0 instanceof Data_Either.Left) {
                                                  return c(y.value0.value0.value0);
                                              };
                                              if (y.value0.value0 instanceof Data_Either.Right) {
                                                  if (y.value0.value0.value0 instanceof Data_Either.Left) {
                                                      return d(y.value0.value0.value0.value0);
                                                  };
                                                  if (y.value0.value0.value0 instanceof Data_Either.Right) {
                                                      if (y.value0.value0.value0.value0 instanceof Data_Either.Left) {
                                                          return e(y.value0.value0.value0.value0.value0);
                                                      };
                                                      if (y.value0.value0.value0.value0 instanceof Data_Either.Right) {
                                                          if (y.value0.value0.value0.value0.value0 instanceof Data_Either.Left) {
                                                              return f(y.value0.value0.value0.value0.value0.value0);
                                                          };
                                                          if (y.value0.value0.value0.value0.value0 instanceof Data_Either.Right) {
                                                              if (y.value0.value0.value0.value0.value0.value0 instanceof Data_Either.Left) {
                                                                  return g(y.value0.value0.value0.value0.value0.value0.value0);
                                                              };
                                                              if (y.value0.value0.value0.value0.value0.value0 instanceof Data_Either.Right) {
                                                                  if (y.value0.value0.value0.value0.value0.value0.value0 instanceof Data_Either.Left) {
                                                                      return h(y.value0.value0.value0.value0.value0.value0.value0.value0);
                                                                  };
                                                                  if (y.value0.value0.value0.value0.value0.value0.value0 instanceof Data_Either.Right) {
                                                                      return Data_Void.absurd(y.value0.value0.value0.value0.value0.value0.value0.value0);
                                                                  };
                                                                  throw new Error("Failed pattern match at Data.Either.Nested line 224, column 27 - line 226, column 38: " + [ y.value0.value0.value0.value0.value0.value0.value0.constructor.name ]);
                                                              };
                                                              throw new Error("Failed pattern match at Data.Either.Nested line 222, column 25 - line 226, column 38: " + [ y.value0.value0.value0.value0.value0.value0.constructor.name ]);
                                                          };
                                                          throw new Error("Failed pattern match at Data.Either.Nested line 220, column 23 - line 226, column 38: " + [ y.value0.value0.value0.value0.value0.constructor.name ]);
                                                      };
                                                      throw new Error("Failed pattern match at Data.Either.Nested line 218, column 21 - line 226, column 38: " + [ y.value0.value0.value0.value0.constructor.name ]);
                                                  };
                                                  throw new Error("Failed pattern match at Data.Either.Nested line 216, column 19 - line 226, column 38: " + [ y.value0.value0.value0.constructor.name ]);
                                              };
                                              throw new Error("Failed pattern match at Data.Either.Nested line 214, column 17 - line 226, column 38: " + [ y.value0.value0.constructor.name ]);
                                          };
                                          throw new Error("Failed pattern match at Data.Either.Nested line 212, column 15 - line 226, column 38: " + [ y.value0.constructor.name ]);
                                      };
                                      throw new Error("Failed pattern match at Data.Either.Nested line 210, column 29 - line 226, column 38: " + [ y.constructor.name ]);
                                  };
                              };
                          };
                      };
                  };
              };
          };
      };
  };
  var either7 = function (a) {
      return function (b) {
          return function (c) {
              return function (d) {
                  return function (e) {
                      return function (f) {
                          return function (g) {
                              return function (y) {
                                  if (y instanceof Data_Either.Left) {
                                      return a(y.value0);
                                  };
                                  if (y instanceof Data_Either.Right) {
                                      if (y.value0 instanceof Data_Either.Left) {
                                          return b(y.value0.value0);
                                      };
                                      if (y.value0 instanceof Data_Either.Right) {
                                          if (y.value0.value0 instanceof Data_Either.Left) {
                                              return c(y.value0.value0.value0);
                                          };
                                          if (y.value0.value0 instanceof Data_Either.Right) {
                                              if (y.value0.value0.value0 instanceof Data_Either.Left) {
                                                  return d(y.value0.value0.value0.value0);
                                              };
                                              if (y.value0.value0.value0 instanceof Data_Either.Right) {
                                                  if (y.value0.value0.value0.value0 instanceof Data_Either.Left) {
                                                      return e(y.value0.value0.value0.value0.value0);
                                                  };
                                                  if (y.value0.value0.value0.value0 instanceof Data_Either.Right) {
                                                      if (y.value0.value0.value0.value0.value0 instanceof Data_Either.Left) {
                                                          return f(y.value0.value0.value0.value0.value0.value0);
                                                      };
                                                      if (y.value0.value0.value0.value0.value0 instanceof Data_Either.Right) {
                                                          if (y.value0.value0.value0.value0.value0.value0 instanceof Data_Either.Left) {
                                                              return g(y.value0.value0.value0.value0.value0.value0.value0);
                                                          };
                                                          if (y.value0.value0.value0.value0.value0.value0 instanceof Data_Either.Right) {
                                                              return Data_Void.absurd(y.value0.value0.value0.value0.value0.value0.value0);
                                                          };
                                                          throw new Error("Failed pattern match at Data.Either.Nested line 205, column 25 - line 207, column 36: " + [ y.value0.value0.value0.value0.value0.value0.constructor.name ]);
                                                      };
                                                      throw new Error("Failed pattern match at Data.Either.Nested line 203, column 23 - line 207, column 36: " + [ y.value0.value0.value0.value0.value0.constructor.name ]);
                                                  };
                                                  throw new Error("Failed pattern match at Data.Either.Nested line 201, column 21 - line 207, column 36: " + [ y.value0.value0.value0.value0.constructor.name ]);
                                              };
                                              throw new Error("Failed pattern match at Data.Either.Nested line 199, column 19 - line 207, column 36: " + [ y.value0.value0.value0.constructor.name ]);
                                          };
                                          throw new Error("Failed pattern match at Data.Either.Nested line 197, column 17 - line 207, column 36: " + [ y.value0.value0.constructor.name ]);
                                      };
                                      throw new Error("Failed pattern match at Data.Either.Nested line 195, column 15 - line 207, column 36: " + [ y.value0.constructor.name ]);
                                  };
                                  throw new Error("Failed pattern match at Data.Either.Nested line 193, column 27 - line 207, column 36: " + [ y.constructor.name ]);
                              };
                          };
                      };
                  };
              };
          };
      };
  };
  var either6 = function (a) {
      return function (b) {
          return function (c) {
              return function (d) {
                  return function (e) {
                      return function (f) {
                          return function (y) {
                              if (y instanceof Data_Either.Left) {
                                  return a(y.value0);
                              };
                              if (y instanceof Data_Either.Right) {
                                  if (y.value0 instanceof Data_Either.Left) {
                                      return b(y.value0.value0);
                                  };
                                  if (y.value0 instanceof Data_Either.Right) {
                                      if (y.value0.value0 instanceof Data_Either.Left) {
                                          return c(y.value0.value0.value0);
                                      };
                                      if (y.value0.value0 instanceof Data_Either.Right) {
                                          if (y.value0.value0.value0 instanceof Data_Either.Left) {
                                              return d(y.value0.value0.value0.value0);
                                          };
                                          if (y.value0.value0.value0 instanceof Data_Either.Right) {
                                              if (y.value0.value0.value0.value0 instanceof Data_Either.Left) {
                                                  return e(y.value0.value0.value0.value0.value0);
                                              };
                                              if (y.value0.value0.value0.value0 instanceof Data_Either.Right) {
                                                  if (y.value0.value0.value0.value0.value0 instanceof Data_Either.Left) {
                                                      return f(y.value0.value0.value0.value0.value0.value0);
                                                  };
                                                  if (y.value0.value0.value0.value0.value0 instanceof Data_Either.Right) {
                                                      return Data_Void.absurd(y.value0.value0.value0.value0.value0.value0);
                                                  };
                                                  throw new Error("Failed pattern match at Data.Either.Nested line 188, column 23 - line 190, column 34: " + [ y.value0.value0.value0.value0.value0.constructor.name ]);
                                              };
                                              throw new Error("Failed pattern match at Data.Either.Nested line 186, column 21 - line 190, column 34: " + [ y.value0.value0.value0.value0.constructor.name ]);
                                          };
                                          throw new Error("Failed pattern match at Data.Either.Nested line 184, column 19 - line 190, column 34: " + [ y.value0.value0.value0.constructor.name ]);
                                      };
                                      throw new Error("Failed pattern match at Data.Either.Nested line 182, column 17 - line 190, column 34: " + [ y.value0.value0.constructor.name ]);
                                  };
                                  throw new Error("Failed pattern match at Data.Either.Nested line 180, column 15 - line 190, column 34: " + [ y.value0.constructor.name ]);
                              };
                              throw new Error("Failed pattern match at Data.Either.Nested line 178, column 25 - line 190, column 34: " + [ y.constructor.name ]);
                          };
                      };
                  };
              };
          };
      };
  };
  var either5 = function (a) {
      return function (b) {
          return function (c) {
              return function (d) {
                  return function (e) {
                      return function (y) {
                          if (y instanceof Data_Either.Left) {
                              return a(y.value0);
                          };
                          if (y instanceof Data_Either.Right) {
                              if (y.value0 instanceof Data_Either.Left) {
                                  return b(y.value0.value0);
                              };
                              if (y.value0 instanceof Data_Either.Right) {
                                  if (y.value0.value0 instanceof Data_Either.Left) {
                                      return c(y.value0.value0.value0);
                                  };
                                  if (y.value0.value0 instanceof Data_Either.Right) {
                                      if (y.value0.value0.value0 instanceof Data_Either.Left) {
                                          return d(y.value0.value0.value0.value0);
                                      };
                                      if (y.value0.value0.value0 instanceof Data_Either.Right) {
                                          if (y.value0.value0.value0.value0 instanceof Data_Either.Left) {
                                              return e(y.value0.value0.value0.value0.value0);
                                          };
                                          if (y.value0.value0.value0.value0 instanceof Data_Either.Right) {
                                              return Data_Void.absurd(y.value0.value0.value0.value0.value0);
                                          };
                                          throw new Error("Failed pattern match at Data.Either.Nested line 173, column 21 - line 175, column 32: " + [ y.value0.value0.value0.value0.constructor.name ]);
                                      };
                                      throw new Error("Failed pattern match at Data.Either.Nested line 171, column 19 - line 175, column 32: " + [ y.value0.value0.value0.constructor.name ]);
                                  };
                                  throw new Error("Failed pattern match at Data.Either.Nested line 169, column 17 - line 175, column 32: " + [ y.value0.value0.constructor.name ]);
                              };
                              throw new Error("Failed pattern match at Data.Either.Nested line 167, column 15 - line 175, column 32: " + [ y.value0.constructor.name ]);
                          };
                          throw new Error("Failed pattern match at Data.Either.Nested line 165, column 23 - line 175, column 32: " + [ y.constructor.name ]);
                      };
                  };
              };
          };
      };
  };
  var either4 = function (a) {
      return function (b) {
          return function (c) {
              return function (d) {
                  return function (y) {
                      if (y instanceof Data_Either.Left) {
                          return a(y.value0);
                      };
                      if (y instanceof Data_Either.Right) {
                          if (y.value0 instanceof Data_Either.Left) {
                              return b(y.value0.value0);
                          };
                          if (y.value0 instanceof Data_Either.Right) {
                              if (y.value0.value0 instanceof Data_Either.Left) {
                                  return c(y.value0.value0.value0);
                              };
                              if (y.value0.value0 instanceof Data_Either.Right) {
                                  if (y.value0.value0.value0 instanceof Data_Either.Left) {
                                      return d(y.value0.value0.value0.value0);
                                  };
                                  if (y.value0.value0.value0 instanceof Data_Either.Right) {
                                      return Data_Void.absurd(y.value0.value0.value0.value0);
                                  };
                                  throw new Error("Failed pattern match at Data.Either.Nested line 160, column 19 - line 162, column 30: " + [ y.value0.value0.value0.constructor.name ]);
                              };
                              throw new Error("Failed pattern match at Data.Either.Nested line 158, column 17 - line 162, column 30: " + [ y.value0.value0.constructor.name ]);
                          };
                          throw new Error("Failed pattern match at Data.Either.Nested line 156, column 15 - line 162, column 30: " + [ y.value0.constructor.name ]);
                      };
                      throw new Error("Failed pattern match at Data.Either.Nested line 154, column 21 - line 162, column 30: " + [ y.constructor.name ]);
                  };
              };
          };
      };
  };
  var either3 = function (a) {
      return function (b) {
          return function (c) {
              return function (y) {
                  if (y instanceof Data_Either.Left) {
                      return a(y.value0);
                  };
                  if (y instanceof Data_Either.Right) {
                      if (y.value0 instanceof Data_Either.Left) {
                          return b(y.value0.value0);
                      };
                      if (y.value0 instanceof Data_Either.Right) {
                          if (y.value0.value0 instanceof Data_Either.Left) {
                              return c(y.value0.value0.value0);
                          };
                          if (y.value0.value0 instanceof Data_Either.Right) {
                              return Data_Void.absurd(y.value0.value0.value0);
                          };
                          throw new Error("Failed pattern match at Data.Either.Nested line 149, column 17 - line 151, column 28: " + [ y.value0.value0.constructor.name ]);
                      };
                      throw new Error("Failed pattern match at Data.Either.Nested line 147, column 15 - line 151, column 28: " + [ y.value0.constructor.name ]);
                  };
                  throw new Error("Failed pattern match at Data.Either.Nested line 145, column 19 - line 151, column 28: " + [ y.constructor.name ]);
              };
          };
      };
  };
  var either2 = function (a) {
      return function (b) {
          return function (y) {
              if (y instanceof Data_Either.Left) {
                  return a(y.value0);
              };
              if (y instanceof Data_Either.Right) {
                  if (y.value0 instanceof Data_Either.Left) {
                      return b(y.value0.value0);
                  };
                  if (y.value0 instanceof Data_Either.Right) {
                      return Data_Void.absurd(y.value0.value0);
                  };
                  throw new Error("Failed pattern match at Data.Either.Nested line 140, column 15 - line 142, column 26: " + [ y.value0.constructor.name ]);
              };
              throw new Error("Failed pattern match at Data.Either.Nested line 138, column 17 - line 142, column 26: " + [ y.constructor.name ]);
          };
      };
  };
  var either10 = function (a) {
      return function (b) {
          return function (c) {
              return function (d) {
                  return function (e) {
                      return function (f) {
                          return function (g) {
                              return function (h) {
                                  return function (i) {
                                      return function (j) {
                                          return function (y) {
                                              if (y instanceof Data_Either.Left) {
                                                  return a(y.value0);
                                              };
                                              if (y instanceof Data_Either.Right) {
                                                  if (y.value0 instanceof Data_Either.Left) {
                                                      return b(y.value0.value0);
                                                  };
                                                  if (y.value0 instanceof Data_Either.Right) {
                                                      if (y.value0.value0 instanceof Data_Either.Left) {
                                                          return c(y.value0.value0.value0);
                                                      };
                                                      if (y.value0.value0 instanceof Data_Either.Right) {
                                                          if (y.value0.value0.value0 instanceof Data_Either.Left) {
                                                              return d(y.value0.value0.value0.value0);
                                                          };
                                                          if (y.value0.value0.value0 instanceof Data_Either.Right) {
                                                              if (y.value0.value0.value0.value0 instanceof Data_Either.Left) {
                                                                  return e(y.value0.value0.value0.value0.value0);
                                                              };
                                                              if (y.value0.value0.value0.value0 instanceof Data_Either.Right) {
                                                                  if (y.value0.value0.value0.value0.value0 instanceof Data_Either.Left) {
                                                                      return f(y.value0.value0.value0.value0.value0.value0);
                                                                  };
                                                                  if (y.value0.value0.value0.value0.value0 instanceof Data_Either.Right) {
                                                                      if (y.value0.value0.value0.value0.value0.value0 instanceof Data_Either.Left) {
                                                                          return g(y.value0.value0.value0.value0.value0.value0.value0);
                                                                      };
                                                                      if (y.value0.value0.value0.value0.value0.value0 instanceof Data_Either.Right) {
                                                                          if (y.value0.value0.value0.value0.value0.value0.value0 instanceof Data_Either.Left) {
                                                                              return h(y.value0.value0.value0.value0.value0.value0.value0.value0);
                                                                          };
                                                                          if (y.value0.value0.value0.value0.value0.value0.value0 instanceof Data_Either.Right) {
                                                                              if (y.value0.value0.value0.value0.value0.value0.value0.value0 instanceof Data_Either.Left) {
                                                                                  return i(y.value0.value0.value0.value0.value0.value0.value0.value0.value0);
                                                                              };
                                                                              if (y.value0.value0.value0.value0.value0.value0.value0.value0 instanceof Data_Either.Right) {
                                                                                  if (y.value0.value0.value0.value0.value0.value0.value0.value0.value0 instanceof Data_Either.Left) {
                                                                                      return j(y.value0.value0.value0.value0.value0.value0.value0.value0.value0.value0);
                                                                                  };
                                                                                  if (y.value0.value0.value0.value0.value0.value0.value0.value0.value0 instanceof Data_Either.Right) {
                                                                                      return Data_Void.absurd(y.value0.value0.value0.value0.value0.value0.value0.value0.value0.value0);
                                                                                  };
                                                                                  throw new Error("Failed pattern match at Data.Either.Nested line 268, column 31 - line 270, column 41: " + [ y.value0.value0.value0.value0.value0.value0.value0.value0.value0.constructor.name ]);
                                                                              };
                                                                              throw new Error("Failed pattern match at Data.Either.Nested line 266, column 29 - line 270, column 41: " + [ y.value0.value0.value0.value0.value0.value0.value0.value0.constructor.name ]);
                                                                          };
                                                                          throw new Error("Failed pattern match at Data.Either.Nested line 264, column 27 - line 270, column 41: " + [ y.value0.value0.value0.value0.value0.value0.value0.constructor.name ]);
                                                                      };
                                                                      throw new Error("Failed pattern match at Data.Either.Nested line 262, column 25 - line 270, column 41: " + [ y.value0.value0.value0.value0.value0.value0.constructor.name ]);
                                                                  };
                                                                  throw new Error("Failed pattern match at Data.Either.Nested line 260, column 23 - line 270, column 41: " + [ y.value0.value0.value0.value0.value0.constructor.name ]);
                                                              };
                                                              throw new Error("Failed pattern match at Data.Either.Nested line 258, column 21 - line 270, column 41: " + [ y.value0.value0.value0.value0.constructor.name ]);
                                                          };
                                                          throw new Error("Failed pattern match at Data.Either.Nested line 256, column 19 - line 270, column 41: " + [ y.value0.value0.value0.constructor.name ]);
                                                      };
                                                      throw new Error("Failed pattern match at Data.Either.Nested line 254, column 17 - line 270, column 41: " + [ y.value0.value0.constructor.name ]);
                                                  };
                                                  throw new Error("Failed pattern match at Data.Either.Nested line 252, column 15 - line 270, column 41: " + [ y.value0.constructor.name ]);
                                              };
                                              throw new Error("Failed pattern match at Data.Either.Nested line 250, column 34 - line 270, column 41: " + [ y.constructor.name ]);
                                          };
                                      };
                                  };
                              };
                          };
                      };
                  };
              };
          };
      };
  };
  var either1 = function (y) {
      if (y instanceof Data_Either.Left) {
          return y.value0;
      };
      if (y instanceof Data_Either.Right) {
          return Data_Void.absurd(y.value0);
      };
      throw new Error("Failed pattern match at Data.Either.Nested line 133, column 13 - line 135, column 24: " + [ y.constructor.name ]);
  };
  var at9 = function (b) {
      return function (f) {
          return function (y) {
              if (y instanceof Data_Either.Right && (y.value0 instanceof Data_Either.Right && (y.value0.value0 instanceof Data_Either.Right && (y.value0.value0.value0 instanceof Data_Either.Right && (y.value0.value0.value0.value0 instanceof Data_Either.Right && (y.value0.value0.value0.value0.value0 instanceof Data_Either.Right && (y.value0.value0.value0.value0.value0.value0 instanceof Data_Either.Right && (y.value0.value0.value0.value0.value0.value0.value0 instanceof Data_Either.Right && y.value0.value0.value0.value0.value0.value0.value0.value0 instanceof Data_Either.Left)))))))) {
                  return f(y.value0.value0.value0.value0.value0.value0.value0.value0.value0);
              };
              return b;
          };
      };
  };
  var at8 = function (b) {
      return function (f) {
          return function (y) {
              if (y instanceof Data_Either.Right && (y.value0 instanceof Data_Either.Right && (y.value0.value0 instanceof Data_Either.Right && (y.value0.value0.value0 instanceof Data_Either.Right && (y.value0.value0.value0.value0 instanceof Data_Either.Right && (y.value0.value0.value0.value0.value0 instanceof Data_Either.Right && (y.value0.value0.value0.value0.value0.value0 instanceof Data_Either.Right && y.value0.value0.value0.value0.value0.value0.value0 instanceof Data_Either.Left))))))) {
                  return f(y.value0.value0.value0.value0.value0.value0.value0.value0);
              };
              return b;
          };
      };
  };
  var at7 = function (b) {
      return function (f) {
          return function (y) {
              if (y instanceof Data_Either.Right && (y.value0 instanceof Data_Either.Right && (y.value0.value0 instanceof Data_Either.Right && (y.value0.value0.value0 instanceof Data_Either.Right && (y.value0.value0.value0.value0 instanceof Data_Either.Right && (y.value0.value0.value0.value0.value0 instanceof Data_Either.Right && y.value0.value0.value0.value0.value0.value0 instanceof Data_Either.Left)))))) {
                  return f(y.value0.value0.value0.value0.value0.value0.value0);
              };
              return b;
          };
      };
  };
  var at6 = function (b) {
      return function (f) {
          return function (y) {
              if (y instanceof Data_Either.Right && (y.value0 instanceof Data_Either.Right && (y.value0.value0 instanceof Data_Either.Right && (y.value0.value0.value0 instanceof Data_Either.Right && (y.value0.value0.value0.value0 instanceof Data_Either.Right && y.value0.value0.value0.value0.value0 instanceof Data_Either.Left))))) {
                  return f(y.value0.value0.value0.value0.value0.value0);
              };
              return b;
          };
      };
  };
  var at5 = function (b) {
      return function (f) {
          return function (y) {
              if (y instanceof Data_Either.Right && (y.value0 instanceof Data_Either.Right && (y.value0.value0 instanceof Data_Either.Right && (y.value0.value0.value0 instanceof Data_Either.Right && y.value0.value0.value0.value0 instanceof Data_Either.Left)))) {
                  return f(y.value0.value0.value0.value0.value0);
              };
              return b;
          };
      };
  };
  var at4 = function (b) {
      return function (f) {
          return function (y) {
              if (y instanceof Data_Either.Right && (y.value0 instanceof Data_Either.Right && (y.value0.value0 instanceof Data_Either.Right && y.value0.value0.value0 instanceof Data_Either.Left))) {
                  return f(y.value0.value0.value0.value0);
              };
              return b;
          };
      };
  };
  var at3 = function (b) {
      return function (f) {
          return function (y) {
              if (y instanceof Data_Either.Right && (y.value0 instanceof Data_Either.Right && y.value0.value0 instanceof Data_Either.Left)) {
                  return f(y.value0.value0.value0);
              };
              return b;
          };
      };
  };
  var at2 = function (b) {
      return function (f) {
          return function (y) {
              if (y instanceof Data_Either.Right && y.value0 instanceof Data_Either.Left) {
                  return f(y.value0.value0);
              };
              return b;
          };
      };
  };
  var at10 = function (b) {
      return function (f) {
          return function (y) {
              if (y instanceof Data_Either.Right && (y.value0 instanceof Data_Either.Right && (y.value0.value0 instanceof Data_Either.Right && (y.value0.value0.value0 instanceof Data_Either.Right && (y.value0.value0.value0.value0 instanceof Data_Either.Right && (y.value0.value0.value0.value0.value0 instanceof Data_Either.Right && (y.value0.value0.value0.value0.value0.value0 instanceof Data_Either.Right && (y.value0.value0.value0.value0.value0.value0.value0 instanceof Data_Either.Right && (y.value0.value0.value0.value0.value0.value0.value0.value0 instanceof Data_Either.Right && y.value0.value0.value0.value0.value0.value0.value0.value0.value0 instanceof Data_Either.Left))))))))) {
                  return f(y.value0.value0.value0.value0.value0.value0.value0.value0.value0.value0);
              };
              return b;
          };
      };
  };
  var at1 = function (b) {
      return function (f) {
          return function (y) {
              if (y instanceof Data_Either.Left) {
                  return f(y.value0);
              };
              return b;
          };
      };
  };
  exports["at1"] = at1;
  exports["at10"] = at10;
  exports["at2"] = at2;
  exports["at3"] = at3;
  exports["at4"] = at4;
  exports["at5"] = at5;
  exports["at6"] = at6;
  exports["at7"] = at7;
  exports["at8"] = at8;
  exports["at9"] = at9;
  exports["either1"] = either1;
  exports["either10"] = either10;
  exports["either2"] = either2;
  exports["either3"] = either3;
  exports["either4"] = either4;
  exports["either5"] = either5;
  exports["either6"] = either6;
  exports["either7"] = either7;
  exports["either8"] = either8;
  exports["either9"] = either9;
  exports["in1"] = in1;
  exports["in10"] = in10;
  exports["in2"] = in2;
  exports["in3"] = in3;
  exports["in4"] = in4;
  exports["in5"] = in5;
  exports["in6"] = in6;
  exports["in7"] = in7;
  exports["in8"] = in8;
  exports["in9"] = in9;
})(PS["Data.Either.Nested"] = PS["Data.Either.Nested"] || {});
(function(exports) {
    "use strict";
  var Prelude = PS["Prelude"];
  var Control_MonadPlus = PS["Control.MonadPlus"];
  var Data_Char = PS["Data.Char"];
  var Data_Either = PS["Data.Either"];
  var Data_Maybe = PS["Data.Maybe"];
  var Data_Newtype = PS["Data.Newtype"];
  var Data_Tuple = PS["Data.Tuple"];
  var Data_Unfoldable = PS["Data.Unfoldable"];
  var Partial_Unsafe = PS["Partial.Unsafe"];
  var Data_Eq = PS["Data.Eq"];
  var Data_Ord = PS["Data.Ord"];
  var Data_Bounded = PS["Data.Bounded"];
  var Data_Semiring = PS["Data.Semiring"];
  var Data_Ring = PS["Data.Ring"];
  var Data_Function = PS["Data.Function"];
  var Data_Ordering = PS["Data.Ordering"];
  var Data_Functor = PS["Data.Functor"];
  var Control_Semigroupoid = PS["Control.Semigroupoid"];
  var Control_Category = PS["Control.Category"];
  var Data_Unit = PS["Data.Unit"];
  var Data_HeytingAlgebra = PS["Data.HeytingAlgebra"];
  var Data_Boolean = PS["Data.Boolean"];
  var Control_Apply = PS["Control.Apply"];
  var Data_EuclideanRing = PS["Data.EuclideanRing"];
  var Control_Bind = PS["Control.Bind"];
  var Control_MonadZero = PS["Control.MonadZero"];
  var Control_Applicative = PS["Control.Applicative"];        
  var Cardinality = function (x) {
      return x;
  };

  /**
 *  | Type class for enumerations.
 *  |
 *  | Laws:
 *  | - `succ a > pred a`
 *  | - `pred a < succ a`
 *  | - `pred >=> succ >=> pred = pred`
 *  | - `succ >=> pred >=> succ = succ`
 */  
  var Enum = function (__superclass_Data$dotOrd$dotOrd_0, pred, succ) {
      this["__superclass_Data.Ord.Ord_0"] = __superclass_Data$dotOrd$dotOrd_0;
      this.pred = pred;
      this.succ = succ;
  };

  /**
 *  | Type class for finite enumerations.
 *  |
 *  | This should not be considered a part of a numeric hierarchy, as in Haskell.
 *  | Rather, this is a type class for small, ordered sum types with
 *  | statically-determined cardinality and the ability to easily compute
 *  | successor and predecessor elements, e.g. `DayOfWeek`.
 *  |
 *  | Laws:
 *  |
 *  | - ```succ bottom >>= succ >>= succ ... succ [cardinality - 1 times] == top```
 *  | - ```pred top    >>= pred >>= pred ... pred [cardinality - 1 times] == bottom```
 *  | - ```forall a > bottom: pred a >>= succ == Just a```
 *  | - ```forall a < top:  succ a >>= pred == Just a```
 *  | - ```forall a > bottom: fromEnum <$> pred a = Just (fromEnum a - 1)```
 *  | - ```forall a < top:  fromEnum <$> succ a = Just (fromEnum a + 1)```
 *  | - ```e1 `compare` e2 == fromEnum e1 `compare` fromEnum e2```
 *  | - ```toEnum (fromEnum a) = Just a```
 */  
  var BoundedEnum = function (__superclass_Data$dotBounded$dotBounded_0, __superclass_Data$dotEnum$dotEnum_1, cardinality, fromEnum, toEnum) {
      this["__superclass_Data.Bounded.Bounded_0"] = __superclass_Data$dotBounded$dotBounded_0;
      this["__superclass_Data.Enum.Enum_1"] = __superclass_Data$dotEnum$dotEnum_1;
      this.cardinality = cardinality;
      this.fromEnum = fromEnum;
      this.toEnum = toEnum;
  };

  /**
 *  | Type class for finite enumerations.
 *  |
 *  | This should not be considered a part of a numeric hierarchy, as in Haskell.
 *  | Rather, this is a type class for small, ordered sum types with
 *  | statically-determined cardinality and the ability to easily compute
 *  | successor and predecessor elements, e.g. `DayOfWeek`.
 *  |
 *  | Laws:
 *  |
 *  | - ```succ bottom >>= succ >>= succ ... succ [cardinality - 1 times] == top```
 *  | - ```pred top    >>= pred >>= pred ... pred [cardinality - 1 times] == bottom```
 *  | - ```forall a > bottom: pred a >>= succ == Just a```
 *  | - ```forall a < top:  succ a >>= pred == Just a```
 *  | - ```forall a > bottom: fromEnum <$> pred a = Just (fromEnum a - 1)```
 *  | - ```forall a < top:  fromEnum <$> succ a = Just (fromEnum a + 1)```
 *  | - ```e1 `compare` e2 == fromEnum e1 `compare` fromEnum e2```
 *  | - ```toEnum (fromEnum a) = Just a```
 */  
  var toEnum = function (dict) {
      return dict.toEnum;
  };

  /**
 *  | Type class for enumerations.
 *  |
 *  | Laws:
 *  | - `succ a > pred a`
 *  | - `pred a < succ a`
 *  | - `pred >=> succ >=> pred = pred`
 *  | - `succ >=> pred >=> succ = succ`
 */  
  var succ = function (dict) {
      return dict.succ;
  };

  /**
 *  | Type class for enumerations.
 *  |
 *  | Laws:
 *  | - `succ a > pred a`
 *  | - `pred a < succ a`
 *  | - `pred >=> succ >=> pred = pred`
 *  | - `succ >=> pred >=> succ = succ`
 */  
  var pred = function (dict) {
      return dict.pred;
  };
  var ordCardinality = Data_Ord.ordInt;
  var newtypeCardinality = new Data_Newtype.Newtype(function (n) {
      return n;
  }, Cardinality);

  /**
 *  | Property: ```forall e in intStepFromTo step a b: a <= e <= b```
 */  
  var intStepFromTo = function (step) {
      return function (from) {
          return function (to) {
              return Data_Unfoldable.unfoldr(Data_Unfoldable.unfoldableArray)(function (e) {
                  var $53 = e <= to;
                  if ($53) {
                      return Data_Maybe.Just.create(new Data_Tuple.Tuple(e, e + step | 0));
                  };
                  if (!$53) {
                      return Data_Maybe.Nothing.value;
                  };
                  throw new Error("Failed pattern match at Data.Enum line 124, column 13 - line 126, column 25: " + [ $53.constructor.name ]);
              })(from);
          };
      };
  };

  /**
 *  | Type class for finite enumerations.
 *  |
 *  | This should not be considered a part of a numeric hierarchy, as in Haskell.
 *  | Rather, this is a type class for small, ordered sum types with
 *  | statically-determined cardinality and the ability to easily compute
 *  | successor and predecessor elements, e.g. `DayOfWeek`.
 *  |
 *  | Laws:
 *  |
 *  | - ```succ bottom >>= succ >>= succ ... succ [cardinality - 1 times] == top```
 *  | - ```pred top    >>= pred >>= pred ... pred [cardinality - 1 times] == bottom```
 *  | - ```forall a > bottom: pred a >>= succ == Just a```
 *  | - ```forall a < top:  succ a >>= pred == Just a```
 *  | - ```forall a > bottom: fromEnum <$> pred a = Just (fromEnum a - 1)```
 *  | - ```forall a < top:  fromEnum <$> succ a = Just (fromEnum a + 1)```
 *  | - ```e1 `compare` e2 == fromEnum e1 `compare` fromEnum e2```
 *  | - ```toEnum (fromEnum a) = Just a```
 */  
  var fromEnum = function (dict) {
      return dict.fromEnum;
  };

  /**
 *  | Like `toEnum` but returns the first argument if `x` is less than
 *  | `fromEnum bottom` and the second argument if `x` is greater than
 *  | `fromEnum top`.
 *  |
 *  | ``` purescript
 *  | toEnumWithDefaults False True (-1) -- False
 *  | toEnumWithDefaults False True 0    -- False
 *  | toEnumWithDefaults False True 1    -- True
 *  | toEnumWithDefaults False True 2    -- True
 *  | ```
 */  
  var toEnumWithDefaults = function (dictBoundedEnum) {
      return function (b) {
          return function (t) {
              return function (x) {
                  var $54 = toEnum(dictBoundedEnum)(x);
                  if ($54 instanceof Data_Maybe.Just) {
                      return $54.value0;
                  };
                  if ($54 instanceof Data_Maybe.Nothing) {
                      var $56 = x < fromEnum(dictBoundedEnum)(Data_Bounded.bottom(dictBoundedEnum["__superclass_Data.Bounded.Bounded_0"]()));
                      if ($56) {
                          return b;
                      };
                      if (!$56) {
                          return t;
                      };
                      throw new Error("Failed pattern match at Data.Enum line 263, column 14 - line 263, column 56: " + [ $56.constructor.name ]);
                  };
                  throw new Error("Failed pattern match at Data.Enum line 261, column 28 - line 263, column 56: " + [ $54.constructor.name ]);
              };
          };
      };
  };
  var eqCardinality = Data_Eq.eqInt;
  var enumUnit = new Enum(function () {
      return Data_Ord.ordUnit;
  }, Data_Function["const"](Data_Maybe.Nothing.value), Data_Function["const"](Data_Maybe.Nothing.value));
  var enumTuple = function (dictEnum) {
      return function (dictBoundedEnum) {
          return new Enum(function () {
              return Data_Tuple.ordTuple(dictEnum["__superclass_Data.Ord.Ord_0"]())((dictBoundedEnum["__superclass_Data.Enum.Enum_1"]())["__superclass_Data.Ord.Ord_0"]());
          }, function (v) {
              return Data_Maybe.maybe(Data_Functor.map(Data_Maybe.functorMaybe)(Data_Function.flip(Data_Tuple.Tuple.create)(Data_Bounded.top(dictBoundedEnum["__superclass_Data.Bounded.Bounded_0"]())))(pred(dictEnum)(v.value0)))(function ($103) {
                  return Data_Maybe.Just.create(Data_Tuple.Tuple.create(v.value0)($103));
              })(pred(dictBoundedEnum["__superclass_Data.Enum.Enum_1"]())(v.value1));
          }, function (v) {
              return Data_Maybe.maybe(Data_Functor.map(Data_Maybe.functorMaybe)(Data_Function.flip(Data_Tuple.Tuple.create)(Data_Bounded.bottom(dictBoundedEnum["__superclass_Data.Bounded.Bounded_0"]())))(succ(dictEnum)(v.value0)))(function ($104) {
                  return Data_Maybe.Just.create(Data_Tuple.Tuple.create(v.value0)($104));
              })(succ(dictBoundedEnum["__superclass_Data.Enum.Enum_1"]())(v.value1));
          });
      };
  };
  var enumOrdering = new Enum(function () {
      return Data_Ord.ordOrdering;
  }, function (v) {
      if (v instanceof Data_Ordering.LT) {
          return Data_Maybe.Nothing.value;
      };
      if (v instanceof Data_Ordering.EQ) {
          return new Data_Maybe.Just(Data_Ordering.LT.value);
      };
      if (v instanceof Data_Ordering.GT) {
          return new Data_Maybe.Just(Data_Ordering.EQ.value);
      };
      throw new Error("Failed pattern match at Data.Enum line 74, column 3 - line 74, column 20: " + [ v.constructor.name ]);
  }, function (v) {
      if (v instanceof Data_Ordering.LT) {
          return new Data_Maybe.Just(Data_Ordering.EQ.value);
      };
      if (v instanceof Data_Ordering.EQ) {
          return new Data_Maybe.Just(Data_Ordering.GT.value);
      };
      if (v instanceof Data_Ordering.GT) {
          return Data_Maybe.Nothing.value;
      };
      throw new Error("Failed pattern match at Data.Enum line 71, column 3 - line 71, column 20: " + [ v.constructor.name ]);
  });
  var enumMaybe = function (dictBoundedEnum) {
      return new Enum(function () {
          return Data_Maybe.ordMaybe((dictBoundedEnum["__superclass_Data.Enum.Enum_1"]())["__superclass_Data.Ord.Ord_0"]());
      }, function (v) {
          if (v instanceof Data_Maybe.Nothing) {
              return Data_Maybe.Nothing.value;
          };
          if (v instanceof Data_Maybe.Just) {
              return Data_Maybe.Just.create(pred(dictBoundedEnum["__superclass_Data.Enum.Enum_1"]())(v.value0));
          };
          throw new Error("Failed pattern match at Data.Enum line 81, column 3 - line 81, column 25: " + [ v.constructor.name ]);
      }, function (v) {
          if (v instanceof Data_Maybe.Nothing) {
              return Data_Maybe.Just.create(new Data_Maybe.Just(Data_Bounded.bottom(dictBoundedEnum["__superclass_Data.Bounded.Bounded_0"]())));
          };
          if (v instanceof Data_Maybe.Just) {
              return Data_Functor.map(Data_Maybe.functorMaybe)(Data_Maybe.Just.create)(succ(dictBoundedEnum["__superclass_Data.Enum.Enum_1"]())(v.value0));
          };
          throw new Error("Failed pattern match at Data.Enum line 79, column 3 - line 79, column 36: " + [ v.constructor.name ]);
      });
  };
  var enumInt = new Enum(function () {
      return Data_Ord.ordInt;
  }, function (n) {
      var $69 = n > Data_Bounded.bottom(Data_Bounded.boundedInt);
      if ($69) {
          return new Data_Maybe.Just(n - 1);
      };
      if (!$69) {
          return Data_Maybe.Nothing.value;
      };
      throw new Error("Failed pattern match at Data.Enum line 56, column 12 - line 56, column 56: " + [ $69.constructor.name ]);
  }, function (n) {
      var $70 = n < Data_Bounded.top(Data_Bounded.boundedInt);
      if ($70) {
          return new Data_Maybe.Just(n + 1 | 0);
      };
      if (!$70) {
          return Data_Maybe.Nothing.value;
      };
      throw new Error("Failed pattern match at Data.Enum line 55, column 12 - line 55, column 53: " + [ $70.constructor.name ]);
  });

  /**
 *  | Returns a successive sequence of elements from the lower bound to
 *  | the upper bound (inclusive).
 */  
  var enumFromTo = function (dictEnum) {
      return function (dictUnfoldable) {
          return function (from) {
              return function (to) {
                  var go = function (mx) {
                      return Control_Bind.bind(Data_Maybe.bindMaybe)(mx)(function (v) {
                          return Control_Bind.bind(Data_Maybe.bindMaybe)(Control_MonadZero.guard(Data_Maybe.monadZeroMaybe)(Data_Ord.lessThanOrEq(dictEnum["__superclass_Data.Ord.Ord_0"]())(v)(to)))(function () {
                              return Control_Applicative.pure(Data_Maybe.applicativeMaybe)(new Data_Tuple.Tuple(v, succ(dictEnum)(v)));
                          });
                      });
                  };
                  return Data_Unfoldable.unfoldr(dictUnfoldable)(go)(new Data_Maybe.Just(from));
              };
          };
      };
  };

  /**
 *  | `[a,b..c]`
 */  
  var enumFromThenTo = function (dictBoundedEnum) {
      return Partial_Unsafe.unsafePartial(function (dictPartial) {
          return function (a) {
              return function (b) {
                  return function (c) {
                      var c$prime = fromEnum(dictBoundedEnum)(c);
                      var b$prime = fromEnum(dictBoundedEnum)(b);
                      var a$prime = fromEnum(dictBoundedEnum)(a);
                      return Data_Functor.map(Data_Functor.functorArray)(function ($105) {
                          return Data_Maybe.fromJust(dictPartial)(toEnum(dictBoundedEnum)($105));
                      })(intStepFromTo(b$prime - a$prime)(a$prime)(c$prime));
                  };
              };
          };
      });
  };
  var enumEither = function (dictBoundedEnum) {
      return function (dictBoundedEnum1) {
          return new Enum(function () {
              return Data_Either.ordEither((dictBoundedEnum["__superclass_Data.Enum.Enum_1"]())["__superclass_Data.Ord.Ord_0"]())((dictBoundedEnum1["__superclass_Data.Enum.Enum_1"]())["__superclass_Data.Ord.Ord_0"]());
          }, function (v) {
              if (v instanceof Data_Either.Left) {
                  return Data_Maybe.maybe(Data_Maybe.Nothing.value)(function ($106) {
                      return Data_Maybe.Just.create(Data_Either.Left.create($106));
                  })(pred(dictBoundedEnum["__superclass_Data.Enum.Enum_1"]())(v.value0));
              };
              if (v instanceof Data_Either.Right) {
                  return Data_Maybe.maybe(Data_Maybe.Just.create(new Data_Either.Left(Data_Bounded.top(dictBoundedEnum["__superclass_Data.Bounded.Bounded_0"]()))))(function ($107) {
                      return Data_Maybe.Just.create(Data_Either.Right.create($107));
                  })(pred(dictBoundedEnum1["__superclass_Data.Enum.Enum_1"]())(v.value0));
              };
              throw new Error("Failed pattern match at Data.Enum line 87, column 3 - line 87, column 59: " + [ v.constructor.name ]);
          }, function (v) {
              if (v instanceof Data_Either.Left) {
                  return Data_Maybe.maybe(Data_Maybe.Just.create(new Data_Either.Right(Data_Bounded.bottom(dictBoundedEnum1["__superclass_Data.Bounded.Bounded_0"]()))))(function ($108) {
                      return Data_Maybe.Just.create(Data_Either.Left.create($108));
                  })(succ(dictBoundedEnum["__superclass_Data.Enum.Enum_1"]())(v.value0));
              };
              if (v instanceof Data_Either.Right) {
                  return Data_Maybe.maybe(Data_Maybe.Nothing.value)(function ($109) {
                      return Data_Maybe.Just.create(Data_Either.Right.create($109));
                  })(succ(dictBoundedEnum1["__superclass_Data.Enum.Enum_1"]())(v.value0));
              };
              throw new Error("Failed pattern match at Data.Enum line 85, column 3 - line 85, column 71: " + [ v.constructor.name ]);
          });
      };
  };
  var enumBoolean = new Enum(function () {
      return Data_Ord.ordBoolean;
  }, function (v) {
      if (v) {
          return new Data_Maybe.Just(false);
      };
      return Data_Maybe.Nothing.value;
  }, function (v) {
      if (!v) {
          return new Data_Maybe.Just(true);
      };
      return Data_Maybe.Nothing.value;
  });
  var diag = function (a) {
      return new Data_Tuple.Tuple(a, a);
  };
  var downFrom = function (dictEnum) {
      return function (dictUnfoldable) {
          return Data_Unfoldable.unfoldr(dictUnfoldable)(function ($110) {
              return Data_Functor.map(Data_Maybe.functorMaybe)(diag)(pred(dictEnum)($110));
          });
      };
  };
  var upFrom = function (dictEnum) {
      return function (dictUnfoldable) {
          return Data_Unfoldable.unfoldr(dictUnfoldable)(function ($111) {
              return Data_Functor.map(Data_Maybe.functorMaybe)(diag)(succ(dictEnum)($111));
          });
      };
  };
  var defaultToEnum = function (dictBounded) {
      return function (dictEnum) {
          return function (n) {
              if (n < 0) {
                  return Data_Maybe.Nothing.value;
              };
              if (n === 0) {
                  return new Data_Maybe.Just(Data_Bounded.bottom(dictBounded));
              };
              if (Data_Boolean.otherwise) {
                  return Control_Bind.bind(Data_Maybe.bindMaybe)(defaultToEnum(dictBounded)(dictEnum)(n - 1))(succ(dictEnum));
              };
              throw new Error("Failed pattern match at Data.Enum line 241, column 1 - line 244, column 47: " + [ n.constructor.name ]);
          };
      };
  };

  /**
 *  | ```defaultSucc toEnum fromEnum = succ```
 */  
  var defaultSucc = function (toEnum$prime) {
      return function (fromEnum$prime) {
          return function (a) {
              return toEnum$prime(fromEnum$prime(a) + 1 | 0);
          };
      };
  };

  /**
 *  | ```defaultPred toEnum fromEnum = pred```
 */  
  var defaultPred = function (toEnum$prime) {
      return function (fromEnum$prime) {
          return function (a) {
              return toEnum$prime(fromEnum$prime(a) - 1);
          };
      };
  };
  var defaultFromEnum = function (dictEnum) {
      return function ($112) {
          return Data_Maybe.maybe(0)(function (prd) {
              return defaultFromEnum(dictEnum)(prd) + 1 | 0;
          })(pred(dictEnum)($112));
      };
  };

  /**
 *  | Runs in `O(n)` where `n` is `fromEnum top`
 */  
  var defaultCardinality = function (dictBounded) {
      return function (dictEnum) {
          var defaultCardinality$prime = function (i) {
              return function ($113) {
                  return Data_Maybe.maybe(i)(defaultCardinality$prime(i + 1 | 0))(succ(dictEnum)($113));
              };
          };
          return Cardinality(defaultCardinality$prime(1)(Data_Bounded.bottom(dictBounded)));
      };
  };
  var charToEnum = function (v) {
      if (v >= Data_Bounded.bottom(Data_Bounded.boundedInt) && v <= Data_Bounded.top(Data_Bounded.boundedInt)) {
          return Data_Maybe.Just.create(Data_Char.fromCharCode(v));
      };
      return Data_Maybe.Nothing.value;
  };
  var enumChar = new Enum(function () {
      return Data_Ord.ordChar;
  }, defaultPred(charToEnum)(Data_Char.toCharCode), defaultSucc(charToEnum)(Data_Char.toCharCode));

  /**
 *  | Type class for finite enumerations.
 *  |
 *  | This should not be considered a part of a numeric hierarchy, as in Haskell.
 *  | Rather, this is a type class for small, ordered sum types with
 *  | statically-determined cardinality and the ability to easily compute
 *  | successor and predecessor elements, e.g. `DayOfWeek`.
 *  |
 *  | Laws:
 *  |
 *  | - ```succ bottom >>= succ >>= succ ... succ [cardinality - 1 times] == top```
 *  | - ```pred top    >>= pred >>= pred ... pred [cardinality - 1 times] == bottom```
 *  | - ```forall a > bottom: pred a >>= succ == Just a```
 *  | - ```forall a < top:  succ a >>= pred == Just a```
 *  | - ```forall a > bottom: fromEnum <$> pred a = Just (fromEnum a - 1)```
 *  | - ```forall a < top:  fromEnum <$> succ a = Just (fromEnum a + 1)```
 *  | - ```e1 `compare` e2 == fromEnum e1 `compare` fromEnum e2```
 *  | - ```toEnum (fromEnum a) = Just a```
 */  
  var cardinality = function (dict) {
      return dict.cardinality;
  };
  var boundedEnumUnit = new BoundedEnum(function () {
      return Data_Bounded.boundedUnit;
  }, function () {
      return enumUnit;
  }, 1, Data_Function["const"](0), function (v) {
      if (v === 0) {
          return new Data_Maybe.Just(Data_Unit.unit);
      };
      return Data_Maybe.Nothing.value;
  });
  var boundedEnumTuple = function (dictBoundedEnum) {
      return function (dictBoundedEnum1) {
          return new BoundedEnum(function () {
              return Data_Tuple.boundedTuple(dictBoundedEnum["__superclass_Data.Bounded.Bounded_0"]())(dictBoundedEnum1["__superclass_Data.Bounded.Bounded_0"]());
          }, function () {
              return enumTuple(dictBoundedEnum["__superclass_Data.Enum.Enum_1"]())(dictBoundedEnum1);
          }, Cardinality(Data_Newtype.unwrap(newtypeCardinality)(cardinality(dictBoundedEnum)) * Data_Newtype.unwrap(newtypeCardinality)(cardinality(dictBoundedEnum1)) | 0), (function () {
              var from = function (v) {
                  return function (v1) {
                      return (fromEnum(dictBoundedEnum)(v1.value0) * v | 0) + fromEnum(dictBoundedEnum1)(v1.value1) | 0;
                  };
              };
              return from(cardinality(dictBoundedEnum1));
          })(), (function () {
              var to = function (v) {
                  return function (n) {
                      return Control_Apply.apply(Data_Maybe.applyMaybe)(Data_Functor.map(Data_Maybe.functorMaybe)(Data_Tuple.Tuple.create)(toEnum(dictBoundedEnum)(n / v | 0)))(toEnum(dictBoundedEnum1)(n % v));
                  };
              };
              return to(cardinality(dictBoundedEnum1));
          })());
      };
  };
  var boundedEnumOrdering = new BoundedEnum(function () {
      return Data_Bounded.boundedOrdering;
  }, function () {
      return enumOrdering;
  }, 3, function (v) {
      if (v instanceof Data_Ordering.LT) {
          return 0;
      };
      if (v instanceof Data_Ordering.EQ) {
          return 1;
      };
      if (v instanceof Data_Ordering.GT) {
          return 2;
      };
      throw new Error("Failed pattern match at Data.Enum line 190, column 3 - line 191, column 3: " + [ v.constructor.name ]);
  }, function (v) {
      if (v === 0) {
          return new Data_Maybe.Just(Data_Ordering.LT.value);
      };
      if (v === 1) {
          return new Data_Maybe.Just(Data_Ordering.EQ.value);
      };
      if (v === 2) {
          return new Data_Maybe.Just(Data_Ordering.GT.value);
      };
      return Data_Maybe.Nothing.value;
  });
  var boundedEnumMaybe = function (dictBoundedEnum) {
      return new BoundedEnum(function () {
          return Data_Maybe.boundedMaybe(dictBoundedEnum["__superclass_Data.Bounded.Bounded_0"]());
      }, function () {
          return enumMaybe(dictBoundedEnum);
      }, Cardinality(Data_Newtype.unwrap(newtypeCardinality)(cardinality(dictBoundedEnum)) + 1 | 0), function (v) {
          if (v instanceof Data_Maybe.Nothing) {
              return 0;
          };
          if (v instanceof Data_Maybe.Just) {
              return fromEnum(dictBoundedEnum)(v.value0) + 1 | 0;
          };
          throw new Error("Failed pattern match at Data.Enum line 202, column 3 - line 203, column 3: " + [ v.constructor.name ]);
      }, (function () {
          var to = function (v) {
              return function (v1) {
                  if (v1 === 0) {
                      return Data_Maybe.Nothing.value;
                  };
                  if (v1 <= v) {
                      return Data_Maybe.Just.create(toEnum(dictBoundedEnum)(v1 - 1));
                  };
                  return Data_Maybe.Nothing.value;
              };
          };
          return to(cardinality(dictBoundedEnum));
      })());
  };
  var boundedEnumInt = new BoundedEnum(function () {
      return Data_Bounded.boundedInt;
  }, function () {
      return enumInt;
  }, Data_Bounded.top(Data_Bounded.boundedInt) - Data_Bounded.bottom(Data_Bounded.boundedInt), Control_Category.id(Control_Category.categoryFn), Data_Maybe.Just.create);
  var boundedEnumEither = function (dictBoundedEnum) {
      return function (dictBoundedEnum1) {
          return new BoundedEnum(function () {
              return Data_Either.boundedEither(dictBoundedEnum["__superclass_Data.Bounded.Bounded_0"]())(dictBoundedEnum1["__superclass_Data.Bounded.Bounded_0"]());
          }, function () {
              return enumEither(dictBoundedEnum)(dictBoundedEnum1);
          }, Cardinality(Data_Newtype.unwrap(newtypeCardinality)(cardinality(dictBoundedEnum)) + Data_Newtype.unwrap(newtypeCardinality)(cardinality(dictBoundedEnum1)) | 0), function (v) {
              if (v instanceof Data_Either.Left) {
                  return fromEnum(dictBoundedEnum)(v.value0);
              };
              if (v instanceof Data_Either.Right) {
                  return fromEnum(dictBoundedEnum1)(v.value0) + Data_Newtype.unwrap(newtypeCardinality)(cardinality(dictBoundedEnum)) | 0;
              };
              throw new Error("Failed pattern match at Data.Enum line 217, column 3 - line 217, column 33: " + [ v.constructor.name ]);
          }, (function () {
              var to = function (v) {
                  return function (v1) {
                      return function (n) {
                          if (n >= 0 && n < v) {
                              return Data_Functor.map(Data_Maybe.functorMaybe)(Data_Either.Left.create)(toEnum(dictBoundedEnum)(n));
                          };
                          if (n >= v && n < v1) {
                              return Data_Functor.map(Data_Maybe.functorMaybe)(Data_Either.Right.create)(toEnum(dictBoundedEnum1)(n - v));
                          };
                          if (Data_Boolean.otherwise) {
                              return Data_Maybe.Nothing.value;
                          };
                          throw new Error("Failed pattern match at Data.Enum line 213, column 5 - line 216, column 28: " + [ v.constructor.name, v1.constructor.name, n.constructor.name ]);
                      };
                  };
              };
              return to(cardinality(dictBoundedEnum))(cardinality(boundedEnumEither(dictBoundedEnum)(dictBoundedEnum1)));
          })());
      };
  };
  var boundedEnumChar = new BoundedEnum(function () {
      return Data_Bounded.boundedChar;
  }, function () {
      return enumChar;
  }, Data_Char.toCharCode(Data_Bounded.top(Data_Bounded.boundedChar)) - Data_Char.toCharCode(Data_Bounded.bottom(Data_Bounded.boundedChar)), Data_Char.toCharCode, charToEnum);
  var boundedEnumBoolean = new BoundedEnum(function () {
      return Data_Bounded.boundedBoolean;
  }, function () {
      return enumBoolean;
  }, 2, function (v) {
      if (!v) {
          return 0;
      };
      if (v) {
          return 1;
      };
      throw new Error("Failed pattern match at Data.Enum line 165, column 3 - line 166, column 3: " + [ v.constructor.name ]);
  }, function (v) {
      if (v === 0) {
          return new Data_Maybe.Just(false);
      };
      if (v === 1) {
          return new Data_Maybe.Just(true);
      };
      return Data_Maybe.Nothing.value;
  });
  exports["Cardinality"] = Cardinality;
  exports["BoundedEnum"] = BoundedEnum;
  exports["Enum"] = Enum;
  exports["cardinality"] = cardinality;
  exports["defaultCardinality"] = defaultCardinality;
  exports["defaultFromEnum"] = defaultFromEnum;
  exports["defaultPred"] = defaultPred;
  exports["defaultSucc"] = defaultSucc;
  exports["defaultToEnum"] = defaultToEnum;
  exports["downFrom"] = downFrom;
  exports["enumFromThenTo"] = enumFromThenTo;
  exports["enumFromTo"] = enumFromTo;
  exports["fromEnum"] = fromEnum;
  exports["pred"] = pred;
  exports["succ"] = succ;
  exports["toEnum"] = toEnum;
  exports["toEnumWithDefaults"] = toEnumWithDefaults;
  exports["upFrom"] = upFrom;
  exports["newtypeCardinality"] = newtypeCardinality;
  exports["eqCardinality"] = eqCardinality;
  exports["ordCardinality"] = ordCardinality;
  exports["enumBoolean"] = enumBoolean;
  exports["enumInt"] = enumInt;
  exports["enumChar"] = enumChar;
  exports["enumUnit"] = enumUnit;
  exports["enumOrdering"] = enumOrdering;
  exports["enumMaybe"] = enumMaybe;
  exports["enumEither"] = enumEither;
  exports["enumTuple"] = enumTuple;
  exports["boundedEnumBoolean"] = boundedEnumBoolean;
  exports["boundedEnumInt"] = boundedEnumInt;
  exports["boundedEnumChar"] = boundedEnumChar;
  exports["boundedEnumUnit"] = boundedEnumUnit;
  exports["boundedEnumOrdering"] = boundedEnumOrdering;
  exports["boundedEnumMaybe"] = boundedEnumMaybe;
  exports["boundedEnumEither"] = boundedEnumEither;
  exports["boundedEnumTuple"] = boundedEnumTuple;
})(PS["Data.Enum"] = PS["Data.Enum"] || {});
(function(exports) {
  /* global exports */
  "use strict";

  // jshint maxparams: 3
  exports.parseJSONImpl = function (left, right, str) {
    try {
      return right(JSON.parse(str));
    } catch (e) {
      return left(e.toString());
    }
  };
  // jshint maxparams: 1

  exports.toForeign = function (value) {
    return value;
  };

  exports.unsafeFromForeign = function (value) {
    return value;
  };

  exports.typeOf = function (value) {
    return typeof value;
  };

  exports.tagOf = function (value) {
    return Object.prototype.toString.call(value).slice(8, -1);
  };

  exports.isNull = function (value) {
    return value === null;
  };

  exports.isUndefined = function (value) {
    return value === undefined;
  };

  exports.isArray = Array.isArray || function (value) {
    return Object.prototype.toString.call(value) === "[object Array]";
  };

  exports.writeObject = function (fields) {
    var record = {};
    for (var i = 0; i < fields.length; i++) {
      record[fields[i].key] = fields[i].value;
    }
    return record;
  };
})(PS["Data.Foreign"] = PS["Data.Foreign"] || {});
(function(exports) {
    "use strict";

  // module Data.Function.Uncurried

  exports.mkFn0 = function (fn) {
    return function () {
      return fn({});
    };
  };

  exports.mkFn2 = function (fn) {
    /* jshint maxparams: 2 */
    return function (a, b) {
      return fn(a)(b);
    };
  };

  exports.mkFn3 = function (fn) {
    /* jshint maxparams: 3 */
    return function (a, b, c) {
      return fn(a)(b)(c);
    };
  };

  exports.mkFn4 = function (fn) {
    /* jshint maxparams: 4 */
    return function (a, b, c, d) {
      return fn(a)(b)(c)(d);
    };
  };

  exports.mkFn5 = function (fn) {
    /* jshint maxparams: 5 */
    return function (a, b, c, d, e) {
      return fn(a)(b)(c)(d)(e);
    };
  };

  exports.mkFn6 = function (fn) {
    /* jshint maxparams: 6 */
    return function (a, b, c, d, e, f) {
      return fn(a)(b)(c)(d)(e)(f);
    };
  };

  exports.mkFn7 = function (fn) {
    /* jshint maxparams: 7 */
    return function (a, b, c, d, e, f, g) {
      return fn(a)(b)(c)(d)(e)(f)(g);
    };
  };

  exports.mkFn8 = function (fn) {
    /* jshint maxparams: 8 */
    return function (a, b, c, d, e, f, g, h) {
      return fn(a)(b)(c)(d)(e)(f)(g)(h);
    };
  };

  exports.mkFn9 = function (fn) {
    /* jshint maxparams: 9 */
    return function (a, b, c, d, e, f, g, h, i) {
      return fn(a)(b)(c)(d)(e)(f)(g)(h)(i);
    };
  };

  exports.mkFn10 = function (fn) {
    /* jshint maxparams: 10 */
    return function (a, b, c, d, e, f, g, h, i, j) {
      return fn(a)(b)(c)(d)(e)(f)(g)(h)(i)(j);
    };
  };

  exports.runFn0 = function (fn) {
    return fn();
  };

  exports.runFn2 = function (fn) {
    return function (a) {
      return function (b) {
        return fn(a, b);
      };
    };
  };

  exports.runFn3 = function (fn) {
    return function (a) {
      return function (b) {
        return function (c) {
          return fn(a, b, c);
        };
      };
    };
  };

  exports.runFn4 = function (fn) {
    return function (a) {
      return function (b) {
        return function (c) {
          return function (d) {
            return fn(a, b, c, d);
          };
        };
      };
    };
  };

  exports.runFn5 = function (fn) {
    return function (a) {
      return function (b) {
        return function (c) {
          return function (d) {
            return function (e) {
              return fn(a, b, c, d, e);
            };
          };
        };
      };
    };
  };

  exports.runFn6 = function (fn) {
    return function (a) {
      return function (b) {
        return function (c) {
          return function (d) {
            return function (e) {
              return function (f) {
                return fn(a, b, c, d, e, f);
              };
            };
          };
        };
      };
    };
  };

  exports.runFn7 = function (fn) {
    return function (a) {
      return function (b) {
        return function (c) {
          return function (d) {
            return function (e) {
              return function (f) {
                return function (g) {
                  return fn(a, b, c, d, e, f, g);
                };
              };
            };
          };
        };
      };
    };
  };

  exports.runFn8 = function (fn) {
    return function (a) {
      return function (b) {
        return function (c) {
          return function (d) {
            return function (e) {
              return function (f) {
                return function (g) {
                  return function (h) {
                    return fn(a, b, c, d, e, f, g, h);
                  };
                };
              };
            };
          };
        };
      };
    };
  };

  exports.runFn9 = function (fn) {
    return function (a) {
      return function (b) {
        return function (c) {
          return function (d) {
            return function (e) {
              return function (f) {
                return function (g) {
                  return function (h) {
                    return function (i) {
                      return fn(a, b, c, d, e, f, g, h, i);
                    };
                  };
                };
              };
            };
          };
        };
      };
    };
  };

  exports.runFn10 = function (fn) {
    return function (a) {
      return function (b) {
        return function (c) {
          return function (d) {
            return function (e) {
              return function (f) {
                return function (g) {
                  return function (h) {
                    return function (i) {
                      return function (j) {
                        return fn(a, b, c, d, e, f, g, h, i, j);
                      };
                    };
                  };
                };
              };
            };
          };
        };
      };
    };
  };
})(PS["Data.Function.Uncurried"] = PS["Data.Function.Uncurried"] || {});
(function(exports) {
    "use strict";
  var $foreign = PS["Data.Function.Uncurried"];
  var Data_Unit = PS["Data.Unit"];        

  /**
 *  | Apply a function of one argument
 */  
  var runFn1 = function (f) {
      return f;
  };

  /**
 *  | Create a function of one argument
 */  
  var mkFn1 = function (f) {
      return f;
  };
  exports["mkFn1"] = mkFn1;
  exports["runFn1"] = runFn1;
  exports["mkFn0"] = $foreign.mkFn0;
  exports["mkFn10"] = $foreign.mkFn10;
  exports["mkFn2"] = $foreign.mkFn2;
  exports["mkFn3"] = $foreign.mkFn3;
  exports["mkFn4"] = $foreign.mkFn4;
  exports["mkFn5"] = $foreign.mkFn5;
  exports["mkFn6"] = $foreign.mkFn6;
  exports["mkFn7"] = $foreign.mkFn7;
  exports["mkFn8"] = $foreign.mkFn8;
  exports["mkFn9"] = $foreign.mkFn9;
  exports["runFn0"] = $foreign.runFn0;
  exports["runFn10"] = $foreign.runFn10;
  exports["runFn2"] = $foreign.runFn2;
  exports["runFn3"] = $foreign.runFn3;
  exports["runFn4"] = $foreign.runFn4;
  exports["runFn5"] = $foreign.runFn5;
  exports["runFn6"] = $foreign.runFn6;
  exports["runFn7"] = $foreign.runFn7;
  exports["runFn8"] = $foreign.runFn8;
  exports["runFn9"] = $foreign.runFn9;
})(PS["Data.Function.Uncurried"] = PS["Data.Function.Uncurried"] || {});
(function(exports) {
    "use strict";
  var Prelude = PS["Prelude"];
  var Data_Foldable = PS["Data.Foldable"];
  var Data_List = PS["Data.List"];
  var Data_List_Types = PS["Data.List.Types"];
  var Data_Maybe = PS["Data.Maybe"];
  var Data_NonEmpty = PS["Data.NonEmpty"];
  var Data_Tuple = PS["Data.Tuple"];
  var Data_Unfoldable = PS["Data.Unfoldable"];
  var Control_Semigroupoid = PS["Control.Semigroupoid"];
  var Data_Functor = PS["Data.Functor"];
  var Data_Semiring = PS["Data.Semiring"];
  var Data_Function = PS["Data.Function"];
  var Control_Bind = PS["Control.Bind"];        
  var uncons = function (v) {
      return {
          head: v.value0, 
          tail: v.value1
      };
  };
  var toList = function (v) {
      return new Data_List_Types.Cons(v.value0, v.value1);
  };
  var toUnfoldable = function (dictUnfoldable) {
      return function ($35) {
          return Data_Unfoldable.unfoldr(dictUnfoldable)(function (xs) {
              return Data_Functor.map(Data_Maybe.functorMaybe)(function (rec) {
                  return new Data_Tuple.Tuple(rec.head, rec.tail);
              })(Data_List.uncons(xs));
          })(toList($35));
      };
  };
  var tail = function (v) {
      return v.value1;
  };
  var singleton = function ($36) {
      return Data_List_Types.NonEmptyList(Data_NonEmpty.singleton(Data_List_Types.plusList)($36));
  };
  var length = function (v) {
      return 1 + Data_List.length(v.value1) | 0;
  };
  var last = function (v) {
      return Data_Maybe.fromMaybe(v.value0)(Data_List.last(v.value1));
  };
  var init = function (v) {
      return Data_Maybe.maybe(Data_List_Types.Nil.value)(function (v1) {
          return new Data_List_Types.Cons(v.value0, v1);
      })(Data_List.init(v.value1));
  };
  var head = function (v) {
      return v.value0;
  };
  var fromList = function (v) {
      if (v instanceof Data_List_Types.Nil) {
          return Data_Maybe.Nothing.value;
      };
      if (v instanceof Data_List_Types.Cons) {
          return new Data_Maybe.Just(new Data_NonEmpty.NonEmpty(v.value0, v.value1));
      };
      throw new Error("Failed pattern match at Data.List.NonEmpty line 36, column 1 - line 36, column 25: " + [ v.constructor.name ]);
  };
  var fromFoldable = function (dictFoldable) {
      return function ($37) {
          return fromList(Data_List.fromFoldable(dictFoldable)($37));
      };
  };
  var concatMap = Data_Function.flip(Control_Bind.bind(Data_List_Types.bindNonEmptyList));
  exports["concatMap"] = concatMap;
  exports["fromFoldable"] = fromFoldable;
  exports["fromList"] = fromList;
  exports["head"] = head;
  exports["init"] = init;
  exports["length"] = length;
  exports["singleton"] = singleton;
  exports["tail"] = tail;
  exports["toList"] = toList;
  exports["toUnfoldable"] = toUnfoldable;
  exports["uncons"] = uncons;
})(PS["Data.List.NonEmpty"] = PS["Data.List.NonEmpty"] || {});
(function(exports) {
  
  /**
 *  | This module defines types and functions for working with _foreign_
 *  | data.
 */  
  "use strict";
  var $foreign = PS["Data.Foreign"];
  var Prelude = PS["Prelude"];
  var Control_Monad_Except = PS["Control.Monad.Except"];
  var Data_Either = PS["Data.Either"];
  var Data_Function_Uncurried = PS["Data.Function.Uncurried"];
  var Data_Int = PS["Data.Int"];
  var Data_List_NonEmpty = PS["Data.List.NonEmpty"];
  var Data_Maybe = PS["Data.Maybe"];
  var Data_String = PS["Data.String"];
  var Data_Eq = PS["Data.Eq"];
  var Data_HeytingAlgebra = PS["Data.HeytingAlgebra"];
  var Data_Ord = PS["Data.Ord"];
  var Data_Ordering = PS["Data.Ordering"];
  var Data_Show = PS["Data.Show"];
  var Data_Semigroup = PS["Data.Semigroup"];
  var Control_Semigroupoid = PS["Control.Semigroupoid"];
  var Control_Monad_Error_Class = PS["Control.Monad.Error.Class"];
  var Control_Monad_Except_Trans = PS["Control.Monad.Except.Trans"];
  var Data_Identity = PS["Data.Identity"];
  var Control_Applicative = PS["Control.Applicative"];
  var Data_Function = PS["Data.Function"];
  var Data_Boolean = PS["Data.Boolean"];        

  /**
 *  | A key/value pair for an object to be written as a `Foreign` value.
 */  
  var Prop = function (x) {
      return x;
  };

  /**
 *  | A type for foreign type errors
 */  
  var ForeignError = (function () {
      function ForeignError(value0) {
          this.value0 = value0;
      };
      ForeignError.create = function (value0) {
          return new ForeignError(value0);
      };
      return ForeignError;
  })();

  /**
 *  | A type for foreign type errors
 */  
  var TypeMismatch = (function () {
      function TypeMismatch(value0, value1) {
          this.value0 = value0;
          this.value1 = value1;
      };
      TypeMismatch.create = function (value0) {
          return function (value1) {
              return new TypeMismatch(value0, value1);
          };
      };
      return TypeMismatch;
  })();

  /**
 *  | A type for foreign type errors
 */  
  var ErrorAtIndex = (function () {
      function ErrorAtIndex(value0, value1) {
          this.value0 = value0;
          this.value1 = value1;
      };
      ErrorAtIndex.create = function (value0) {
          return function (value1) {
              return new ErrorAtIndex(value0, value1);
          };
      };
      return ErrorAtIndex;
  })();

  /**
 *  | A type for foreign type errors
 */  
  var ErrorAtProperty = (function () {
      function ErrorAtProperty(value0, value1) {
          this.value0 = value0;
          this.value1 = value1;
      };
      ErrorAtProperty.create = function (value0) {
          return function (value1) {
              return new ErrorAtProperty(value0, value1);
          };
      };
      return ErrorAtProperty;
  })();

  /**
 *  | A type for foreign type errors
 */  
  var JSONError = (function () {
      function JSONError(value0) {
          this.value0 = value0;
      };
      JSONError.create = function (value0) {
          return new JSONError(value0);
      };
      return JSONError;
  })();
  var showForeignError = new Data_Show.Show(function (v) {
      if (v instanceof ForeignError) {
          return "(ForeignError " + (v.value0 + ")");
      };
      if (v instanceof ErrorAtIndex) {
          return "(ErrorAtIndex " + (Data_Show.show(Data_Show.showInt)(v.value0) + (" " + (Data_Show.show(showForeignError)(v.value1) + ")")));
      };
      if (v instanceof ErrorAtProperty) {
          return "(ErrorAtProperty " + (Data_Show.show(Data_Show.showString)(v.value0) + (" " + (Data_Show.show(showForeignError)(v.value1) + ")")));
      };
      if (v instanceof JSONError) {
          return "(JSONError " + (Data_Show.show(Data_Show.showString)(v.value0) + ")");
      };
      if (v instanceof TypeMismatch) {
          return "(TypeMismatch " + (Data_Show.show(Data_Show.showString)(v.value0) + (" " + (Data_Show.show(Data_Show.showString)(v.value1) + ")")));
      };
      throw new Error("Failed pattern match at Data.Foreign line 65, column 3 - line 66, column 3: " + [ v.constructor.name ]);
  });
  var renderForeignError = function (v) {
      if (v instanceof ForeignError) {
          return v.value0;
      };
      if (v instanceof ErrorAtIndex) {
          return "Error at array index " + (Data_Show.show(Data_Show.showInt)(v.value0) + (": " + Data_Show.show(showForeignError)(v.value1)));
      };
      if (v instanceof ErrorAtProperty) {
          return "Error at property " + (Data_Show.show(Data_Show.showString)(v.value0) + (": " + Data_Show.show(showForeignError)(v.value1)));
      };
      if (v instanceof JSONError) {
          return "JSON error: " + v.value0;
      };
      if (v instanceof TypeMismatch) {
          return "Type mismatch: expected " + (v.value0 + (", found " + v.value1));
      };
      throw new Error("Failed pattern match at Data.Foreign line 75, column 1 - line 75, column 44: " + [ v.constructor.name ]);
  };

  /**
 *  | Throws a failure error in `F`.
 */  
  var fail = function ($112) {
      return Control_Monad_Error_Class.throwError(Control_Monad_Except_Trans.monadErrorExceptT(Data_Identity.monadIdentity))(Data_List_NonEmpty.singleton($112));
  };

  /**
 *  | Attempt to parse a JSON string, returning the result as foreign data.
 */  
  var parseJSON = function (json) {
      return $foreign.parseJSONImpl(function ($113) {
          return fail(JSONError.create($113));
      }, Control_Applicative.pure(Control_Monad_Except_Trans.applicativeExceptT(Data_Identity.monadIdentity)), json);
  };

  /**
 *  | Attempt to coerce a foreign value to an array.
 */  
  var readArray = function (value) {
      if ($foreign.isArray(value)) {
          return Control_Applicative.pure(Control_Monad_Except_Trans.applicativeExceptT(Data_Identity.monadIdentity))($foreign.unsafeFromForeign(value));
      };
      if (Data_Boolean.otherwise) {
          return fail(new TypeMismatch("array", $foreign.tagOf(value)));
      };
      throw new Error("Failed pattern match at Data.Foreign line 149, column 1 - line 151, column 58: " + [ value.constructor.name ]);
  };

  /**
 *  | Unsafely coerce a `Foreign` value when the value has a particular `tagOf`
 *  | value.
 */  
  var unsafeReadTagged = function (tag) {
      return function (value) {
          if ($foreign.tagOf(value) === tag) {
              return Control_Applicative.pure(Control_Monad_Except_Trans.applicativeExceptT(Data_Identity.monadIdentity))($foreign.unsafeFromForeign(value));
          };
          if (Data_Boolean.otherwise) {
              return fail(new TypeMismatch(tag, $foreign.tagOf(value)));
          };
          throw new Error("Failed pattern match at Data.Foreign line 108, column 1 - line 110, column 54: " + [ tag.constructor.name, value.constructor.name ]);
      };
  };

  /**
 *  | Attempt to coerce a foreign value to a `Boolean`.
 */  
  var readBoolean = unsafeReadTagged("Boolean");

  /**
 *  | Attempt to coerce a foreign value to a `Number`.
 */  
  var readNumber = unsafeReadTagged("Number");

  /**
 *  | Attempt to coerce a foreign value to an `Int`.
 */  
  var readInt = function (value) {
      var error = Data_Either.Left.create(Data_List_NonEmpty.singleton(new TypeMismatch("Int", $foreign.tagOf(value))));
      var fromNumber = function ($114) {
          return Data_Maybe.maybe(error)(Control_Applicative.pure(Data_Either.applicativeEither))(Data_Int.fromNumber($114));
      };
      return Control_Monad_Except.mapExcept(Data_Either.either(Data_Function["const"](error))(fromNumber))(readNumber(value));
  };

  /**
 *  | Attempt to coerce a foreign value to a `String`.
 */  
  var readString = unsafeReadTagged("String");

  /**
 *  | Attempt to coerce a foreign value to a `Char`.
 */  
  var readChar = function (value) {
      var error = Data_Either.Left.create(Data_List_NonEmpty.singleton(new TypeMismatch("Char", $foreign.tagOf(value))));
      var fromString = function ($115) {
          return Data_Maybe.maybe(error)(Control_Applicative.pure(Data_Either.applicativeEither))(Data_String.toChar($115));
      };
      return Control_Monad_Except.mapExcept(Data_Either.either(Data_Function["const"](error))(fromString))(readString(value));
  };
  var eqForeignError = new Data_Eq.Eq(function (x) {
      return function (y) {
          if (x instanceof ForeignError && y instanceof ForeignError) {
              return x.value0 === y.value0;
          };
          if (x instanceof TypeMismatch && y instanceof TypeMismatch) {
              return x.value0 === y.value0 && x.value1 === y.value1;
          };
          if (x instanceof ErrorAtIndex && y instanceof ErrorAtIndex) {
              return x.value0 === y.value0 && Data_Eq.eq(eqForeignError)(x.value1)(y.value1);
          };
          if (x instanceof ErrorAtProperty && y instanceof ErrorAtProperty) {
              return x.value0 === y.value0 && Data_Eq.eq(eqForeignError)(x.value1)(y.value1);
          };
          if (x instanceof JSONError && y instanceof JSONError) {
              return x.value0 === y.value0;
          };
          return false;
      };
  });
  var ordForeignError = new Data_Ord.Ord(function () {
      return eqForeignError;
  }, function (x) {
      return function (y) {
          if (x instanceof ForeignError && y instanceof ForeignError) {
              return Data_Ord.compare(Data_Ord.ordString)(x.value0)(y.value0);
          };
          if (x instanceof ForeignError) {
              return Data_Ordering.LT.value;
          };
          if (y instanceof ForeignError) {
              return Data_Ordering.GT.value;
          };
          if (x instanceof TypeMismatch && y instanceof TypeMismatch) {
              var $83 = Data_Ord.compare(Data_Ord.ordString)(x.value0)(y.value0);
              if ($83 instanceof Data_Ordering.LT) {
                  return Data_Ordering.LT.value;
              };
              if ($83 instanceof Data_Ordering.GT) {
                  return Data_Ordering.GT.value;
              };
              return Data_Ord.compare(Data_Ord.ordString)(x.value1)(y.value1);
          };
          if (x instanceof TypeMismatch) {
              return Data_Ordering.LT.value;
          };
          if (y instanceof TypeMismatch) {
              return Data_Ordering.GT.value;
          };
          if (x instanceof ErrorAtIndex && y instanceof ErrorAtIndex) {
              var $92 = Data_Ord.compare(Data_Ord.ordInt)(x.value0)(y.value0);
              if ($92 instanceof Data_Ordering.LT) {
                  return Data_Ordering.LT.value;
              };
              if ($92 instanceof Data_Ordering.GT) {
                  return Data_Ordering.GT.value;
              };
              return Data_Ord.compare(ordForeignError)(x.value1)(y.value1);
          };
          if (x instanceof ErrorAtIndex) {
              return Data_Ordering.LT.value;
          };
          if (y instanceof ErrorAtIndex) {
              return Data_Ordering.GT.value;
          };
          if (x instanceof ErrorAtProperty && y instanceof ErrorAtProperty) {
              var $101 = Data_Ord.compare(Data_Ord.ordString)(x.value0)(y.value0);
              if ($101 instanceof Data_Ordering.LT) {
                  return Data_Ordering.LT.value;
              };
              if ($101 instanceof Data_Ordering.GT) {
                  return Data_Ordering.GT.value;
              };
              return Data_Ord.compare(ordForeignError)(x.value1)(y.value1);
          };
          if (x instanceof ErrorAtProperty) {
              return Data_Ordering.LT.value;
          };
          if (y instanceof ErrorAtProperty) {
              return Data_Ordering.GT.value;
          };
          if (x instanceof JSONError && y instanceof JSONError) {
              return Data_Ord.compare(Data_Ord.ordString)(x.value0)(y.value0);
          };
          throw new Error("Failed pattern match: " + [ x.constructor.name, y.constructor.name ]);
      };
  });
  exports["ForeignError"] = ForeignError;
  exports["TypeMismatch"] = TypeMismatch;
  exports["ErrorAtIndex"] = ErrorAtIndex;
  exports["ErrorAtProperty"] = ErrorAtProperty;
  exports["JSONError"] = JSONError;
  exports["Prop"] = Prop;
  exports["fail"] = fail;
  exports["parseJSON"] = parseJSON;
  exports["readArray"] = readArray;
  exports["readBoolean"] = readBoolean;
  exports["readChar"] = readChar;
  exports["readInt"] = readInt;
  exports["readNumber"] = readNumber;
  exports["readString"] = readString;
  exports["unsafeReadTagged"] = unsafeReadTagged;
  exports["eqForeignError"] = eqForeignError;
  exports["ordForeignError"] = ordForeignError;
  exports["showForeignError"] = showForeignError;
  exports["isArray"] = $foreign.isArray;
  exports["isNull"] = $foreign.isNull;
  exports["isUndefined"] = $foreign.isUndefined;
  exports["tagOf"] = $foreign.tagOf;
  exports["toForeign"] = $foreign.toForeign;
  exports["typeOf"] = $foreign.typeOf;
  exports["unsafeFromForeign"] = $foreign.unsafeFromForeign;
  exports["writeObject"] = $foreign.writeObject;
})(PS["Data.Foreign"] = PS["Data.Foreign"] || {});
(function(exports) {
  /* global exports */
  "use strict";

  // jshint maxparams: 4
  exports.unsafeReadPropImpl = function (f, s, key, value) {
    return value == null ? f : s(value[key]);
  };

  // jshint maxparams: 2
  exports.unsafeHasOwnProperty = function (prop, value) {
    return Object.prototype.hasOwnProperty.call(value, prop);
  };

  exports.unsafeHasProperty = function (prop, value) {
    return prop in value;
  };
})(PS["Data.Foreign.Index"] = PS["Data.Foreign.Index"] || {});
(function(exports) {
  
  /**
 *  | This module defines a type class for types which act like
 *  | _property indices_.
 */  
  "use strict";
  var $foreign = PS["Data.Foreign.Index"];
  var Prelude = PS["Prelude"];
  var Data_Foreign = PS["Data.Foreign"];
  var Data_Function_Uncurried = PS["Data.Function.Uncurried"];
  var Data_Function = PS["Data.Function"];
  var Control_Applicative = PS["Control.Applicative"];
  var Control_Monad_Except_Trans = PS["Control.Monad.Except.Trans"];
  var Data_Identity = PS["Data.Identity"];
  var Data_HeytingAlgebra = PS["Data.HeytingAlgebra"];
  var Data_Eq = PS["Data.Eq"];        

  /**
 *  | This type class identifies types that act like _property indices_.
 *  |
 *  | The canonical instances are for `String`s and `Int`s.
 */  
  var Index = function (errorAt, hasOwnProperty, hasProperty, ix) {
      this.errorAt = errorAt;
      this.hasOwnProperty = hasOwnProperty;
      this.hasProperty = hasProperty;
      this.ix = ix;
  };
  var unsafeReadProp = function (k) {
      return function (value) {
          return $foreign.unsafeReadPropImpl(Data_Foreign.fail(new Data_Foreign.TypeMismatch("object", Data_Foreign.typeOf(value))), Control_Applicative.pure(Control_Monad_Except_Trans.applicativeExceptT(Data_Identity.monadIdentity)), k, value);
      };
  };

  /**
 *  | Attempt to read a value from a foreign value property
 */  
  var prop = unsafeReadProp;

  /**
 *  | This type class identifies types that act like _property indices_.
 *  |
 *  | The canonical instances are for `String`s and `Int`s.
 */  
  var ix = function (dict) {
      return dict.ix;
  };

  /**
 *  | Attempt to read a value from a foreign value at the specified numeric index
 */  
  var index = unsafeReadProp;
  var hasPropertyImpl = function (v) {
      return function (value) {
          if (Data_Foreign.isNull(value)) {
              return false;
          };
          if (Data_Foreign.isUndefined(value)) {
              return false;
          };
          if (Data_Foreign.typeOf(value) === "object" || Data_Foreign.typeOf(value) === "function") {
              return $foreign.unsafeHasProperty(v, value);
          };
          return false;
      };
  };

  /**
 *  | This type class identifies types that act like _property indices_.
 *  |
 *  | The canonical instances are for `String`s and `Int`s.
 */  
  var hasProperty = function (dict) {
      return dict.hasProperty;
  };
  var hasOwnPropertyImpl = function (v) {
      return function (value) {
          if (Data_Foreign.isNull(value)) {
              return false;
          };
          if (Data_Foreign.isUndefined(value)) {
              return false;
          };
          if (Data_Foreign.typeOf(value) === "object" || Data_Foreign.typeOf(value) === "function") {
              return $foreign.unsafeHasOwnProperty(v, value);
          };
          return false;
      };
  };
  var indexInt = new Index(Data_Foreign.ErrorAtIndex.create, hasOwnPropertyImpl, hasPropertyImpl, Data_Function.flip(index));
  var indexString = new Index(Data_Foreign.ErrorAtProperty.create, hasOwnPropertyImpl, hasPropertyImpl, Data_Function.flip(prop));

  /**
 *  | This type class identifies types that act like _property indices_.
 *  |
 *  | The canonical instances are for `String`s and `Int`s.
 */  
  var hasOwnProperty = function (dict) {
      return dict.hasOwnProperty;
  };

  /**
 *  | This type class identifies types that act like _property indices_.
 *  |
 *  | The canonical instances are for `String`s and `Int`s.
 */  
  var errorAt = function (dict) {
      return dict.errorAt;
  };
  exports["Index"] = Index;
  exports["errorAt"] = errorAt;
  exports["hasOwnProperty"] = hasOwnProperty;
  exports["hasProperty"] = hasProperty;
  exports["index"] = index;
  exports["ix"] = ix;
  exports["prop"] = prop;
  exports["indexString"] = indexString;
  exports["indexInt"] = indexInt;
})(PS["Data.Foreign.Index"] = PS["Data.Foreign.Index"] || {});
(function(exports) {
  /* global exports */
  "use strict";

  exports.writeNull = null;
})(PS["Data.Foreign.Null"] = PS["Data.Foreign.Null"] || {});
(function(exports) {
    "use strict";
  var $foreign = PS["Data.Foreign.Null"];
  var Prelude = PS["Prelude"];
  var Data_Maybe = PS["Data.Maybe"];
  var Data_Foreign = PS["Data.Foreign"];
  var Control_Applicative = PS["Control.Applicative"];
  var Control_Monad_Except_Trans = PS["Control.Monad.Except.Trans"];
  var Data_Identity = PS["Data.Identity"];
  var Data_Functor = PS["Data.Functor"];
  var Control_Semigroupoid = PS["Control.Semigroupoid"];        

  /**
 *  | A `newtype` wrapper whose `IsForeign` instance correctly handles
 *  | null values.
 *  |
 *  | Conceptually, this type represents values which may be `null`,
 *  | but not `undefined`.
 */  
  var Null = function (x) {
      return x;
  };

  /**
 *  | Unwrap a `Null` value
 */  
  var unNull = function (v) {
      return v;
  };

  /**
 *  | Read a `Null` value
 */  
  var readNull = function (v) {
      return function (value) {
          if (Data_Foreign.isNull(value)) {
              return Control_Applicative.pure(Control_Monad_Except_Trans.applicativeExceptT(Data_Identity.monadIdentity))(Data_Maybe.Nothing.value);
          };
          return Data_Functor.map(Control_Monad_Except_Trans.functorExceptT(Data_Identity.functorIdentity))(function ($5) {
              return Null(Data_Maybe.Just.create($5));
          })(v(value));
      };
  };
  exports["Null"] = Null;
  exports["readNull"] = readNull;
  exports["unNull"] = unNull;
  exports["writeNull"] = $foreign.writeNull;
})(PS["Data.Foreign.Null"] = PS["Data.Foreign.Null"] || {});
(function(exports) {
    "use strict";
  var Prelude = PS["Prelude"];
  var Data_Maybe = PS["Data.Maybe"];
  var Data_Foreign = PS["Data.Foreign"];
  var Data_HeytingAlgebra = PS["Data.HeytingAlgebra"];
  var Control_Applicative = PS["Control.Applicative"];
  var Control_Monad_Except_Trans = PS["Control.Monad.Except.Trans"];
  var Data_Identity = PS["Data.Identity"];
  var Data_Functor = PS["Data.Functor"];
  var Control_Semigroupoid = PS["Control.Semigroupoid"];        

  /**
 *  | A `newtype` wrapper whose `IsForeign` instance correctly handles
 *  | null and undefined values.
 *  |
 *  | Conceptually, this type represents values which may be `null`
 *  | or `undefined`.
 */  
  var NullOrUndefined = function (x) {
      return x;
  };

  /**
 *  | Unwrap a `NullOrUndefined` value
 */  
  var unNullOrUndefined = function (v) {
      return v;
  };

  /**
 *  | Read a `NullOrUndefined` value
 */  
  var readNullOrUndefined = function (v) {
      return function (value) {
          if (Data_Foreign.isNull(value) || Data_Foreign.isUndefined(value)) {
              return Control_Applicative.pure(Control_Monad_Except_Trans.applicativeExceptT(Data_Identity.monadIdentity))(Data_Maybe.Nothing.value);
          };
          return Data_Functor.map(Control_Monad_Except_Trans.functorExceptT(Data_Identity.functorIdentity))(function ($5) {
              return NullOrUndefined(Data_Maybe.Just.create($5));
          })(v(value));
      };
  };
  exports["NullOrUndefined"] = NullOrUndefined;
  exports["readNullOrUndefined"] = readNullOrUndefined;
  exports["unNullOrUndefined"] = unNullOrUndefined;
})(PS["Data.Foreign.NullOrUndefined"] = PS["Data.Foreign.NullOrUndefined"] || {});
(function(exports) {
  /* global exports */
  "use strict";

  exports.writeUndefined = undefined;
})(PS["Data.Foreign.Undefined"] = PS["Data.Foreign.Undefined"] || {});
(function(exports) {
    "use strict";
  var $foreign = PS["Data.Foreign.Undefined"];
  var Prelude = PS["Prelude"];
  var Data_Maybe = PS["Data.Maybe"];
  var Data_Foreign = PS["Data.Foreign"];
  var Control_Applicative = PS["Control.Applicative"];
  var Control_Monad_Except_Trans = PS["Control.Monad.Except.Trans"];
  var Data_Identity = PS["Data.Identity"];
  var Data_Functor = PS["Data.Functor"];
  var Control_Semigroupoid = PS["Control.Semigroupoid"];        

  /**
 *  | A `newtype` wrapper whose `IsForeign` instance correctly handles
 *  | undefined values.
 *  |
 *  | Conceptually, this type represents values which may be `undefined`,
 *  | but not `null`.
 */  
  var Undefined = function (x) {
      return x;
  };

  /**
 *  | Unwrap an `Undefined` value
 */  
  var unUndefined = function (v) {
      return v;
  };

  /**
 *  | Read an `Undefined` value
 */  
  var readUndefined = function (v) {
      return function (value) {
          if (Data_Foreign.isUndefined(value)) {
              return Control_Applicative.pure(Control_Monad_Except_Trans.applicativeExceptT(Data_Identity.monadIdentity))(Data_Maybe.Nothing.value);
          };
          return Data_Functor.map(Control_Monad_Except_Trans.functorExceptT(Data_Identity.functorIdentity))(function ($5) {
              return Undefined(Data_Maybe.Just.create($5));
          })(v(value));
      };
  };
  exports["Undefined"] = Undefined;
  exports["readUndefined"] = readUndefined;
  exports["unUndefined"] = unUndefined;
  exports["writeUndefined"] = $foreign.writeUndefined;
})(PS["Data.Foreign.Undefined"] = PS["Data.Foreign.Undefined"] || {});
(function(exports) {
  
  /**
 *  | This module defines a type class for reading foreign values.
 */  
  "use strict";
  var Prelude = PS["Prelude"];
  var Control_Alt = PS["Control.Alt"];
  var Control_Monad_Except = PS["Control.Monad.Except"];
  var Data_Array = PS["Data.Array"];
  var Data_Bifunctor = PS["Data.Bifunctor"];
  var Data_Either = PS["Data.Either"];
  var Data_Foreign = PS["Data.Foreign"];
  var Data_Foreign_Index = PS["Data.Foreign.Index"];
  var Data_Foreign_Null = PS["Data.Foreign.Null"];
  var Data_Foreign_NullOrUndefined = PS["Data.Foreign.NullOrUndefined"];
  var Data_Foreign_Undefined = PS["Data.Foreign.Undefined"];
  var Data_Maybe = PS["Data.Maybe"];
  var Data_Traversable = PS["Data.Traversable"];
  var Control_Applicative = PS["Control.Applicative"];
  var Data_Functor = PS["Data.Functor"];
  var Data_Semiring = PS["Data.Semiring"];
  var Control_Bind = PS["Control.Bind"];
  var Control_Category = PS["Control.Category"];
  var Control_Semigroupoid = PS["Control.Semigroupoid"];
  var Control_Monad_Except_Trans = PS["Control.Monad.Except.Trans"];
  var Data_List_Types = PS["Data.List.Types"];
  var Data_Identity = PS["Data.Identity"];        

  /**
 *  | A type class instance for this class can be written for a type if it
 *  | is possible to attempt to _safely_ coerce a `Foreign` value to that
 *  | type.
 *  |
 *  | Instances are provided for standard data structures, and the `F` monad
 *  | can be used to construct instances for new data structures.
 */  
  var IsForeign = function (read) {
      this.read = read;
  };

  /**
 *  | A type class to convert to a `Foreign` value.
 *  |
 *  | Instances are provided for standard data structures.
 */  
  var AsForeign = function (write) {
      this.write = write;
  };

  /**
 *  | A type class to convert to a `Foreign` value.
 *  |
 *  | Instances are provided for standard data structures.
 */  
  var write = function (dict) {
      return dict.write;
  };
  var writeProp = function (dictAsForeign) {
      return function (k) {
          return function (v) {
              return {
                  key: k, 
                  value: write(dictAsForeign)(v)
              };
          };
      };
  };
  var undefinedAsForeign = function (dictAsForeign) {
      return new AsForeign(function (v) {
          return Data_Maybe.maybe(Data_Foreign_Undefined.writeUndefined)(write(dictAsForeign))(v);
      });
  };
  var stringIsForeign = new IsForeign(Data_Foreign.readString);
  var stringAsForeign = new AsForeign(Data_Foreign.toForeign);

  /**
 *  | A type class instance for this class can be written for a type if it
 *  | is possible to attempt to _safely_ coerce a `Foreign` value to that
 *  | type.
 *  |
 *  | Instances are provided for standard data structures, and the `F` monad
 *  | can be used to construct instances for new data structures.
 */  
  var read = function (dict) {
      return dict.read;
  };

  /**
 *  | Attempt to read a value that can be either one thing or another. This
 *  | implementation is left biased.
 */  
  var readEitherL = function (dictIsForeign) {
      return function (dictIsForeign1) {
          return function (value) {
              return Control_Alt.alt(Control_Monad_Except_Trans.altExceptT(Data_List_Types.semigroupNonEmptyList)(Data_Identity.monadIdentity))(Data_Functor.map(Control_Monad_Except_Trans.functorExceptT(Data_Identity.functorIdentity))(Data_Either.Left.create)(read(dictIsForeign)(value)))(Data_Functor.map(Control_Monad_Except_Trans.functorExceptT(Data_Identity.functorIdentity))(Data_Either.Right.create)(read(dictIsForeign1)(value)));
          };
      };
  };

  /**
 *  | Attempt to read a value that can be either one thing or another. This
 *  | implementation is right biased.
 */  
  var readEitherR = function (dictIsForeign) {
      return function (dictIsForeign1) {
          return function (value) {
              return Control_Alt.alt(Control_Monad_Except_Trans.altExceptT(Data_List_Types.semigroupNonEmptyList)(Data_Identity.monadIdentity))(Data_Functor.map(Control_Monad_Except_Trans.functorExceptT(Data_Identity.functorIdentity))(Data_Either.Right.create)(read(dictIsForeign1)(value)))(Data_Functor.map(Control_Monad_Except_Trans.functorExceptT(Data_Identity.functorIdentity))(Data_Either.Left.create)(read(dictIsForeign)(value)));
          };
      };
  };

  /**
 *  | Attempt to read a data structure from a JSON string
 */  
  var readJSON = function (dictIsForeign) {
      return function (json) {
          return Control_Bind.bind(Control_Monad_Except_Trans.bindExceptT(Data_Identity.monadIdentity))(Data_Foreign.parseJSON(json))(read(dictIsForeign));
      };
  };

  /**
 *  | Attempt to read a foreign value, handling errors using the specified function
 */  
  var readWith = function (dictIsForeign) {
      return function (f) {
          return function ($23) {
              return Control_Monad_Except.mapExcept(Data_Bifunctor.lmap(Data_Either.bifunctorEither)(f))(read(dictIsForeign)($23));
          };
      };
  };

  /**
 *  | Attempt to read a property of a foreign value at the specified index
 */  
  var readProp = function (dictIsForeign) {
      return function (dictIndex) {
          return function (prop) {
              return function (value) {
                  return Control_Bind.bind(Control_Monad_Except_Trans.bindExceptT(Data_Identity.monadIdentity))(Data_Foreign_Index.ix(dictIndex)(value)(prop))(readWith(dictIsForeign)(Data_Functor.map(Data_List_Types.functorNonEmptyList)(Data_Foreign_Index.errorAt(dictIndex)(prop))));
              };
          };
      };
  };
  var undefinedIsForeign = function (dictIsForeign) {
      return new IsForeign(Data_Foreign_Undefined.readUndefined(read(dictIsForeign)));
  };
  var numberIsForeign = new IsForeign(Data_Foreign.readNumber);
  var numberAsForeign = new AsForeign(Data_Foreign.toForeign);
  var nullOrUndefinedIsForeign = function (dictIsForeign) {
      return new IsForeign(Data_Foreign_NullOrUndefined.readNullOrUndefined(read(dictIsForeign)));
  };
  var nullIsForeign = function (dictIsForeign) {
      return new IsForeign(Data_Foreign_Null.readNull(read(dictIsForeign)));
  };
  var nullAsForeign = function (dictAsForeign) {
      return new AsForeign(function (v) {
          return Data_Maybe.maybe(Data_Foreign_Null.writeNull)(write(dictAsForeign))(v);
      });
  };
  var nullOrUndefinedAsForeign = function (dictAsForeign) {
      return new AsForeign(function (v) {
          return write(nullAsForeign(dictAsForeign))(v);
      });
  };
  var intIsForeign = new IsForeign(Data_Foreign.readInt);
  var intAsForeign = new AsForeign(Data_Foreign.toForeign);
  var foreignIsForeign = new IsForeign(Control_Applicative.pure(Control_Monad_Except_Trans.applicativeExceptT(Data_Identity.monadIdentity)));
  var foreignAsForeign = new AsForeign(Control_Category.id(Control_Category.categoryFn));
  var charIsForeign = new IsForeign(Data_Foreign.readChar);
  var charAsForeign = new AsForeign(Data_Foreign.toForeign);
  var booleanIsForeign = new IsForeign(Data_Foreign.readBoolean);
  var booleanAsForeign = new AsForeign(Data_Foreign.toForeign);
  var arrayIsForeign = function (dictIsForeign) {
      return new IsForeign(function (value) {
          var readElement = function (i) {
              return function (value1) {
                  return readWith(dictIsForeign)(Data_Functor.map(Data_List_Types.functorNonEmptyList)(Data_Foreign.ErrorAtIndex.create(i)))(value1);
              };
          };
          var readElements = function (arr) {
              return Data_Traversable.sequence(Data_Traversable.traversableArray)(Control_Monad_Except_Trans.applicativeExceptT(Data_Identity.monadIdentity))(Data_Array.zipWith(readElement)(Data_Array.range(0)(Data_Array.length(arr)))(arr));
          };
          return Control_Bind.bind(Control_Monad_Except_Trans.bindExceptT(Data_Identity.monadIdentity))(Data_Foreign.readArray(value))(readElements);
      });
  };
  var arrayAsForeign = function (dictAsForeign) {
      return new AsForeign(function ($24) {
          return Data_Foreign.toForeign(Data_Functor.map(Data_Functor.functorArray)(write(dictAsForeign))($24));
      });
  };
  exports["AsForeign"] = AsForeign;
  exports["IsForeign"] = IsForeign;
  exports["read"] = read;
  exports["readEitherL"] = readEitherL;
  exports["readEitherR"] = readEitherR;
  exports["readJSON"] = readJSON;
  exports["readProp"] = readProp;
  exports["readWith"] = readWith;
  exports["write"] = write;
  exports["writeProp"] = writeProp;
  exports["foreignIsForeign"] = foreignIsForeign;
  exports["stringIsForeign"] = stringIsForeign;
  exports["charIsForeign"] = charIsForeign;
  exports["booleanIsForeign"] = booleanIsForeign;
  exports["numberIsForeign"] = numberIsForeign;
  exports["intIsForeign"] = intIsForeign;
  exports["arrayIsForeign"] = arrayIsForeign;
  exports["nullIsForeign"] = nullIsForeign;
  exports["undefinedIsForeign"] = undefinedIsForeign;
  exports["nullOrUndefinedIsForeign"] = nullOrUndefinedIsForeign;
  exports["foreignAsForeign"] = foreignAsForeign;
  exports["stringAsForeign"] = stringAsForeign;
  exports["charAsForeign"] = charAsForeign;
  exports["booleanAsForeign"] = booleanAsForeign;
  exports["numberAsForeign"] = numberAsForeign;
  exports["intAsForeign"] = intAsForeign;
  exports["arrayAsForeign"] = arrayAsForeign;
  exports["nullAsForeign"] = nullAsForeign;
  exports["undefinedAsForeign"] = undefinedAsForeign;
  exports["nullOrUndefinedAsForeign"] = nullOrUndefinedAsForeign;
})(PS["Data.Foreign.Class"] = PS["Data.Foreign.Class"] || {});
(function(exports) {
  /* global exports */
  "use strict";

  exports.unsafeKeys = Object.keys || function (value) {
    var keys = [];
    for (var prop in value) {
      if (Object.prototype.hasOwnProperty.call(value, prop)) {
        keys.push(prop);
      }
    }
    return keys;
  };
})(PS["Data.Foreign.Keys"] = PS["Data.Foreign.Keys"] || {});
(function(exports) {
  
  /**
 *  | This module provides functions for working with object properties
 *  | of Javascript objects.
 */  
  "use strict";
  var $foreign = PS["Data.Foreign.Keys"];
  var Prelude = PS["Prelude"];
  var Data_Foreign = PS["Data.Foreign"];
  var Data_Function = PS["Data.Function"];
  var Data_Eq = PS["Data.Eq"];
  var Control_Applicative = PS["Control.Applicative"];
  var Control_Monad_Except_Trans = PS["Control.Monad.Except.Trans"];
  var Data_Identity = PS["Data.Identity"];
  var Data_Boolean = PS["Data.Boolean"];        

  /**
 *  | Get an array of the properties defined on a foreign value
 */  
  var keys = function (value) {
      if (Data_Foreign.isNull(value)) {
          return Data_Foreign.fail(new Data_Foreign.TypeMismatch("object", "null"));
      };
      if (Data_Foreign.isUndefined(value)) {
          return Data_Foreign.fail(new Data_Foreign.TypeMismatch("object", "undefined"));
      };
      if (Data_Foreign.typeOf(value) === "object") {
          return Control_Applicative.pure(Control_Monad_Except_Trans.applicativeExceptT(Data_Identity.monadIdentity))($foreign.unsafeKeys(value));
      };
      if (Data_Boolean.otherwise) {
          return Data_Foreign.fail(new Data_Foreign.TypeMismatch("object", Data_Foreign.typeOf(value)));
      };
      throw new Error("Failed pattern match at Data.Foreign.Keys line 16, column 1 - line 20, column 59: " + [ value.constructor.name ]);
  };
  exports["keys"] = keys;
})(PS["Data.Foreign.Keys"] = PS["Data.Foreign.Keys"] || {});
(function(exports) {
    "use strict";
  var Prelude = PS["Prelude"];
  var Control_Alt = PS["Control.Alt"];
  var Control_Alternative = PS["Control.Alternative"];
  var Control_Plus = PS["Control.Plus"];
  var Data_Foldable = PS["Data.Foldable"];
  var Data_Newtype = PS["Data.Newtype"];
  var Data_Traversable = PS["Data.Traversable"];
  var Data_Eq = PS["Data.Eq"];
  var Data_Ord = PS["Data.Ord"];
  var Data_Show = PS["Data.Show"];
  var Data_Semigroup = PS["Data.Semigroup"];
  var Data_Functor = PS["Data.Functor"];
  var Data_Function = PS["Data.Function"];
  var Control_Apply = PS["Control.Apply"];
  var Control_Applicative = PS["Control.Applicative"];
  var Control_Semigroupoid = PS["Control.Semigroupoid"];
  var Control_Category = PS["Control.Category"];        

  /**
 *  | `Compose f g` is the composition of the two functors `f` and `g`.
 */  
  var Compose = function (x) {
      return x;
  };
  var showCompose = function (dictShow) {
      return new Data_Show.Show(function (v) {
          return "(Compose " + (Data_Show.show(dictShow)(v) + ")");
      });
  };
  var ordCompose = function (dictOrd) {
      return dictOrd;
  };
  var newtypeCompose = new Data_Newtype.Newtype(function (n) {
      return n;
  }, Compose);
  var functorCompose = function (dictFunctor) {
      return function (dictFunctor1) {
          return new Data_Functor.Functor(function (f) {
              return function (v) {
                  return Compose(Data_Functor.map(dictFunctor)(Data_Functor.map(dictFunctor1)(f))(v));
              };
          });
      };
  };
  var foldableCompose = function (dictFoldable) {
      return function (dictFoldable1) {
          return new Data_Foldable.Foldable(function (dictMonoid) {
              return function (f) {
                  return function (v) {
                      return Data_Foldable.foldMap(dictFoldable)(dictMonoid)(Data_Foldable.foldMap(dictFoldable1)(dictMonoid)(f))(v);
                  };
              };
          }, function (f) {
              return function (i) {
                  return function (v) {
                      return Data_Foldable.foldl(dictFoldable)(Data_Foldable.foldl(dictFoldable1)(f))(i)(v);
                  };
              };
          }, function (f) {
              return function (i) {
                  return function (v) {
                      return Data_Foldable.foldr(dictFoldable)(Data_Function.flip(Data_Foldable.foldr(dictFoldable1)(f)))(i)(v);
                  };
              };
          });
      };
  };
  var traversableCompose = function (dictTraversable) {
      return function (dictTraversable1) {
          return new Data_Traversable.Traversable(function () {
              return foldableCompose(dictTraversable["__superclass_Data.Foldable.Foldable_1"]())(dictTraversable1["__superclass_Data.Foldable.Foldable_1"]());
          }, function () {
              return functorCompose(dictTraversable["__superclass_Data.Functor.Functor_0"]())(dictTraversable1["__superclass_Data.Functor.Functor_0"]());
          }, function (dictApplicative) {
              return Data_Traversable.traverse(traversableCompose(dictTraversable)(dictTraversable1))(dictApplicative)(Control_Category.id(Control_Category.categoryFn));
          }, function (dictApplicative) {
              return function (f) {
                  return function (v) {
                      return Data_Functor.map((dictApplicative["__superclass_Control.Apply.Apply_0"]())["__superclass_Data.Functor.Functor_0"]())(Compose)(Data_Traversable.traverse(dictTraversable)(dictApplicative)(Data_Traversable.traverse(dictTraversable1)(dictApplicative)(f))(v));
                  };
              };
          });
      };
  };
  var eqCompose = function (dictEq) {
      return dictEq;
  };
  var bihoistCompose = function (dictFunctor) {
      return function (natF) {
          return function (natG) {
              return function (v) {
                  return natF(Data_Functor.map(dictFunctor)(natG)(v));
              };
          };
      };
  };
  var applyCompose = function (dictApply) {
      return function (dictApply1) {
          return new Control_Apply.Apply(function () {
              return functorCompose(dictApply["__superclass_Data.Functor.Functor_0"]())(dictApply1["__superclass_Data.Functor.Functor_0"]());
          }, function (v) {
              return function (v1) {
                  return Compose(Control_Apply.apply(dictApply)(Data_Functor.map(dictApply["__superclass_Data.Functor.Functor_0"]())(Control_Apply.apply(dictApply1))(v))(v1));
              };
          });
      };
  };
  var applicativeCompose = function (dictApplicative) {
      return function (dictApplicative1) {
          return new Control_Applicative.Applicative(function () {
              return applyCompose(dictApplicative["__superclass_Control.Apply.Apply_0"]())(dictApplicative1["__superclass_Control.Apply.Apply_0"]());
          }, function ($57) {
              return Compose(Control_Applicative.pure(dictApplicative)(Control_Applicative.pure(dictApplicative1)($57)));
          });
      };
  };
  var altCompose = function (dictAlt) {
      return function (dictFunctor) {
          return new Control_Alt.Alt(function () {
              return functorCompose(dictAlt["__superclass_Data.Functor.Functor_0"]())(dictFunctor);
          }, function (v) {
              return function (v1) {
                  return Compose(Control_Alt.alt(dictAlt)(v)(v1));
              };
          });
      };
  };
  var plusCompose = function (dictPlus) {
      return function (dictFunctor) {
          return new Control_Plus.Plus(function () {
              return altCompose(dictPlus["__superclass_Control.Alt.Alt_0"]())(dictFunctor);
          }, Control_Plus.empty(dictPlus));
      };
  };
  var alternativeCompose = function (dictAlternative) {
      return function (dictApplicative) {
          return new Control_Alternative.Alternative(function () {
              return applicativeCompose(dictAlternative["__superclass_Control.Applicative.Applicative_0"]())(dictApplicative);
          }, function () {
              return plusCompose(dictAlternative["__superclass_Control.Plus.Plus_1"]())((dictApplicative["__superclass_Control.Apply.Apply_0"]())["__superclass_Data.Functor.Functor_0"]());
          });
      };
  };
  exports["Compose"] = Compose;
  exports["bihoistCompose"] = bihoistCompose;
  exports["newtypeCompose"] = newtypeCompose;
  exports["eqCompose"] = eqCompose;
  exports["ordCompose"] = ordCompose;
  exports["showCompose"] = showCompose;
  exports["functorCompose"] = functorCompose;
  exports["applyCompose"] = applyCompose;
  exports["applicativeCompose"] = applicativeCompose;
  exports["foldableCompose"] = foldableCompose;
  exports["traversableCompose"] = traversableCompose;
  exports["altCompose"] = altCompose;
  exports["plusCompose"] = plusCompose;
  exports["alternativeCompose"] = alternativeCompose;
})(PS["Data.Functor.Compose"] = PS["Data.Functor.Compose"] || {});
(function(exports) {
    "use strict";
  var Prelude = PS["Prelude"];
  var Data_Const = PS["Data.Const"];
  var Data_Either = PS["Data.Either"];
  var Data_Functor_Coproduct = PS["Data.Functor.Coproduct"];
  var Data_Newtype = PS["Data.Newtype"];
  var Data_Void = PS["Data.Void"];        
  var in9 = function (v) {
      return Data_Functor_Coproduct.right(Data_Functor_Coproduct.right(Data_Functor_Coproduct.right(Data_Functor_Coproduct.right(Data_Functor_Coproduct.right(Data_Functor_Coproduct.right(Data_Functor_Coproduct.right(Data_Functor_Coproduct.right(Data_Functor_Coproduct.left(v)))))))));
  };
  var in8 = function (v) {
      return Data_Functor_Coproduct.right(Data_Functor_Coproduct.right(Data_Functor_Coproduct.right(Data_Functor_Coproduct.right(Data_Functor_Coproduct.right(Data_Functor_Coproduct.right(Data_Functor_Coproduct.right(Data_Functor_Coproduct.left(v))))))));
  };
  var in7 = function (v) {
      return Data_Functor_Coproduct.right(Data_Functor_Coproduct.right(Data_Functor_Coproduct.right(Data_Functor_Coproduct.right(Data_Functor_Coproduct.right(Data_Functor_Coproduct.right(Data_Functor_Coproduct.left(v)))))));
  };
  var in6 = function (v) {
      return Data_Functor_Coproduct.right(Data_Functor_Coproduct.right(Data_Functor_Coproduct.right(Data_Functor_Coproduct.right(Data_Functor_Coproduct.right(Data_Functor_Coproduct.left(v))))));
  };
  var in5 = function (v) {
      return Data_Functor_Coproduct.right(Data_Functor_Coproduct.right(Data_Functor_Coproduct.right(Data_Functor_Coproduct.right(Data_Functor_Coproduct.left(v)))));
  };
  var in4 = function (v) {
      return Data_Functor_Coproduct.right(Data_Functor_Coproduct.right(Data_Functor_Coproduct.right(Data_Functor_Coproduct.left(v))));
  };
  var in3 = function (v) {
      return Data_Functor_Coproduct.right(Data_Functor_Coproduct.right(Data_Functor_Coproduct.left(v)));
  };
  var in2 = function (v) {
      return Data_Functor_Coproduct.right(Data_Functor_Coproduct.left(v));
  };
  var in10 = function (v) {
      return Data_Functor_Coproduct.right(Data_Functor_Coproduct.right(Data_Functor_Coproduct.right(Data_Functor_Coproduct.right(Data_Functor_Coproduct.right(Data_Functor_Coproduct.right(Data_Functor_Coproduct.right(Data_Functor_Coproduct.right(Data_Functor_Coproduct.right(Data_Functor_Coproduct.left(v))))))))));
  };
  var in1 = Data_Functor_Coproduct.left;
  var coproduct9 = function (a) {
      return function (b) {
          return function (c) {
              return function (d) {
                  return function (e) {
                      return function (f) {
                          return function (g) {
                              return function (h) {
                                  return function (i) {
                                      return function (y) {
                                          if (y instanceof Data_Either.Left) {
                                              return a(y.value0);
                                          };
                                          if (y instanceof Data_Either.Right) {
                                              if (y.value0 instanceof Data_Either.Left) {
                                                  return b(y.value0.value0);
                                              };
                                              if (y.value0 instanceof Data_Either.Right) {
                                                  if (y.value0.value0 instanceof Data_Either.Left) {
                                                      return c(y.value0.value0.value0);
                                                  };
                                                  if (y.value0.value0 instanceof Data_Either.Right) {
                                                      if (y.value0.value0.value0 instanceof Data_Either.Left) {
                                                          return d(y.value0.value0.value0.value0);
                                                      };
                                                      if (y.value0.value0.value0 instanceof Data_Either.Right) {
                                                          if (y.value0.value0.value0.value0 instanceof Data_Either.Left) {
                                                              return e(y.value0.value0.value0.value0.value0);
                                                          };
                                                          if (y.value0.value0.value0.value0 instanceof Data_Either.Right) {
                                                              if (y.value0.value0.value0.value0.value0 instanceof Data_Either.Left) {
                                                                  return f(y.value0.value0.value0.value0.value0.value0);
                                                              };
                                                              if (y.value0.value0.value0.value0.value0 instanceof Data_Either.Right) {
                                                                  if (y.value0.value0.value0.value0.value0.value0 instanceof Data_Either.Left) {
                                                                      return g(y.value0.value0.value0.value0.value0.value0.value0);
                                                                  };
                                                                  if (y.value0.value0.value0.value0.value0.value0 instanceof Data_Either.Right) {
                                                                      if (y.value0.value0.value0.value0.value0.value0.value0 instanceof Data_Either.Left) {
                                                                          return h(y.value0.value0.value0.value0.value0.value0.value0.value0);
                                                                      };
                                                                      if (y.value0.value0.value0.value0.value0.value0.value0 instanceof Data_Either.Right) {
                                                                          if (y.value0.value0.value0.value0.value0.value0.value0.value0 instanceof Data_Either.Left) {
                                                                              return i(y.value0.value0.value0.value0.value0.value0.value0.value0.value0);
                                                                          };
                                                                          if (y.value0.value0.value0.value0.value0.value0.value0.value0 instanceof Data_Either.Right) {
                                                                              return Data_Void.absurd(Data_Newtype.unwrap(Data_Const.newtypeConst)(y.value0.value0.value0.value0.value0.value0.value0.value0.value0));
                                                                          };
                                                                          throw new Error("Failed pattern match at Data.Functor.Coproduct.Nested line 225, column 41 - line 227, column 61: " + [ y.value0.value0.value0.value0.value0.value0.value0.value0.constructor.name ]);
                                                                      };
                                                                      throw new Error("Failed pattern match at Data.Functor.Coproduct.Nested line 223, column 39 - line 227, column 61: " + [ y.value0.value0.value0.value0.value0.value0.value0.constructor.name ]);
                                                                  };
                                                                  throw new Error("Failed pattern match at Data.Functor.Coproduct.Nested line 221, column 37 - line 227, column 61: " + [ y.value0.value0.value0.value0.value0.value0.constructor.name ]);
                                                              };
                                                              throw new Error("Failed pattern match at Data.Functor.Coproduct.Nested line 219, column 35 - line 227, column 61: " + [ y.value0.value0.value0.value0.value0.constructor.name ]);
                                                          };
                                                          throw new Error("Failed pattern match at Data.Functor.Coproduct.Nested line 217, column 33 - line 227, column 61: " + [ y.value0.value0.value0.value0.constructor.name ]);
                                                      };
                                                      throw new Error("Failed pattern match at Data.Functor.Coproduct.Nested line 215, column 31 - line 227, column 61: " + [ y.value0.value0.value0.constructor.name ]);
                                                  };
                                                  throw new Error("Failed pattern match at Data.Functor.Coproduct.Nested line 213, column 29 - line 227, column 61: " + [ y.value0.value0.constructor.name ]);
                                              };
                                              throw new Error("Failed pattern match at Data.Functor.Coproduct.Nested line 211, column 27 - line 227, column 61: " + [ y.value0.constructor.name ]);
                                          };
                                          throw new Error("Failed pattern match at Data.Functor.Coproduct.Nested line 209, column 34 - line 227, column 61: " + [ y.constructor.name ]);
                                      };
                                  };
                              };
                          };
                      };
                  };
              };
          };
      };
  };
  var coproduct8 = function (a) {
      return function (b) {
          return function (c) {
              return function (d) {
                  return function (e) {
                      return function (f) {
                          return function (g) {
                              return function (h) {
                                  return function (y) {
                                      if (y instanceof Data_Either.Left) {
                                          return a(y.value0);
                                      };
                                      if (y instanceof Data_Either.Right) {
                                          if (y.value0 instanceof Data_Either.Left) {
                                              return b(y.value0.value0);
                                          };
                                          if (y.value0 instanceof Data_Either.Right) {
                                              if (y.value0.value0 instanceof Data_Either.Left) {
                                                  return c(y.value0.value0.value0);
                                              };
                                              if (y.value0.value0 instanceof Data_Either.Right) {
                                                  if (y.value0.value0.value0 instanceof Data_Either.Left) {
                                                      return d(y.value0.value0.value0.value0);
                                                  };
                                                  if (y.value0.value0.value0 instanceof Data_Either.Right) {
                                                      if (y.value0.value0.value0.value0 instanceof Data_Either.Left) {
                                                          return e(y.value0.value0.value0.value0.value0);
                                                      };
                                                      if (y.value0.value0.value0.value0 instanceof Data_Either.Right) {
                                                          if (y.value0.value0.value0.value0.value0 instanceof Data_Either.Left) {
                                                              return f(y.value0.value0.value0.value0.value0.value0);
                                                          };
                                                          if (y.value0.value0.value0.value0.value0 instanceof Data_Either.Right) {
                                                              if (y.value0.value0.value0.value0.value0.value0 instanceof Data_Either.Left) {
                                                                  return g(y.value0.value0.value0.value0.value0.value0.value0);
                                                              };
                                                              if (y.value0.value0.value0.value0.value0.value0 instanceof Data_Either.Right) {
                                                                  if (y.value0.value0.value0.value0.value0.value0.value0 instanceof Data_Either.Left) {
                                                                      return h(y.value0.value0.value0.value0.value0.value0.value0.value0);
                                                                  };
                                                                  if (y.value0.value0.value0.value0.value0.value0.value0 instanceof Data_Either.Right) {
                                                                      return Data_Void.absurd(Data_Newtype.unwrap(Data_Const.newtypeConst)(y.value0.value0.value0.value0.value0.value0.value0.value0));
                                                                  };
                                                                  throw new Error("Failed pattern match at Data.Functor.Coproduct.Nested line 204, column 39 - line 206, column 59: " + [ y.value0.value0.value0.value0.value0.value0.value0.constructor.name ]);
                                                              };
                                                              throw new Error("Failed pattern match at Data.Functor.Coproduct.Nested line 202, column 37 - line 206, column 59: " + [ y.value0.value0.value0.value0.value0.value0.constructor.name ]);
                                                          };
                                                          throw new Error("Failed pattern match at Data.Functor.Coproduct.Nested line 200, column 35 - line 206, column 59: " + [ y.value0.value0.value0.value0.value0.constructor.name ]);
                                                      };
                                                      throw new Error("Failed pattern match at Data.Functor.Coproduct.Nested line 198, column 33 - line 206, column 59: " + [ y.value0.value0.value0.value0.constructor.name ]);
                                                  };
                                                  throw new Error("Failed pattern match at Data.Functor.Coproduct.Nested line 196, column 31 - line 206, column 59: " + [ y.value0.value0.value0.constructor.name ]);
                                              };
                                              throw new Error("Failed pattern match at Data.Functor.Coproduct.Nested line 194, column 29 - line 206, column 59: " + [ y.value0.value0.constructor.name ]);
                                          };
                                          throw new Error("Failed pattern match at Data.Functor.Coproduct.Nested line 192, column 27 - line 206, column 59: " + [ y.value0.constructor.name ]);
                                      };
                                      throw new Error("Failed pattern match at Data.Functor.Coproduct.Nested line 190, column 32 - line 206, column 59: " + [ y.constructor.name ]);
                                  };
                              };
                          };
                      };
                  };
              };
          };
      };
  };
  var coproduct7 = function (a) {
      return function (b) {
          return function (c) {
              return function (d) {
                  return function (e) {
                      return function (f) {
                          return function (g) {
                              return function (y) {
                                  if (y instanceof Data_Either.Left) {
                                      return a(y.value0);
                                  };
                                  if (y instanceof Data_Either.Right) {
                                      if (y.value0 instanceof Data_Either.Left) {
                                          return b(y.value0.value0);
                                      };
                                      if (y.value0 instanceof Data_Either.Right) {
                                          if (y.value0.value0 instanceof Data_Either.Left) {
                                              return c(y.value0.value0.value0);
                                          };
                                          if (y.value0.value0 instanceof Data_Either.Right) {
                                              if (y.value0.value0.value0 instanceof Data_Either.Left) {
                                                  return d(y.value0.value0.value0.value0);
                                              };
                                              if (y.value0.value0.value0 instanceof Data_Either.Right) {
                                                  if (y.value0.value0.value0.value0 instanceof Data_Either.Left) {
                                                      return e(y.value0.value0.value0.value0.value0);
                                                  };
                                                  if (y.value0.value0.value0.value0 instanceof Data_Either.Right) {
                                                      if (y.value0.value0.value0.value0.value0 instanceof Data_Either.Left) {
                                                          return f(y.value0.value0.value0.value0.value0.value0);
                                                      };
                                                      if (y.value0.value0.value0.value0.value0 instanceof Data_Either.Right) {
                                                          if (y.value0.value0.value0.value0.value0.value0 instanceof Data_Either.Left) {
                                                              return g(y.value0.value0.value0.value0.value0.value0.value0);
                                                          };
                                                          if (y.value0.value0.value0.value0.value0.value0 instanceof Data_Either.Right) {
                                                              return Data_Void.absurd(Data_Newtype.unwrap(Data_Const.newtypeConst)(y.value0.value0.value0.value0.value0.value0.value0));
                                                          };
                                                          throw new Error("Failed pattern match at Data.Functor.Coproduct.Nested line 185, column 37 - line 187, column 57: " + [ y.value0.value0.value0.value0.value0.value0.constructor.name ]);
                                                      };
                                                      throw new Error("Failed pattern match at Data.Functor.Coproduct.Nested line 183, column 35 - line 187, column 57: " + [ y.value0.value0.value0.value0.value0.constructor.name ]);
                                                  };
                                                  throw new Error("Failed pattern match at Data.Functor.Coproduct.Nested line 181, column 33 - line 187, column 57: " + [ y.value0.value0.value0.value0.constructor.name ]);
                                              };
                                              throw new Error("Failed pattern match at Data.Functor.Coproduct.Nested line 179, column 31 - line 187, column 57: " + [ y.value0.value0.value0.constructor.name ]);
                                          };
                                          throw new Error("Failed pattern match at Data.Functor.Coproduct.Nested line 177, column 29 - line 187, column 57: " + [ y.value0.value0.constructor.name ]);
                                      };
                                      throw new Error("Failed pattern match at Data.Functor.Coproduct.Nested line 175, column 27 - line 187, column 57: " + [ y.value0.constructor.name ]);
                                  };
                                  throw new Error("Failed pattern match at Data.Functor.Coproduct.Nested line 173, column 30 - line 187, column 57: " + [ y.constructor.name ]);
                              };
                          };
                      };
                  };
              };
          };
      };
  };
  var coproduct6 = function (a) {
      return function (b) {
          return function (c) {
              return function (d) {
                  return function (e) {
                      return function (f) {
                          return function (y) {
                              if (y instanceof Data_Either.Left) {
                                  return a(y.value0);
                              };
                              if (y instanceof Data_Either.Right) {
                                  if (y.value0 instanceof Data_Either.Left) {
                                      return b(y.value0.value0);
                                  };
                                  if (y.value0 instanceof Data_Either.Right) {
                                      if (y.value0.value0 instanceof Data_Either.Left) {
                                          return c(y.value0.value0.value0);
                                      };
                                      if (y.value0.value0 instanceof Data_Either.Right) {
                                          if (y.value0.value0.value0 instanceof Data_Either.Left) {
                                              return d(y.value0.value0.value0.value0);
                                          };
                                          if (y.value0.value0.value0 instanceof Data_Either.Right) {
                                              if (y.value0.value0.value0.value0 instanceof Data_Either.Left) {
                                                  return e(y.value0.value0.value0.value0.value0);
                                              };
                                              if (y.value0.value0.value0.value0 instanceof Data_Either.Right) {
                                                  if (y.value0.value0.value0.value0.value0 instanceof Data_Either.Left) {
                                                      return f(y.value0.value0.value0.value0.value0.value0);
                                                  };
                                                  if (y.value0.value0.value0.value0.value0 instanceof Data_Either.Right) {
                                                      return Data_Void.absurd(Data_Newtype.unwrap(Data_Const.newtypeConst)(y.value0.value0.value0.value0.value0.value0));
                                                  };
                                                  throw new Error("Failed pattern match at Data.Functor.Coproduct.Nested line 168, column 35 - line 170, column 55: " + [ y.value0.value0.value0.value0.value0.constructor.name ]);
                                              };
                                              throw new Error("Failed pattern match at Data.Functor.Coproduct.Nested line 166, column 33 - line 170, column 55: " + [ y.value0.value0.value0.value0.constructor.name ]);
                                          };
                                          throw new Error("Failed pattern match at Data.Functor.Coproduct.Nested line 164, column 31 - line 170, column 55: " + [ y.value0.value0.value0.constructor.name ]);
                                      };
                                      throw new Error("Failed pattern match at Data.Functor.Coproduct.Nested line 162, column 29 - line 170, column 55: " + [ y.value0.value0.constructor.name ]);
                                  };
                                  throw new Error("Failed pattern match at Data.Functor.Coproduct.Nested line 160, column 27 - line 170, column 55: " + [ y.value0.constructor.name ]);
                              };
                              throw new Error("Failed pattern match at Data.Functor.Coproduct.Nested line 158, column 28 - line 170, column 55: " + [ y.constructor.name ]);
                          };
                      };
                  };
              };
          };
      };
  };
  var coproduct5 = function (a) {
      return function (b) {
          return function (c) {
              return function (d) {
                  return function (e) {
                      return function (y) {
                          if (y instanceof Data_Either.Left) {
                              return a(y.value0);
                          };
                          if (y instanceof Data_Either.Right) {
                              if (y.value0 instanceof Data_Either.Left) {
                                  return b(y.value0.value0);
                              };
                              if (y.value0 instanceof Data_Either.Right) {
                                  if (y.value0.value0 instanceof Data_Either.Left) {
                                      return c(y.value0.value0.value0);
                                  };
                                  if (y.value0.value0 instanceof Data_Either.Right) {
                                      if (y.value0.value0.value0 instanceof Data_Either.Left) {
                                          return d(y.value0.value0.value0.value0);
                                      };
                                      if (y.value0.value0.value0 instanceof Data_Either.Right) {
                                          if (y.value0.value0.value0.value0 instanceof Data_Either.Left) {
                                              return e(y.value0.value0.value0.value0.value0);
                                          };
                                          if (y.value0.value0.value0.value0 instanceof Data_Either.Right) {
                                              return Data_Void.absurd(Data_Newtype.unwrap(Data_Const.newtypeConst)(y.value0.value0.value0.value0.value0));
                                          };
                                          throw new Error("Failed pattern match at Data.Functor.Coproduct.Nested line 153, column 33 - line 155, column 53: " + [ y.value0.value0.value0.value0.constructor.name ]);
                                      };
                                      throw new Error("Failed pattern match at Data.Functor.Coproduct.Nested line 151, column 31 - line 155, column 53: " + [ y.value0.value0.value0.constructor.name ]);
                                  };
                                  throw new Error("Failed pattern match at Data.Functor.Coproduct.Nested line 149, column 29 - line 155, column 53: " + [ y.value0.value0.constructor.name ]);
                              };
                              throw new Error("Failed pattern match at Data.Functor.Coproduct.Nested line 147, column 27 - line 155, column 53: " + [ y.value0.constructor.name ]);
                          };
                          throw new Error("Failed pattern match at Data.Functor.Coproduct.Nested line 145, column 26 - line 155, column 53: " + [ y.constructor.name ]);
                      };
                  };
              };
          };
      };
  };
  var coproduct4 = function (a) {
      return function (b) {
          return function (c) {
              return function (d) {
                  return function (y) {
                      if (y instanceof Data_Either.Left) {
                          return a(y.value0);
                      };
                      if (y instanceof Data_Either.Right) {
                          if (y.value0 instanceof Data_Either.Left) {
                              return b(y.value0.value0);
                          };
                          if (y.value0 instanceof Data_Either.Right) {
                              if (y.value0.value0 instanceof Data_Either.Left) {
                                  return c(y.value0.value0.value0);
                              };
                              if (y.value0.value0 instanceof Data_Either.Right) {
                                  if (y.value0.value0.value0 instanceof Data_Either.Left) {
                                      return d(y.value0.value0.value0.value0);
                                  };
                                  if (y.value0.value0.value0 instanceof Data_Either.Right) {
                                      return Data_Void.absurd(Data_Newtype.unwrap(Data_Const.newtypeConst)(y.value0.value0.value0.value0));
                                  };
                                  throw new Error("Failed pattern match at Data.Functor.Coproduct.Nested line 140, column 31 - line 142, column 51: " + [ y.value0.value0.value0.constructor.name ]);
                              };
                              throw new Error("Failed pattern match at Data.Functor.Coproduct.Nested line 138, column 29 - line 142, column 51: " + [ y.value0.value0.constructor.name ]);
                          };
                          throw new Error("Failed pattern match at Data.Functor.Coproduct.Nested line 136, column 27 - line 142, column 51: " + [ y.value0.constructor.name ]);
                      };
                      throw new Error("Failed pattern match at Data.Functor.Coproduct.Nested line 134, column 24 - line 142, column 51: " + [ y.constructor.name ]);
                  };
              };
          };
      };
  };
  var coproduct3 = function (a) {
      return function (b) {
          return function (c) {
              return function (y) {
                  if (y instanceof Data_Either.Left) {
                      return a(y.value0);
                  };
                  if (y instanceof Data_Either.Right) {
                      if (y.value0 instanceof Data_Either.Left) {
                          return b(y.value0.value0);
                      };
                      if (y.value0 instanceof Data_Either.Right) {
                          if (y.value0.value0 instanceof Data_Either.Left) {
                              return c(y.value0.value0.value0);
                          };
                          if (y.value0.value0 instanceof Data_Either.Right) {
                              return Data_Void.absurd(Data_Newtype.unwrap(Data_Const.newtypeConst)(y.value0.value0.value0));
                          };
                          throw new Error("Failed pattern match at Data.Functor.Coproduct.Nested line 129, column 29 - line 131, column 49: " + [ y.value0.value0.constructor.name ]);
                      };
                      throw new Error("Failed pattern match at Data.Functor.Coproduct.Nested line 127, column 27 - line 131, column 49: " + [ y.value0.constructor.name ]);
                  };
                  throw new Error("Failed pattern match at Data.Functor.Coproduct.Nested line 125, column 22 - line 131, column 49: " + [ y.constructor.name ]);
              };
          };
      };
  };
  var coproduct2 = function (a) {
      return function (b) {
          return function (y) {
              if (y instanceof Data_Either.Left) {
                  return a(y.value0);
              };
              if (y instanceof Data_Either.Right) {
                  if (y.value0 instanceof Data_Either.Left) {
                      return b(y.value0.value0);
                  };
                  if (y.value0 instanceof Data_Either.Right) {
                      return Data_Void.absurd(Data_Newtype.unwrap(Data_Const.newtypeConst)(y.value0.value0));
                  };
                  throw new Error("Failed pattern match at Data.Functor.Coproduct.Nested line 120, column 27 - line 122, column 47: " + [ y.value0.constructor.name ]);
              };
              throw new Error("Failed pattern match at Data.Functor.Coproduct.Nested line 118, column 20 - line 122, column 47: " + [ y.constructor.name ]);
          };
      };
  };
  var coproduct10 = function (a) {
      return function (b) {
          return function (c) {
              return function (d) {
                  return function (e) {
                      return function (f) {
                          return function (g) {
                              return function (h) {
                                  return function (i) {
                                      return function (j) {
                                          return function (y) {
                                              if (y instanceof Data_Either.Left) {
                                                  return a(y.value0);
                                              };
                                              if (y instanceof Data_Either.Right) {
                                                  if (y.value0 instanceof Data_Either.Left) {
                                                      return b(y.value0.value0);
                                                  };
                                                  if (y.value0 instanceof Data_Either.Right) {
                                                      if (y.value0.value0 instanceof Data_Either.Left) {
                                                          return c(y.value0.value0.value0);
                                                      };
                                                      if (y.value0.value0 instanceof Data_Either.Right) {
                                                          if (y.value0.value0.value0 instanceof Data_Either.Left) {
                                                              return d(y.value0.value0.value0.value0);
                                                          };
                                                          if (y.value0.value0.value0 instanceof Data_Either.Right) {
                                                              if (y.value0.value0.value0.value0 instanceof Data_Either.Left) {
                                                                  return e(y.value0.value0.value0.value0.value0);
                                                              };
                                                              if (y.value0.value0.value0.value0 instanceof Data_Either.Right) {
                                                                  if (y.value0.value0.value0.value0.value0 instanceof Data_Either.Left) {
                                                                      return f(y.value0.value0.value0.value0.value0.value0);
                                                                  };
                                                                  if (y.value0.value0.value0.value0.value0 instanceof Data_Either.Right) {
                                                                      if (y.value0.value0.value0.value0.value0.value0 instanceof Data_Either.Left) {
                                                                          return g(y.value0.value0.value0.value0.value0.value0.value0);
                                                                      };
                                                                      if (y.value0.value0.value0.value0.value0.value0 instanceof Data_Either.Right) {
                                                                          if (y.value0.value0.value0.value0.value0.value0.value0 instanceof Data_Either.Left) {
                                                                              return h(y.value0.value0.value0.value0.value0.value0.value0.value0);
                                                                          };
                                                                          if (y.value0.value0.value0.value0.value0.value0.value0 instanceof Data_Either.Right) {
                                                                              if (y.value0.value0.value0.value0.value0.value0.value0.value0 instanceof Data_Either.Left) {
                                                                                  return i(y.value0.value0.value0.value0.value0.value0.value0.value0.value0);
                                                                              };
                                                                              if (y.value0.value0.value0.value0.value0.value0.value0.value0 instanceof Data_Either.Right) {
                                                                                  if (y.value0.value0.value0.value0.value0.value0.value0.value0.value0 instanceof Data_Either.Left) {
                                                                                      return j(y.value0.value0.value0.value0.value0.value0.value0.value0.value0.value0);
                                                                                  };
                                                                                  if (y.value0.value0.value0.value0.value0.value0.value0.value0.value0 instanceof Data_Either.Right) {
                                                                                      return Data_Void.absurd(Data_Newtype.unwrap(Data_Const.newtypeConst)(y.value0.value0.value0.value0.value0.value0.value0.value0.value0.value0));
                                                                                  };
                                                                                  throw new Error("Failed pattern match at Data.Functor.Coproduct.Nested line 248, column 43 - line 250, column 64: " + [ y.value0.value0.value0.value0.value0.value0.value0.value0.value0.constructor.name ]);
                                                                              };
                                                                              throw new Error("Failed pattern match at Data.Functor.Coproduct.Nested line 246, column 41 - line 250, column 64: " + [ y.value0.value0.value0.value0.value0.value0.value0.value0.constructor.name ]);
                                                                          };
                                                                          throw new Error("Failed pattern match at Data.Functor.Coproduct.Nested line 244, column 39 - line 250, column 64: " + [ y.value0.value0.value0.value0.value0.value0.value0.constructor.name ]);
                                                                      };
                                                                      throw new Error("Failed pattern match at Data.Functor.Coproduct.Nested line 242, column 37 - line 250, column 64: " + [ y.value0.value0.value0.value0.value0.value0.constructor.name ]);
                                                                  };
                                                                  throw new Error("Failed pattern match at Data.Functor.Coproduct.Nested line 240, column 35 - line 250, column 64: " + [ y.value0.value0.value0.value0.value0.constructor.name ]);
                                                              };
                                                              throw new Error("Failed pattern match at Data.Functor.Coproduct.Nested line 238, column 33 - line 250, column 64: " + [ y.value0.value0.value0.value0.constructor.name ]);
                                                          };
                                                          throw new Error("Failed pattern match at Data.Functor.Coproduct.Nested line 236, column 31 - line 250, column 64: " + [ y.value0.value0.value0.constructor.name ]);
                                                      };
                                                      throw new Error("Failed pattern match at Data.Functor.Coproduct.Nested line 234, column 29 - line 250, column 64: " + [ y.value0.value0.constructor.name ]);
                                                  };
                                                  throw new Error("Failed pattern match at Data.Functor.Coproduct.Nested line 232, column 27 - line 250, column 64: " + [ y.value0.constructor.name ]);
                                              };
                                              throw new Error("Failed pattern match at Data.Functor.Coproduct.Nested line 230, column 37 - line 250, column 64: " + [ y.constructor.name ]);
                                          };
                                      };
                                  };
                              };
                          };
                      };
                  };
              };
          };
      };
  };
  var coproduct1 = function (y) {
      if (y instanceof Data_Either.Left) {
          return y.value0;
      };
      if (y instanceof Data_Either.Right) {
          return Data_Void.absurd(Data_Newtype.unwrap(Data_Const.newtypeConst)(y.value0));
      };
      throw new Error("Failed pattern match at Data.Functor.Coproduct.Nested line 113, column 16 - line 115, column 45: " + [ y.constructor.name ]);
  };
  var at9 = function (b) {
      return function (f) {
          return function (y) {
              if (y instanceof Data_Either.Right && (y.value0 instanceof Data_Either.Right && (y.value0.value0 instanceof Data_Either.Right && (y.value0.value0.value0 instanceof Data_Either.Right && (y.value0.value0.value0.value0 instanceof Data_Either.Right && (y.value0.value0.value0.value0.value0 instanceof Data_Either.Right && (y.value0.value0.value0.value0.value0.value0 instanceof Data_Either.Right && (y.value0.value0.value0.value0.value0.value0.value0 instanceof Data_Either.Right && y.value0.value0.value0.value0.value0.value0.value0.value0 instanceof Data_Either.Left)))))))) {
                  return f(y.value0.value0.value0.value0.value0.value0.value0.value0.value0);
              };
              return b;
          };
      };
  };
  var at8 = function (b) {
      return function (f) {
          return function (y) {
              if (y instanceof Data_Either.Right && (y.value0 instanceof Data_Either.Right && (y.value0.value0 instanceof Data_Either.Right && (y.value0.value0.value0 instanceof Data_Either.Right && (y.value0.value0.value0.value0 instanceof Data_Either.Right && (y.value0.value0.value0.value0.value0 instanceof Data_Either.Right && (y.value0.value0.value0.value0.value0.value0 instanceof Data_Either.Right && y.value0.value0.value0.value0.value0.value0.value0 instanceof Data_Either.Left))))))) {
                  return f(y.value0.value0.value0.value0.value0.value0.value0.value0);
              };
              return b;
          };
      };
  };
  var at7 = function (b) {
      return function (f) {
          return function (y) {
              if (y instanceof Data_Either.Right && (y.value0 instanceof Data_Either.Right && (y.value0.value0 instanceof Data_Either.Right && (y.value0.value0.value0 instanceof Data_Either.Right && (y.value0.value0.value0.value0 instanceof Data_Either.Right && (y.value0.value0.value0.value0.value0 instanceof Data_Either.Right && y.value0.value0.value0.value0.value0.value0 instanceof Data_Either.Left)))))) {
                  return f(y.value0.value0.value0.value0.value0.value0.value0);
              };
              return b;
          };
      };
  };
  var at6 = function (b) {
      return function (f) {
          return function (y) {
              if (y instanceof Data_Either.Right && (y.value0 instanceof Data_Either.Right && (y.value0.value0 instanceof Data_Either.Right && (y.value0.value0.value0 instanceof Data_Either.Right && (y.value0.value0.value0.value0 instanceof Data_Either.Right && y.value0.value0.value0.value0.value0 instanceof Data_Either.Left))))) {
                  return f(y.value0.value0.value0.value0.value0.value0);
              };
              return b;
          };
      };
  };
  var at5 = function (b) {
      return function (f) {
          return function (y) {
              if (y instanceof Data_Either.Right && (y.value0 instanceof Data_Either.Right && (y.value0.value0 instanceof Data_Either.Right && (y.value0.value0.value0 instanceof Data_Either.Right && y.value0.value0.value0.value0 instanceof Data_Either.Left)))) {
                  return f(y.value0.value0.value0.value0.value0);
              };
              return b;
          };
      };
  };
  var at4 = function (b) {
      return function (f) {
          return function (y) {
              if (y instanceof Data_Either.Right && (y.value0 instanceof Data_Either.Right && (y.value0.value0 instanceof Data_Either.Right && y.value0.value0.value0 instanceof Data_Either.Left))) {
                  return f(y.value0.value0.value0.value0);
              };
              return b;
          };
      };
  };
  var at3 = function (b) {
      return function (f) {
          return function (y) {
              if (y instanceof Data_Either.Right && (y.value0 instanceof Data_Either.Right && y.value0.value0 instanceof Data_Either.Left)) {
                  return f(y.value0.value0.value0);
              };
              return b;
          };
      };
  };
  var at2 = function (b) {
      return function (f) {
          return function (y) {
              if (y instanceof Data_Either.Right && y.value0 instanceof Data_Either.Left) {
                  return f(y.value0.value0);
              };
              return b;
          };
      };
  };
  var at10 = function (b) {
      return function (f) {
          return function (y) {
              if (y instanceof Data_Either.Right && (y.value0 instanceof Data_Either.Right && (y.value0.value0 instanceof Data_Either.Right && (y.value0.value0.value0 instanceof Data_Either.Right && (y.value0.value0.value0.value0 instanceof Data_Either.Right && (y.value0.value0.value0.value0.value0 instanceof Data_Either.Right && (y.value0.value0.value0.value0.value0.value0 instanceof Data_Either.Right && (y.value0.value0.value0.value0.value0.value0.value0 instanceof Data_Either.Right && (y.value0.value0.value0.value0.value0.value0.value0.value0 instanceof Data_Either.Right && y.value0.value0.value0.value0.value0.value0.value0.value0.value0 instanceof Data_Either.Left))))))))) {
                  return f(y.value0.value0.value0.value0.value0.value0.value0.value0.value0.value0);
              };
              return b;
          };
      };
  };
  var at1 = function (b) {
      return function (f) {
          return function (y) {
              if (y instanceof Data_Either.Left) {
                  return f(y.value0);
              };
              return b;
          };
      };
  };
  exports["at1"] = at1;
  exports["at10"] = at10;
  exports["at2"] = at2;
  exports["at3"] = at3;
  exports["at4"] = at4;
  exports["at5"] = at5;
  exports["at6"] = at6;
  exports["at7"] = at7;
  exports["at8"] = at8;
  exports["at9"] = at9;
  exports["coproduct1"] = coproduct1;
  exports["coproduct10"] = coproduct10;
  exports["coproduct2"] = coproduct2;
  exports["coproduct3"] = coproduct3;
  exports["coproduct4"] = coproduct4;
  exports["coproduct5"] = coproduct5;
  exports["coproduct6"] = coproduct6;
  exports["coproduct7"] = coproduct7;
  exports["coproduct8"] = coproduct8;
  exports["coproduct9"] = coproduct9;
  exports["in1"] = in1;
  exports["in10"] = in10;
  exports["in2"] = in2;
  exports["in3"] = in3;
  exports["in4"] = in4;
  exports["in5"] = in5;
  exports["in6"] = in6;
  exports["in7"] = in7;
  exports["in8"] = in8;
  exports["in9"] = in9;
})(PS["Data.Functor.Coproduct.Nested"] = PS["Data.Functor.Coproduct.Nested"] || {});
(function(exports) {
    "use strict";
  var Prelude = PS["Prelude"];
  var Control_Apply = PS["Control.Apply"];
  var Data_Bifunctor = PS["Data.Bifunctor"];
  var Data_Foldable = PS["Data.Foldable"];
  var Data_Newtype = PS["Data.Newtype"];
  var Data_Traversable = PS["Data.Traversable"];
  var Data_Tuple = PS["Data.Tuple"];
  var Data_Eq = PS["Data.Eq"];
  var Data_Ord = PS["Data.Ord"];
  var Data_Show = PS["Data.Show"];
  var Data_Semigroup = PS["Data.Semigroup"];
  var Data_Functor = PS["Data.Functor"];
  var Control_Applicative = PS["Control.Applicative"];
  var Control_Bind = PS["Control.Bind"];
  var Control_Semigroupoid = PS["Control.Semigroupoid"];
  var Control_Monad = PS["Control.Monad"];        

  /**
 *  | `Product f g` is the product of the two functors `f` and `g`.
 */  
  var Product = function (x) {
      return x;
  };
  var showProduct = function (dictShow) {
      return function (dictShow1) {
          return new Data_Show.Show(function (v) {
              return "(product " + (Data_Show.show(dictShow)(v.value0) + (" " + (Data_Show.show(dictShow1)(v.value1) + ")")));
          });
      };
  };

  /**
 *  | Create a product.
 */  
  var product = function (fa) {
      return function (ga) {
          return new Data_Tuple.Tuple(fa, ga);
      };
  };
  var newtypeProduct = new Data_Newtype.Newtype(function (n) {
      return n;
  }, Product);
  var functorProduct = function (dictFunctor) {
      return function (dictFunctor1) {
          return new Data_Functor.Functor(function (f) {
              return function (v) {
                  return Data_Bifunctor.bimap(Data_Tuple.bifunctorTuple)(Data_Functor.map(dictFunctor)(f))(Data_Functor.map(dictFunctor1)(f))(v);
              };
          });
      };
  };
  var foldableProduct = function (dictFoldable) {
      return function (dictFoldable1) {
          return new Data_Foldable.Foldable(function (dictMonoid) {
              return function (f) {
                  return function (v) {
                      return Data_Semigroup.append(dictMonoid["__superclass_Data.Semigroup.Semigroup_0"]())(Data_Foldable.foldMap(dictFoldable)(dictMonoid)(f)(v.value0))(Data_Foldable.foldMap(dictFoldable1)(dictMonoid)(f)(v.value1));
                  };
              };
          }, function (f) {
              return function (z) {
                  return function (v) {
                      return Data_Foldable.foldl(dictFoldable1)(f)(Data_Foldable.foldl(dictFoldable)(f)(z)(v.value0))(v.value1);
                  };
              };
          }, function (f) {
              return function (z) {
                  return function (v) {
                      return Data_Foldable.foldr(dictFoldable)(f)(Data_Foldable.foldr(dictFoldable1)(f)(z)(v.value1))(v.value0);
                  };
              };
          });
      };
  };
  var traversableProduct = function (dictTraversable) {
      return function (dictTraversable1) {
          return new Data_Traversable.Traversable(function () {
              return foldableProduct(dictTraversable["__superclass_Data.Foldable.Foldable_1"]())(dictTraversable1["__superclass_Data.Foldable.Foldable_1"]());
          }, function () {
              return functorProduct(dictTraversable["__superclass_Data.Functor.Functor_0"]())(dictTraversable1["__superclass_Data.Functor.Functor_0"]());
          }, function (dictApplicative) {
              return function (v) {
                  return Control_Apply.lift2(dictApplicative["__superclass_Control.Apply.Apply_0"]())(product)(Data_Traversable.sequence(dictTraversable)(dictApplicative)(v.value0))(Data_Traversable.sequence(dictTraversable1)(dictApplicative)(v.value1));
              };
          }, function (dictApplicative) {
              return function (f) {
                  return function (v) {
                      return Control_Apply.lift2(dictApplicative["__superclass_Control.Apply.Apply_0"]())(product)(Data_Traversable.traverse(dictTraversable)(dictApplicative)(f)(v.value0))(Data_Traversable.traverse(dictTraversable1)(dictApplicative)(f)(v.value1));
                  };
              };
          });
      };
  };
  var eqProduct = function (dictEq) {
      return function (dictEq1) {
          return new Data_Eq.Eq(function (x) {
              return function (y) {
                  return Data_Eq.eq(Data_Tuple.eqTuple(dictEq)(dictEq1))(x)(y);
              };
          });
      };
  };
  var ordProduct = function (dictOrd) {
      return function (dictOrd1) {
          return new Data_Ord.Ord(function () {
              return eqProduct(dictOrd["__superclass_Data.Eq.Eq_0"]())(dictOrd1["__superclass_Data.Eq.Eq_0"]());
          }, function (x) {
              return function (y) {
                  return Data_Ord.compare(Data_Tuple.ordTuple(dictOrd)(dictOrd1))(x)(y);
              };
          });
      };
  };
  var bihoistProduct = function (natF) {
      return function (natG) {
          return function (v) {
              return Data_Bifunctor.bimap(Data_Tuple.bifunctorTuple)(natF)(natG)(v);
          };
      };
  };
  var applyProduct = function (dictApply) {
      return function (dictApply1) {
          return new Control_Apply.Apply(function () {
              return functorProduct(dictApply["__superclass_Data.Functor.Functor_0"]())(dictApply1["__superclass_Data.Functor.Functor_0"]());
          }, function (v) {
              return function (v1) {
                  return product(Control_Apply.apply(dictApply)(v.value0)(v1.value0))(Control_Apply.apply(dictApply1)(v.value1)(v1.value1));
              };
          });
      };
  };
  var bindProduct = function (dictBind) {
      return function (dictBind1) {
          return new Control_Bind.Bind(function () {
              return applyProduct(dictBind["__superclass_Control.Apply.Apply_0"]())(dictBind1["__superclass_Control.Apply.Apply_0"]());
          }, function (v) {
              return function (f) {
                  return product(Control_Bind.bind(dictBind)(v.value0)(function ($88) {
                      return Data_Tuple.fst(Data_Newtype.unwrap(newtypeProduct)(f($88)));
                  }))(Control_Bind.bind(dictBind1)(v.value1)(function ($89) {
                      return Data_Tuple.snd(Data_Newtype.unwrap(newtypeProduct)(f($89)));
                  }));
              };
          });
      };
  };
  var applicativeProduct = function (dictApplicative) {
      return function (dictApplicative1) {
          return new Control_Applicative.Applicative(function () {
              return applyProduct(dictApplicative["__superclass_Control.Apply.Apply_0"]())(dictApplicative1["__superclass_Control.Apply.Apply_0"]());
          }, function (a) {
              return product(Control_Applicative.pure(dictApplicative)(a))(Control_Applicative.pure(dictApplicative1)(a));
          });
      };
  };
  var monadProduct = function (dictMonad) {
      return function (dictMonad1) {
          return new Control_Monad.Monad(function () {
              return applicativeProduct(dictMonad["__superclass_Control.Applicative.Applicative_0"]())(dictMonad1["__superclass_Control.Applicative.Applicative_0"]());
          }, function () {
              return bindProduct(dictMonad["__superclass_Control.Bind.Bind_1"]())(dictMonad1["__superclass_Control.Bind.Bind_1"]());
          });
      };
  };
  exports["Product"] = Product;
  exports["bihoistProduct"] = bihoistProduct;
  exports["product"] = product;
  exports["newtypeProduct"] = newtypeProduct;
  exports["eqProduct"] = eqProduct;
  exports["ordProduct"] = ordProduct;
  exports["showProduct"] = showProduct;
  exports["functorProduct"] = functorProduct;
  exports["foldableProduct"] = foldableProduct;
  exports["traversableProduct"] = traversableProduct;
  exports["applyProduct"] = applyProduct;
  exports["applicativeProduct"] = applicativeProduct;
  exports["bindProduct"] = bindProduct;
  exports["monadProduct"] = monadProduct;
})(PS["Data.Functor.Product"] = PS["Data.Functor.Product"] || {});
(function(exports) {
    "use strict";
  var Prelude = PS["Prelude"];
  var Data_Const = PS["Data.Const"];
  var Data_Functor_Product = PS["Data.Functor.Product"];
  var Data_Tuple = PS["Data.Tuple"];
  var Data_Unit = PS["Data.Unit"];        
  var product9 = function (a) {
      return function (b) {
          return function (c) {
              return function (d) {
                  return function (e) {
                      return function (f) {
                          return function (g) {
                              return function (h) {
                                  return function (i) {
                                      return Data_Functor_Product.product(a)(Data_Functor_Product.product(b)(Data_Functor_Product.product(c)(Data_Functor_Product.product(d)(Data_Functor_Product.product(e)(Data_Functor_Product.product(f)(Data_Functor_Product.product(g)(Data_Functor_Product.product(h)(Data_Functor_Product.product(i)(Data_Unit.unit)))))))));
                                  };
                              };
                          };
                      };
                  };
              };
          };
      };
  };
  var product8 = function (a) {
      return function (b) {
          return function (c) {
              return function (d) {
                  return function (e) {
                      return function (f) {
                          return function (g) {
                              return function (h) {
                                  return Data_Functor_Product.product(a)(Data_Functor_Product.product(b)(Data_Functor_Product.product(c)(Data_Functor_Product.product(d)(Data_Functor_Product.product(e)(Data_Functor_Product.product(f)(Data_Functor_Product.product(g)(Data_Functor_Product.product(h)(Data_Unit.unit))))))));
                              };
                          };
                      };
                  };
              };
          };
      };
  };
  var product7 = function (a) {
      return function (b) {
          return function (c) {
              return function (d) {
                  return function (e) {
                      return function (f) {
                          return function (g) {
                              return Data_Functor_Product.product(a)(Data_Functor_Product.product(b)(Data_Functor_Product.product(c)(Data_Functor_Product.product(d)(Data_Functor_Product.product(e)(Data_Functor_Product.product(f)(Data_Functor_Product.product(g)(Data_Unit.unit)))))));
                          };
                      };
                  };
              };
          };
      };
  };
  var product6 = function (a) {
      return function (b) {
          return function (c) {
              return function (d) {
                  return function (e) {
                      return function (f) {
                          return Data_Functor_Product.product(a)(Data_Functor_Product.product(b)(Data_Functor_Product.product(c)(Data_Functor_Product.product(d)(Data_Functor_Product.product(e)(Data_Functor_Product.product(f)(Data_Unit.unit))))));
                      };
                  };
              };
          };
      };
  };
  var product5 = function (a) {
      return function (b) {
          return function (c) {
              return function (d) {
                  return function (e) {
                      return Data_Functor_Product.product(a)(Data_Functor_Product.product(b)(Data_Functor_Product.product(c)(Data_Functor_Product.product(d)(Data_Functor_Product.product(e)(Data_Unit.unit)))));
                  };
              };
          };
      };
  };
  var product4 = function (a) {
      return function (b) {
          return function (c) {
              return function (d) {
                  return Data_Functor_Product.product(a)(Data_Functor_Product.product(b)(Data_Functor_Product.product(c)(Data_Functor_Product.product(d)(Data_Unit.unit))));
              };
          };
      };
  };
  var product3 = function (a) {
      return function (b) {
          return function (c) {
              return Data_Functor_Product.product(a)(Data_Functor_Product.product(b)(Data_Functor_Product.product(c)(Data_Unit.unit)));
          };
      };
  };
  var product2 = function (a) {
      return function (b) {
          return Data_Functor_Product.product(a)(Data_Functor_Product.product(b)(Data_Unit.unit));
      };
  };
  var product10 = function (a) {
      return function (b) {
          return function (c) {
              return function (d) {
                  return function (e) {
                      return function (f) {
                          return function (g) {
                              return function (h) {
                                  return function (i) {
                                      return function (j) {
                                          return Data_Functor_Product.product(a)(Data_Functor_Product.product(b)(Data_Functor_Product.product(c)(Data_Functor_Product.product(d)(Data_Functor_Product.product(e)(Data_Functor_Product.product(f)(Data_Functor_Product.product(g)(Data_Functor_Product.product(h)(Data_Functor_Product.product(i)(Data_Functor_Product.product(j)(Data_Unit.unit))))))))));
                                      };
                                  };
                              };
                          };
                      };
                  };
              };
          };
      };
  };
  var product1 = function (a) {
      return Data_Functor_Product.product(a)(Data_Unit.unit);
  };
  var get9 = function (v) {
      return v.value1.value1.value1.value1.value1.value1.value1.value1.value0;
  };
  var get8 = function (v) {
      return v.value1.value1.value1.value1.value1.value1.value1.value0;
  };
  var get7 = function (v) {
      return v.value1.value1.value1.value1.value1.value1.value0;
  };
  var get6 = function (v) {
      return v.value1.value1.value1.value1.value1.value0;
  };
  var get5 = function (v) {
      return v.value1.value1.value1.value1.value0;
  };
  var get4 = function (v) {
      return v.value1.value1.value1.value0;
  };
  var get3 = function (v) {
      return v.value1.value1.value0;
  };
  var get2 = function (v) {
      return v.value1.value0;
  };
  var get10 = function (v) {
      return v.value1.value1.value1.value1.value1.value1.value1.value1.value1.value0;
  };
  var get1 = function (v) {
      return v.value0;
  };
  exports["get1"] = get1;
  exports["get10"] = get10;
  exports["get2"] = get2;
  exports["get3"] = get3;
  exports["get4"] = get4;
  exports["get5"] = get5;
  exports["get6"] = get6;
  exports["get7"] = get7;
  exports["get8"] = get8;
  exports["get9"] = get9;
  exports["product1"] = product1;
  exports["product10"] = product10;
  exports["product2"] = product2;
  exports["product3"] = product3;
  exports["product4"] = product4;
  exports["product5"] = product5;
  exports["product6"] = product6;
  exports["product7"] = product7;
  exports["product8"] = product8;
  exports["product9"] = product9;
})(PS["Data.Functor.Product.Nested"] = PS["Data.Functor.Product.Nested"] || {});
(function(exports) {
  
  /**
 *  | This module defines a type of maps as balanced 2-3 trees, based on
 *  | <http://www.cs.princeton.edu/~dpw/courses/cos326-12/ass/2-3-trees.pdf>
 */  
  "use strict";
  var Prelude = PS["Prelude"];
  var Data_Foldable = PS["Data.Foldable"];
  var Data_List = PS["Data.List"];
  var Data_Maybe = PS["Data.Maybe"];
  var Data_Monoid = PS["Data.Monoid"];
  var Data_Traversable = PS["Data.Traversable"];
  var Data_Tuple = PS["Data.Tuple"];
  var Data_Unfoldable = PS["Data.Unfoldable"];
  var Partial_Unsafe = PS["Partial.Unsafe"];
  var Data_Eq = PS["Data.Eq"];
  var Data_Ord = PS["Data.Ord"];
  var Data_Show = PS["Data.Show"];
  var Data_Semigroup = PS["Data.Semigroup"];
  var Data_Functor = PS["Data.Functor"];
  var Control_Apply = PS["Control.Apply"];
  var Control_Applicative = PS["Control.Applicative"];
  var Control_Category = PS["Control.Category"];
  var Data_List_Types = PS["Data.List.Types"];
  var Control_Semigroupoid = PS["Control.Semigroupoid"];
  var Data_Ordering = PS["Data.Ordering"];
  var Data_Function = PS["Data.Function"];
  var Data_Semiring = PS["Data.Semiring"];        

  /**
 *  | `Map k v` represents maps from keys of type `k` to values of type `v`.
 */  
  var Leaf = (function () {
      function Leaf() {

      };
      Leaf.value = new Leaf();
      return Leaf;
  })();

  /**
 *  | `Map k v` represents maps from keys of type `k` to values of type `v`.
 */  
  var Two = (function () {
      function Two(value0, value1, value2, value3) {
          this.value0 = value0;
          this.value1 = value1;
          this.value2 = value2;
          this.value3 = value3;
      };
      Two.create = function (value0) {
          return function (value1) {
              return function (value2) {
                  return function (value3) {
                      return new Two(value0, value1, value2, value3);
                  };
              };
          };
      };
      return Two;
  })();

  /**
 *  | `Map k v` represents maps from keys of type `k` to values of type `v`.
 */  
  var Three = (function () {
      function Three(value0, value1, value2, value3, value4, value5, value6) {
          this.value0 = value0;
          this.value1 = value1;
          this.value2 = value2;
          this.value3 = value3;
          this.value4 = value4;
          this.value5 = value5;
          this.value6 = value6;
      };
      Three.create = function (value0) {
          return function (value1) {
              return function (value2) {
                  return function (value3) {
                      return function (value4) {
                          return function (value5) {
                              return function (value6) {
                                  return new Three(value0, value1, value2, value3, value4, value5, value6);
                              };
                          };
                      };
                  };
              };
          };
      };
      return Three;
  })();
  var TwoLeft = (function () {
      function TwoLeft(value0, value1, value2) {
          this.value0 = value0;
          this.value1 = value1;
          this.value2 = value2;
      };
      TwoLeft.create = function (value0) {
          return function (value1) {
              return function (value2) {
                  return new TwoLeft(value0, value1, value2);
              };
          };
      };
      return TwoLeft;
  })();
  var TwoRight = (function () {
      function TwoRight(value0, value1, value2) {
          this.value0 = value0;
          this.value1 = value1;
          this.value2 = value2;
      };
      TwoRight.create = function (value0) {
          return function (value1) {
              return function (value2) {
                  return new TwoRight(value0, value1, value2);
              };
          };
      };
      return TwoRight;
  })();
  var ThreeLeft = (function () {
      function ThreeLeft(value0, value1, value2, value3, value4, value5) {
          this.value0 = value0;
          this.value1 = value1;
          this.value2 = value2;
          this.value3 = value3;
          this.value4 = value4;
          this.value5 = value5;
      };
      ThreeLeft.create = function (value0) {
          return function (value1) {
              return function (value2) {
                  return function (value3) {
                      return function (value4) {
                          return function (value5) {
                              return new ThreeLeft(value0, value1, value2, value3, value4, value5);
                          };
                      };
                  };
              };
          };
      };
      return ThreeLeft;
  })();
  var ThreeMiddle = (function () {
      function ThreeMiddle(value0, value1, value2, value3, value4, value5) {
          this.value0 = value0;
          this.value1 = value1;
          this.value2 = value2;
          this.value3 = value3;
          this.value4 = value4;
          this.value5 = value5;
      };
      ThreeMiddle.create = function (value0) {
          return function (value1) {
              return function (value2) {
                  return function (value3) {
                      return function (value4) {
                          return function (value5) {
                              return new ThreeMiddle(value0, value1, value2, value3, value4, value5);
                          };
                      };
                  };
              };
          };
      };
      return ThreeMiddle;
  })();
  var ThreeRight = (function () {
      function ThreeRight(value0, value1, value2, value3, value4, value5) {
          this.value0 = value0;
          this.value1 = value1;
          this.value2 = value2;
          this.value3 = value3;
          this.value4 = value4;
          this.value5 = value5;
      };
      ThreeRight.create = function (value0) {
          return function (value1) {
              return function (value2) {
                  return function (value3) {
                      return function (value4) {
                          return function (value5) {
                              return new ThreeRight(value0, value1, value2, value3, value4, value5);
                          };
                      };
                  };
              };
          };
      };
      return ThreeRight;
  })();
  var KickUp = (function () {
      function KickUp(value0, value1, value2, value3) {
          this.value0 = value0;
          this.value1 = value1;
          this.value2 = value2;
          this.value3 = value3;
      };
      KickUp.create = function (value0) {
          return function (value1) {
              return function (value2) {
                  return function (value3) {
                      return new KickUp(value0, value1, value2, value3);
                  };
              };
          };
      };
      return KickUp;
  })();
  var values = function (v) {
      if (v instanceof Leaf) {
          return Data_List_Types.Nil.value;
      };
      if (v instanceof Two) {
          return Data_Semigroup.append(Data_List_Types.semigroupList)(values(v.value0))(Data_Semigroup.append(Data_List_Types.semigroupList)(Control_Applicative.pure(Data_List_Types.applicativeList)(v.value2))(values(v.value3)));
      };
      if (v instanceof Three) {
          return Data_Semigroup.append(Data_List_Types.semigroupList)(values(v.value0))(Data_Semigroup.append(Data_List_Types.semigroupList)(Control_Applicative.pure(Data_List_Types.applicativeList)(v.value2))(Data_Semigroup.append(Data_List_Types.semigroupList)(values(v.value3))(Data_Semigroup.append(Data_List_Types.semigroupList)(Control_Applicative.pure(Data_List_Types.applicativeList)(v.value5))(values(v.value6)))));
      };
      throw new Error("Failed pattern match at Data.Map line 391, column 1 - line 391, column 18: " + [ v.constructor.name ]);
  };
  var toList = function (v) {
      if (v instanceof Leaf) {
          return Data_List_Types.Nil.value;
      };
      if (v instanceof Two) {
          return Data_Semigroup.append(Data_List_Types.semigroupList)(toList(v.value0))(new Data_List_Types.Cons(new Data_Tuple.Tuple(v.value1, v.value2), toList(v.value3)));
      };
      if (v instanceof Three) {
          return Data_Semigroup.append(Data_List_Types.semigroupList)(toList(v.value0))(Data_Semigroup.append(Data_List_Types.semigroupList)(new Data_List_Types.Cons(new Data_Tuple.Tuple(v.value1, v.value2), toList(v.value3)))(new Data_List_Types.Cons(new Data_Tuple.Tuple(v.value4, v.value5), toList(v.value6))));
      };
      throw new Error("Failed pattern match at Data.Map line 370, column 1 - line 370, column 18: " + [ v.constructor.name ]);
  };

  /**
 *  | Calculate the number of key/value pairs in a map
 */  
  var size = function ($620) {
      return Data_List.length(values($620));
  };

  /**
 *  | Create a map with one key/value pair
 */  
  var singleton = function (k) {
      return function (v) {
          return new Two(Leaf.value, k, v, Leaf.value);
      };
  };
  var showTree = function (dictShow) {
      return function (dictShow1) {
          return function (v) {
              if (v instanceof Leaf) {
                  return "Leaf";
              };
              if (v instanceof Two) {
                  return "Two (" + (showTree(dictShow)(dictShow1)(v.value0) + (") (" + (Data_Show.show(dictShow)(v.value1) + (") (" + (Data_Show.show(dictShow1)(v.value2) + (") (" + (showTree(dictShow)(dictShow1)(v.value3) + ")")))))));
              };
              if (v instanceof Three) {
                  return "Three (" + (showTree(dictShow)(dictShow1)(v.value0) + (") (" + (Data_Show.show(dictShow)(v.value1) + (") (" + (Data_Show.show(dictShow1)(v.value2) + (") (" + (showTree(dictShow)(dictShow1)(v.value3) + (") (" + (Data_Show.show(dictShow)(v.value4) + (") (" + (Data_Show.show(dictShow1)(v.value5) + (") (" + (showTree(dictShow)(dictShow1)(v.value6) + ")")))))))))))));
              };
              throw new Error("Failed pattern match at Data.Map line 86, column 1 - line 87, column 1: " + [ v.constructor.name ]);
          };
      };
  };
  var showMap = function (dictShow) {
      return function (dictShow1) {
          return new Data_Show.Show(function (m) {
              return "(fromList " + (Data_Show.show(Data_List_Types.showList(Data_Tuple.showTuple(dictShow)(dictShow1)))(toList(m)) + ")");
          });
      };
  };
  var mapWithKey = function (v) {
      return function (v1) {
          if (v1 instanceof Leaf) {
              return Leaf.value;
          };
          if (v1 instanceof Two) {
              return new Two(mapWithKey(v)(v1.value0), v1.value1, v(v1.value1)(v1.value2), mapWithKey(v)(v1.value3));
          };
          if (v1 instanceof Three) {
              return new Three(mapWithKey(v)(v1.value0), v1.value1, v(v1.value1)(v1.value2), mapWithKey(v)(v1.value3), v1.value4, v(v1.value4)(v1.value5), mapWithKey(v)(v1.value6));
          };
          throw new Error("Failed pattern match at Data.Map line 417, column 1 - line 417, column 25: " + [ v.constructor.name, v1.constructor.name ]);
      };
  };
  var lookupLE = function (dictOrd) {
      return function (v) {
          return function (v1) {
              if (v1 instanceof Leaf) {
                  return Data_Maybe.Nothing.value;
              };
              if (v1 instanceof Two) {
                  var $133 = Data_Ord.compare(dictOrd)(v)(v1.value1);
                  if ($133 instanceof Data_Ordering.EQ) {
                      return new Data_Maybe.Just({
                          key: v1.value1, 
                          value: v1.value2
                      });
                  };
                  if ($133 instanceof Data_Ordering.GT) {
                      return Data_Maybe.Just.create(Data_Maybe.fromMaybe({
                          key: v1.value1, 
                          value: v1.value2
                      })(lookupLE(dictOrd)(v)(v1.value3)));
                  };
                  if ($133 instanceof Data_Ordering.LT) {
                      return lookupLE(dictOrd)(v)(v1.value0);
                  };
                  throw new Error("Failed pattern match at Data.Map line 153, column 37 - line 156, column 24: " + [ $133.constructor.name ]);
              };
              if (v1 instanceof Three) {
                  var $138 = Data_Ord.compare(dictOrd)(v)(v1.value4);
                  if ($138 instanceof Data_Ordering.EQ) {
                      return new Data_Maybe.Just({
                          key: v1.value4, 
                          value: v1.value5
                      });
                  };
                  if ($138 instanceof Data_Ordering.GT) {
                      return Data_Maybe.Just.create(Data_Maybe.fromMaybe({
                          key: v1.value4, 
                          value: v1.value5
                      })(lookupLE(dictOrd)(v)(v1.value6)));
                  };
                  if ($138 instanceof Data_Ordering.LT) {
                      return lookupLE(dictOrd)(v)(new Two(v1.value0, v1.value1, v1.value2, v1.value3));
                  };
                  throw new Error("Failed pattern match at Data.Map line 157, column 49 - line 160, column 40: " + [ $138.constructor.name ]);
              };
              throw new Error("Failed pattern match at Data.Map line 152, column 1 - line 152, column 26: " + [ v.constructor.name, v1.constructor.name ]);
          };
      };
  };
  var lookupGE = function (dictOrd) {
      return function (v) {
          return function (v1) {
              if (v1 instanceof Leaf) {
                  return Data_Maybe.Nothing.value;
              };
              if (v1 instanceof Two) {
                  var $148 = Data_Ord.compare(dictOrd)(v)(v1.value1);
                  if ($148 instanceof Data_Ordering.EQ) {
                      return new Data_Maybe.Just({
                          key: v1.value1, 
                          value: v1.value2
                      });
                  };
                  if ($148 instanceof Data_Ordering.LT) {
                      return Data_Maybe.Just.create(Data_Maybe.fromMaybe({
                          key: v1.value1, 
                          value: v1.value2
                      })(lookupGE(dictOrd)(v)(v1.value0)));
                  };
                  if ($148 instanceof Data_Ordering.GT) {
                      return lookupGE(dictOrd)(v)(v1.value3);
                  };
                  throw new Error("Failed pattern match at Data.Map line 177, column 37 - line 180, column 25: " + [ $148.constructor.name ]);
              };
              if (v1 instanceof Three) {
                  var $153 = Data_Ord.compare(dictOrd)(v)(v1.value1);
                  if ($153 instanceof Data_Ordering.EQ) {
                      return new Data_Maybe.Just({
                          key: v1.value1, 
                          value: v1.value2
                      });
                  };
                  if ($153 instanceof Data_Ordering.LT) {
                      return Data_Maybe.Just.create(Data_Maybe.fromMaybe({
                          key: v1.value1, 
                          value: v1.value2
                      })(lookupGE(dictOrd)(v)(v1.value0)));
                  };
                  if ($153 instanceof Data_Ordering.GT) {
                      return lookupGE(dictOrd)(v)(new Two(v1.value3, v1.value4, v1.value5, v1.value6));
                  };
                  throw new Error("Failed pattern match at Data.Map line 181, column 49 - line 184, column 41: " + [ $153.constructor.name ]);
              };
              throw new Error("Failed pattern match at Data.Map line 176, column 1 - line 176, column 26: " + [ v.constructor.name, v1.constructor.name ]);
          };
      };
  };
  var lookup = function (dictOrd) {
      return Partial_Unsafe.unsafePartial(function (dictPartial) {
          return function (k) {
              return function (tree) {
                  if (tree instanceof Leaf) {
                      return Data_Maybe.Nothing.value;
                  };
                  var comp = Data_Ord.compare(dictOrd);
                  var __unused = function (dictPartial1) {
                      return function ($dollar40) {
                          return $dollar40;
                      };
                  };
                  return __unused(dictPartial)((function () {
                      if (tree instanceof Two) {
                          var $163 = comp(k)(tree.value1);
                          if ($163 instanceof Data_Ordering.EQ) {
                              return new Data_Maybe.Just(tree.value2);
                          };
                          if ($163 instanceof Data_Ordering.LT) {
                              return lookup(dictOrd)(k)(tree.value0);
                          };
                          return lookup(dictOrd)(k)(tree.value3);
                      };
                      if (tree instanceof Three) {
                          var $168 = comp(k)(tree.value1);
                          if ($168 instanceof Data_Ordering.EQ) {
                              return new Data_Maybe.Just(tree.value2);
                          };
                          var $170 = comp(k)(tree.value4);
                          if ($170 instanceof Data_Ordering.EQ) {
                              return new Data_Maybe.Just(tree.value5);
                          };
                          if ($168 instanceof Data_Ordering.LT) {
                              return lookup(dictOrd)(k)(tree.value0);
                          };
                          if ($170 instanceof Data_Ordering.GT) {
                              return lookup(dictOrd)(k)(tree.value6);
                          };
                          return lookup(dictOrd)(k)(tree.value3);
                      };
                      throw new Error("Failed pattern match at Data.Map line 133, column 10 - line 147, column 39: " + [ tree.constructor.name ]);
                  })());
              };
          };
      });
  };

  /**
 *  | Test if a key is a member of a map
 */  
  var member = function (dictOrd) {
      return function (k) {
          return function (m) {
              return Data_Maybe.isJust(lookup(dictOrd)(k)(m));
          };
      };
  };
  var keys = function (v) {
      if (v instanceof Leaf) {
          return Data_List_Types.Nil.value;
      };
      if (v instanceof Two) {
          return Data_Semigroup.append(Data_List_Types.semigroupList)(keys(v.value0))(Data_Semigroup.append(Data_List_Types.semigroupList)(Control_Applicative.pure(Data_List_Types.applicativeList)(v.value1))(keys(v.value3)));
      };
      if (v instanceof Three) {
          return Data_Semigroup.append(Data_List_Types.semigroupList)(keys(v.value0))(Data_Semigroup.append(Data_List_Types.semigroupList)(Control_Applicative.pure(Data_List_Types.applicativeList)(v.value1))(Data_Semigroup.append(Data_List_Types.semigroupList)(keys(v.value3))(Data_Semigroup.append(Data_List_Types.semigroupList)(Control_Applicative.pure(Data_List_Types.applicativeList)(v.value4))(keys(v.value6)))));
      };
      throw new Error("Failed pattern match at Data.Map line 385, column 1 - line 385, column 16: " + [ v.constructor.name ]);
  };

  /**
 *  | Test if a map is empty
 */  
  var isEmpty = function (v) {
      if (v instanceof Leaf) {
          return true;
      };
      return false;
  };
  var functorMap = new Data_Functor.Functor(function (v) {
      return function (v1) {
          if (v1 instanceof Leaf) {
              return Leaf.value;
          };
          if (v1 instanceof Two) {
              return new Two(Data_Functor.map(functorMap)(v)(v1.value0), v1.value1, v(v1.value2), Data_Functor.map(functorMap)(v)(v1.value3));
          };
          if (v1 instanceof Three) {
              return new Three(Data_Functor.map(functorMap)(v)(v1.value0), v1.value1, v(v1.value2), Data_Functor.map(functorMap)(v)(v1.value3), v1.value4, v(v1.value5), Data_Functor.map(functorMap)(v)(v1.value6));
          };
          throw new Error("Failed pattern match at Data.Map line 71, column 3 - line 71, column 20: " + [ v.constructor.name, v1.constructor.name ]);
      };
  });
  var fromZipper = function (__copy_dictOrd) {
      return function (__copy_v) {
          return function (__copy_tree) {
              var dictOrd = __copy_dictOrd;
              var v = __copy_v;
              var tree = __copy_tree;
              tco: while (true) {
                  if (v instanceof Data_List_Types.Nil) {
                      return tree;
                  };
                  if (v instanceof Data_List_Types.Cons) {
                      if (v.value0 instanceof TwoLeft) {
                          var __tco_dictOrd = dictOrd;
                          var __tco_v = v.value1;
                          var __tco_tree = new Two(tree, v.value0.value0, v.value0.value1, v.value0.value2);
                          dictOrd = __tco_dictOrd;
                          v = __tco_v;
                          tree = __tco_tree;
                          continue tco;
                      };
                      if (v.value0 instanceof TwoRight) {
                          var __tco_dictOrd = dictOrd;
                          var __tco_v = v.value1;
                          var __tco_tree = new Two(v.value0.value0, v.value0.value1, v.value0.value2, tree);
                          dictOrd = __tco_dictOrd;
                          v = __tco_v;
                          tree = __tco_tree;
                          continue tco;
                      };
                      if (v.value0 instanceof ThreeLeft) {
                          var __tco_dictOrd = dictOrd;
                          var __tco_v = v.value1;
                          var __tco_tree = new Three(tree, v.value0.value0, v.value0.value1, v.value0.value2, v.value0.value3, v.value0.value4, v.value0.value5);
                          dictOrd = __tco_dictOrd;
                          v = __tco_v;
                          tree = __tco_tree;
                          continue tco;
                      };
                      if (v.value0 instanceof ThreeMiddle) {
                          var __tco_dictOrd = dictOrd;
                          var __tco_v = v.value1;
                          var __tco_tree = new Three(v.value0.value0, v.value0.value1, v.value0.value2, tree, v.value0.value3, v.value0.value4, v.value0.value5);
                          dictOrd = __tco_dictOrd;
                          v = __tco_v;
                          tree = __tco_tree;
                          continue tco;
                      };
                      if (v.value0 instanceof ThreeRight) {
                          var __tco_dictOrd = dictOrd;
                          var __tco_v = v.value1;
                          var __tco_tree = new Three(v.value0.value0, v.value0.value1, v.value0.value2, v.value0.value3, v.value0.value4, v.value0.value5, tree);
                          dictOrd = __tco_dictOrd;
                          v = __tco_v;
                          tree = __tco_tree;
                          continue tco;
                      };
                      throw new Error("Failed pattern match at Data.Map line 224, column 3 - line 229, column 88: " + [ v.value0.constructor.name ]);
                  };
                  throw new Error("Failed pattern match at Data.Map line 222, column 1 - line 222, column 27: " + [ v.constructor.name, tree.constructor.name ]);
              };
          };
      };
  };

  /**
 *  | Insert a key/value pair into a map
 */  
  var insert = function (dictOrd) {
      var up = function (__copy_v) {
          return function (__copy_v1) {
              var v = __copy_v;
              var v1 = __copy_v1;
              tco: while (true) {
                  if (v instanceof Data_List_Types.Nil) {
                      return new Two(v1.value0, v1.value1, v1.value2, v1.value3);
                  };
                  if (v instanceof Data_List_Types.Cons) {
                      if (v.value0 instanceof TwoLeft) {
                          return fromZipper(dictOrd)(v.value1)(new Three(v1.value0, v1.value1, v1.value2, v1.value3, v.value0.value0, v.value0.value1, v.value0.value2));
                      };
                      if (v.value0 instanceof TwoRight) {
                          return fromZipper(dictOrd)(v.value1)(new Three(v.value0.value0, v.value0.value1, v.value0.value2, v1.value0, v1.value1, v1.value2, v1.value3));
                      };
                      if (v.value0 instanceof ThreeLeft) {
                          var __tco_v = v.value1;
                          var __tco_v1 = new KickUp(new Two(v1.value0, v1.value1, v1.value2, v1.value3), v.value0.value0, v.value0.value1, new Two(v.value0.value2, v.value0.value3, v.value0.value4, v.value0.value5));
                          v = __tco_v;
                          v1 = __tco_v1;
                          continue tco;
                      };
                      if (v.value0 instanceof ThreeMiddle) {
                          var __tco_v = v.value1;
                          var __tco_v1 = new KickUp(new Two(v.value0.value0, v.value0.value1, v.value0.value2, v1.value0), v1.value1, v1.value2, new Two(v1.value3, v.value0.value3, v.value0.value4, v.value0.value5));
                          v = __tco_v;
                          v1 = __tco_v1;
                          continue tco;
                      };
                      if (v.value0 instanceof ThreeRight) {
                          var __tco_v = v.value1;
                          var __tco_v1 = new KickUp(new Two(v.value0.value0, v.value0.value1, v.value0.value2, v.value0.value3), v.value0.value4, v.value0.value5, new Two(v1.value0, v1.value1, v1.value2, v1.value3));
                          v = __tco_v;
                          v1 = __tco_v1;
                          continue tco;
                      };
                      throw new Error("Failed pattern match at Data.Map line 260, column 5 - line 265, column 104: " + [ v.value0.constructor.name, v1.constructor.name ]);
                  };
                  throw new Error("Failed pattern match at Data.Map line 258, column 3 - line 258, column 54: " + [ v.constructor.name, v1.constructor.name ]);
              };
          };
      };
      var comp = Data_Ord.compare(dictOrd);
      var down = function (__copy_ctx) {
          return function (__copy_k) {
              return function (__copy_v) {
                  return function (__copy_v1) {
                      var ctx = __copy_ctx;
                      var k = __copy_k;
                      var v = __copy_v;
                      var v1 = __copy_v1;
                      tco: while (true) {
                          if (v1 instanceof Leaf) {
                              return up(ctx)(new KickUp(Leaf.value, k, v, Leaf.value));
                          };
                          if (v1 instanceof Two) {
                              var $291 = comp(k)(v1.value1);
                              if ($291 instanceof Data_Ordering.EQ) {
                                  return fromZipper(dictOrd)(ctx)(new Two(v1.value0, k, v, v1.value3));
                              };
                              if ($291 instanceof Data_Ordering.LT) {
                                  var __tco_ctx = new Data_List_Types.Cons(new TwoLeft(v1.value1, v1.value2, v1.value3), ctx);
                                  var __tco_k = k;
                                  var __tco_v = v;
                                  var __tco_v1 = v1.value0;
                                  ctx = __tco_ctx;
                                  k = __tco_k;
                                  v = __tco_v;
                                  v1 = __tco_v1;
                                  continue tco;
                              };
                              var __tco_ctx = new Data_List_Types.Cons(new TwoRight(v1.value0, v1.value1, v1.value2), ctx);
                              var __tco_k = k;
                              var __tco_v = v;
                              var __tco_v1 = v1.value3;
                              ctx = __tco_ctx;
                              k = __tco_k;
                              v = __tco_v;
                              v1 = __tco_v1;
                              continue tco;
                          };
                          if (v1 instanceof Three) {
                              var $296 = comp(k)(v1.value1);
                              if ($296 instanceof Data_Ordering.EQ) {
                                  return fromZipper(dictOrd)(ctx)(new Three(v1.value0, k, v, v1.value3, v1.value4, v1.value5, v1.value6));
                              };
                              var $298 = comp(k)(v1.value4);
                              if ($298 instanceof Data_Ordering.EQ) {
                                  return fromZipper(dictOrd)(ctx)(new Three(v1.value0, v1.value1, v1.value2, v1.value3, k, v, v1.value6));
                              };
                              if ($296 instanceof Data_Ordering.LT) {
                                  var __tco_ctx = new Data_List_Types.Cons(new ThreeLeft(v1.value1, v1.value2, v1.value3, v1.value4, v1.value5, v1.value6), ctx);
                                  var __tco_k = k;
                                  var __tco_v = v;
                                  var __tco_v1 = v1.value0;
                                  ctx = __tco_ctx;
                                  k = __tco_k;
                                  v = __tco_v;
                                  v1 = __tco_v1;
                                  continue tco;
                              };
                              if ($296 instanceof Data_Ordering.GT && $298 instanceof Data_Ordering.LT) {
                                  var __tco_ctx = new Data_List_Types.Cons(new ThreeMiddle(v1.value0, v1.value1, v1.value2, v1.value4, v1.value5, v1.value6), ctx);
                                  var __tco_k = k;
                                  var __tco_v = v;
                                  var __tco_v1 = v1.value3;
                                  ctx = __tco_ctx;
                                  k = __tco_k;
                                  v = __tco_v;
                                  v1 = __tco_v1;
                                  continue tco;
                              };
                              var __tco_ctx = new Data_List_Types.Cons(new ThreeRight(v1.value0, v1.value1, v1.value2, v1.value3, v1.value4, v1.value5), ctx);
                              var __tco_k = k;
                              var __tco_v = v;
                              var __tco_v1 = v1.value6;
                              ctx = __tco_ctx;
                              k = __tco_k;
                              v = __tco_v;
                              v1 = __tco_v1;
                              continue tco;
                          };
                          throw new Error("Failed pattern match at Data.Map line 241, column 3 - line 241, column 52: " + [ ctx.constructor.name, k.constructor.name, v.constructor.name, v1.constructor.name ]);
                      };
                  };
              };
          };
      };
      return down(Data_List_Types.Nil.value);
  };

  /**
 *  | Delete a key and its corresponding value from a map, returning the value
 *  | as well as the subsequent map.
 */  
  var pop = function (dictOrd) {
      var up = Partial_Unsafe.unsafePartial(function (dictPartial) {
          return function (ctxs) {
              return function (tree) {
                  if (ctxs instanceof Data_List_Types.Nil) {
                      return tree;
                  };
                  if (ctxs instanceof Data_List_Types.Cons) {
                      var __unused = function (dictPartial1) {
                          return function ($dollar48) {
                              return $dollar48;
                          };
                      };
                      return __unused(dictPartial)((function () {
                          if (ctxs.value0 instanceof TwoLeft && (ctxs.value0.value2 instanceof Leaf && tree instanceof Leaf)) {
                              return fromZipper(dictOrd)(ctxs.value1)(new Two(Leaf.value, ctxs.value0.value0, ctxs.value0.value1, Leaf.value));
                          };
                          if (ctxs.value0 instanceof TwoRight && (ctxs.value0.value0 instanceof Leaf && tree instanceof Leaf)) {
                              return fromZipper(dictOrd)(ctxs.value1)(new Two(Leaf.value, ctxs.value0.value1, ctxs.value0.value2, Leaf.value));
                          };
                          if (ctxs.value0 instanceof TwoLeft && ctxs.value0.value2 instanceof Two) {
                              return up(ctxs.value1)(new Three(tree, ctxs.value0.value0, ctxs.value0.value1, ctxs.value0.value2.value0, ctxs.value0.value2.value1, ctxs.value0.value2.value2, ctxs.value0.value2.value3));
                          };
                          if (ctxs.value0 instanceof TwoRight && ctxs.value0.value0 instanceof Two) {
                              return up(ctxs.value1)(new Three(ctxs.value0.value0.value0, ctxs.value0.value0.value1, ctxs.value0.value0.value2, ctxs.value0.value0.value3, ctxs.value0.value1, ctxs.value0.value2, tree));
                          };
                          if (ctxs.value0 instanceof TwoLeft && ctxs.value0.value2 instanceof Three) {
                              return fromZipper(dictOrd)(ctxs.value1)(new Two(new Two(tree, ctxs.value0.value0, ctxs.value0.value1, ctxs.value0.value2.value0), ctxs.value0.value2.value1, ctxs.value0.value2.value2, new Two(ctxs.value0.value2.value3, ctxs.value0.value2.value4, ctxs.value0.value2.value5, ctxs.value0.value2.value6)));
                          };
                          if (ctxs.value0 instanceof TwoRight && ctxs.value0.value0 instanceof Three) {
                              return fromZipper(dictOrd)(ctxs.value1)(new Two(new Two(ctxs.value0.value0.value0, ctxs.value0.value0.value1, ctxs.value0.value0.value2, ctxs.value0.value0.value3), ctxs.value0.value0.value4, ctxs.value0.value0.value5, new Two(ctxs.value0.value0.value6, ctxs.value0.value1, ctxs.value0.value2, tree)));
                          };
                          if (ctxs.value0 instanceof ThreeLeft && (ctxs.value0.value2 instanceof Leaf && (ctxs.value0.value5 instanceof Leaf && tree instanceof Leaf))) {
                              return fromZipper(dictOrd)(ctxs.value1)(new Three(Leaf.value, ctxs.value0.value0, ctxs.value0.value1, Leaf.value, ctxs.value0.value3, ctxs.value0.value4, Leaf.value));
                          };
                          if (ctxs.value0 instanceof ThreeMiddle && (ctxs.value0.value0 instanceof Leaf && (ctxs.value0.value5 instanceof Leaf && tree instanceof Leaf))) {
                              return fromZipper(dictOrd)(ctxs.value1)(new Three(Leaf.value, ctxs.value0.value1, ctxs.value0.value2, Leaf.value, ctxs.value0.value3, ctxs.value0.value4, Leaf.value));
                          };
                          if (ctxs.value0 instanceof ThreeRight && (ctxs.value0.value0 instanceof Leaf && (ctxs.value0.value3 instanceof Leaf && tree instanceof Leaf))) {
                              return fromZipper(dictOrd)(ctxs.value1)(new Three(Leaf.value, ctxs.value0.value1, ctxs.value0.value2, Leaf.value, ctxs.value0.value4, ctxs.value0.value5, Leaf.value));
                          };
                          if (ctxs.value0 instanceof ThreeLeft && ctxs.value0.value2 instanceof Two) {
                              return fromZipper(dictOrd)(ctxs.value1)(new Two(new Three(tree, ctxs.value0.value0, ctxs.value0.value1, ctxs.value0.value2.value0, ctxs.value0.value2.value1, ctxs.value0.value2.value2, ctxs.value0.value2.value3), ctxs.value0.value3, ctxs.value0.value4, ctxs.value0.value5));
                          };
                          if (ctxs.value0 instanceof ThreeMiddle && ctxs.value0.value0 instanceof Two) {
                              return fromZipper(dictOrd)(ctxs.value1)(new Two(new Three(ctxs.value0.value0.value0, ctxs.value0.value0.value1, ctxs.value0.value0.value2, ctxs.value0.value0.value3, ctxs.value0.value1, ctxs.value0.value2, tree), ctxs.value0.value3, ctxs.value0.value4, ctxs.value0.value5));
                          };
                          if (ctxs.value0 instanceof ThreeMiddle && ctxs.value0.value5 instanceof Two) {
                              return fromZipper(dictOrd)(ctxs.value1)(new Two(ctxs.value0.value0, ctxs.value0.value1, ctxs.value0.value2, new Three(tree, ctxs.value0.value3, ctxs.value0.value4, ctxs.value0.value5.value0, ctxs.value0.value5.value1, ctxs.value0.value5.value2, ctxs.value0.value5.value3)));
                          };
                          if (ctxs.value0 instanceof ThreeRight && ctxs.value0.value3 instanceof Two) {
                              return fromZipper(dictOrd)(ctxs.value1)(new Two(ctxs.value0.value0, ctxs.value0.value1, ctxs.value0.value2, new Three(ctxs.value0.value3.value0, ctxs.value0.value3.value1, ctxs.value0.value3.value2, ctxs.value0.value3.value3, ctxs.value0.value4, ctxs.value0.value5, tree)));
                          };
                          if (ctxs.value0 instanceof ThreeLeft && ctxs.value0.value2 instanceof Three) {
                              return fromZipper(dictOrd)(ctxs.value1)(new Three(new Two(tree, ctxs.value0.value0, ctxs.value0.value1, ctxs.value0.value2.value0), ctxs.value0.value2.value1, ctxs.value0.value2.value2, new Two(ctxs.value0.value2.value3, ctxs.value0.value2.value4, ctxs.value0.value2.value5, ctxs.value0.value2.value6), ctxs.value0.value3, ctxs.value0.value4, ctxs.value0.value5));
                          };
                          if (ctxs.value0 instanceof ThreeMiddle && ctxs.value0.value0 instanceof Three) {
                              return fromZipper(dictOrd)(ctxs.value1)(new Three(new Two(ctxs.value0.value0.value0, ctxs.value0.value0.value1, ctxs.value0.value0.value2, ctxs.value0.value0.value3), ctxs.value0.value0.value4, ctxs.value0.value0.value5, new Two(ctxs.value0.value0.value6, ctxs.value0.value1, ctxs.value0.value2, tree), ctxs.value0.value3, ctxs.value0.value4, ctxs.value0.value5));
                          };
                          if (ctxs.value0 instanceof ThreeMiddle && ctxs.value0.value5 instanceof Three) {
                              return fromZipper(dictOrd)(ctxs.value1)(new Three(ctxs.value0.value0, ctxs.value0.value1, ctxs.value0.value2, new Two(tree, ctxs.value0.value3, ctxs.value0.value4, ctxs.value0.value5.value0), ctxs.value0.value5.value1, ctxs.value0.value5.value2, new Two(ctxs.value0.value5.value3, ctxs.value0.value5.value4, ctxs.value0.value5.value5, ctxs.value0.value5.value6)));
                          };
                          if (ctxs.value0 instanceof ThreeRight && ctxs.value0.value3 instanceof Three) {
                              return fromZipper(dictOrd)(ctxs.value1)(new Three(ctxs.value0.value0, ctxs.value0.value1, ctxs.value0.value2, new Two(ctxs.value0.value3.value0, ctxs.value0.value3.value1, ctxs.value0.value3.value2, ctxs.value0.value3.value3), ctxs.value0.value3.value4, ctxs.value0.value3.value5, new Two(ctxs.value0.value3.value6, ctxs.value0.value4, ctxs.value0.value5, tree)));
                          };
                          throw new Error("Failed pattern match at Data.Map line 310, column 9 - line 327, column 136: " + [ ctxs.value0.constructor.name, tree.constructor.name ]);
                      })());
                  };
                  throw new Error("Failed pattern match at Data.Map line 307, column 5 - line 327, column 136: " + [ ctxs.constructor.name ]);
              };
          };
      });
      var removeMaxNode = Partial_Unsafe.unsafePartial(function (dictPartial) {
          return function (ctx) {
              return function (m) {
                  var __unused = function (dictPartial1) {
                      return function ($dollar50) {
                          return $dollar50;
                      };
                  };
                  return __unused(dictPartial)((function () {
                      if (m instanceof Two && (m.value0 instanceof Leaf && m.value3 instanceof Leaf)) {
                          return up(ctx)(Leaf.value);
                      };
                      if (m instanceof Two) {
                          return removeMaxNode(new Data_List_Types.Cons(new TwoRight(m.value0, m.value1, m.value2), ctx))(m.value3);
                      };
                      if (m instanceof Three && (m.value0 instanceof Leaf && (m.value3 instanceof Leaf && m.value6 instanceof Leaf))) {
                          return up(new Data_List_Types.Cons(new TwoRight(Leaf.value, m.value1, m.value2), ctx))(Leaf.value);
                      };
                      if (m instanceof Three) {
                          return removeMaxNode(new Data_List_Types.Cons(new ThreeRight(m.value0, m.value1, m.value2, m.value3, m.value4, m.value5), ctx))(m.value6);
                      };
                      throw new Error("Failed pattern match at Data.Map line 339, column 5 - line 343, column 107: " + [ m.constructor.name ]);
                  })());
              };
          };
      });
      var maxNode = Partial_Unsafe.unsafePartial(function (dictPartial) {
          return function (m) {
              var __unused = function (dictPartial1) {
                  return function ($dollar52) {
                      return $dollar52;
                  };
              };
              return __unused(dictPartial)((function () {
                  if (m instanceof Two && m.value3 instanceof Leaf) {
                      return {
                          key: m.value1, 
                          value: m.value2
                      };
                  };
                  if (m instanceof Two) {
                      return maxNode(m.value3);
                  };
                  if (m instanceof Three && m.value6 instanceof Leaf) {
                      return {
                          key: m.value4, 
                          value: m.value5
                      };
                  };
                  if (m instanceof Three) {
                      return maxNode(m.value6);
                  };
                  throw new Error("Failed pattern match at Data.Map line 330, column 33 - line 334, column 45: " + [ m.constructor.name ]);
              })());
          };
      });
      var comp = Data_Ord.compare(dictOrd);
      var down = Partial_Unsafe.unsafePartial(function (dictPartial) {
          return function (ctx) {
              return function (k) {
                  return function (m) {
                      if (m instanceof Leaf) {
                          return Data_Maybe.Nothing.value;
                      };
                      if (m instanceof Two) {
                          var $509 = comp(k)(m.value1);
                          if (m.value3 instanceof Leaf && $509 instanceof Data_Ordering.EQ) {
                              return new Data_Maybe.Just(new Data_Tuple.Tuple(m.value2, up(ctx)(Leaf.value)));
                          };
                          if ($509 instanceof Data_Ordering.EQ) {
                              var max = maxNode(m.value0);
                              return new Data_Maybe.Just(new Data_Tuple.Tuple(m.value2, removeMaxNode(new Data_List_Types.Cons(new TwoLeft(max.key, max.value, m.value3), ctx))(m.value0)));
                          };
                          if ($509 instanceof Data_Ordering.LT) {
                              return down(new Data_List_Types.Cons(new TwoLeft(m.value1, m.value2, m.value3), ctx))(k)(m.value0);
                          };
                          return down(new Data_List_Types.Cons(new TwoRight(m.value0, m.value1, m.value2), ctx))(k)(m.value3);
                      };
                      if (m instanceof Three) {
                          var leaves = (function () {
                              if (m.value0 instanceof Leaf && (m.value3 instanceof Leaf && m.value6 instanceof Leaf)) {
                                  return true;
                              };
                              return false;
                          })();
                          var $518 = comp(k)(m.value1);
                          var $519 = comp(k)(m.value4);
                          if (leaves && $518 instanceof Data_Ordering.EQ) {
                              return new Data_Maybe.Just(new Data_Tuple.Tuple(m.value2, fromZipper(dictOrd)(ctx)(new Two(Leaf.value, m.value4, m.value5, Leaf.value))));
                          };
                          if (leaves && $519 instanceof Data_Ordering.EQ) {
                              return new Data_Maybe.Just(new Data_Tuple.Tuple(m.value5, fromZipper(dictOrd)(ctx)(new Two(Leaf.value, m.value1, m.value2, Leaf.value))));
                          };
                          if ($518 instanceof Data_Ordering.EQ) {
                              var max = maxNode(m.value0);
                              return new Data_Maybe.Just(new Data_Tuple.Tuple(m.value2, removeMaxNode(new Data_List_Types.Cons(new ThreeLeft(max.key, max.value, m.value3, m.value4, m.value5, m.value6), ctx))(m.value0)));
                          };
                          if ($519 instanceof Data_Ordering.EQ) {
                              var max = maxNode(m.value3);
                              return new Data_Maybe.Just(new Data_Tuple.Tuple(m.value5, removeMaxNode(new Data_List_Types.Cons(new ThreeMiddle(m.value0, m.value1, m.value2, max.key, max.value, m.value6), ctx))(m.value3)));
                          };
                          if ($518 instanceof Data_Ordering.LT) {
                              return down(new Data_List_Types.Cons(new ThreeLeft(m.value1, m.value2, m.value3, m.value4, m.value5, m.value6), ctx))(k)(m.value0);
                          };
                          if ($518 instanceof Data_Ordering.GT && $519 instanceof Data_Ordering.LT) {
                              return down(new Data_List_Types.Cons(new ThreeMiddle(m.value0, m.value1, m.value2, m.value4, m.value5, m.value6), ctx))(k)(m.value3);
                          };
                          return down(new Data_List_Types.Cons(new ThreeRight(m.value0, m.value1, m.value2, m.value3, m.value4, m.value5), ctx))(k)(m.value6);
                      };
                      throw new Error("Failed pattern match at Data.Map line 280, column 36 - line 303, column 82: " + [ m.constructor.name ]);
                  };
              };
          };
      });
      return down(Data_List_Types.Nil.value);
  };
  var foldableMap = new Data_Foldable.Foldable(function (dictMonoid) {
      return function (f) {
          return function (m) {
              return Data_Foldable.foldMap(Data_List_Types.foldableList)(dictMonoid)(f)(values(m));
          };
      };
  }, function (f) {
      return function (z) {
          return function (m) {
              return Data_Foldable.foldl(Data_List_Types.foldableList)(f)(z)(values(m));
          };
      };
  }, function (f) {
      return function (z) {
          return function (m) {
              return Data_Foldable.foldr(Data_List_Types.foldableList)(f)(z)(values(m));
          };
      };
  });
  var findMin = function (v) {
      if (v instanceof Leaf) {
          return Data_Maybe.Nothing.value;
      };
      if (v instanceof Two) {
          return Data_Maybe.Just.create(Data_Maybe.fromMaybe({
              key: v.value1, 
              value: v.value2
          })(findMin(v.value0)));
      };
      if (v instanceof Three) {
          return Data_Maybe.Just.create(Data_Maybe.fromMaybe({
              key: v.value1, 
              value: v.value2
          })(findMin(v.value0)));
      };
      throw new Error("Failed pattern match at Data.Map line 206, column 1 - line 206, column 23: " + [ v.constructor.name ]);
  };
  var lookupGT = function (dictOrd) {
      return function (v) {
          return function (v1) {
              if (v1 instanceof Leaf) {
                  return Data_Maybe.Nothing.value;
              };
              if (v1 instanceof Two) {
                  var $541 = Data_Ord.compare(dictOrd)(v)(v1.value1);
                  if ($541 instanceof Data_Ordering.EQ) {
                      return findMin(v1.value3);
                  };
                  if ($541 instanceof Data_Ordering.LT) {
                      return Data_Maybe.Just.create(Data_Maybe.fromMaybe({
                          key: v1.value1, 
                          value: v1.value2
                      })(lookupGT(dictOrd)(v)(v1.value0)));
                  };
                  if ($541 instanceof Data_Ordering.GT) {
                      return lookupGT(dictOrd)(v)(v1.value3);
                  };
                  throw new Error("Failed pattern match at Data.Map line 189, column 37 - line 192, column 25: " + [ $541.constructor.name ]);
              };
              if (v1 instanceof Three) {
                  var $546 = Data_Ord.compare(dictOrd)(v)(v1.value1);
                  if ($546 instanceof Data_Ordering.EQ) {
                      return findMin(new Two(v1.value3, v1.value4, v1.value5, v1.value6));
                  };
                  if ($546 instanceof Data_Ordering.LT) {
                      return Data_Maybe.Just.create(Data_Maybe.fromMaybe({
                          key: v1.value1, 
                          value: v1.value2
                      })(lookupGT(dictOrd)(v)(v1.value0)));
                  };
                  if ($546 instanceof Data_Ordering.GT) {
                      return lookupGT(dictOrd)(v)(new Two(v1.value3, v1.value4, v1.value5, v1.value6));
                  };
                  throw new Error("Failed pattern match at Data.Map line 193, column 49 - line 196, column 41: " + [ $546.constructor.name ]);
              };
              throw new Error("Failed pattern match at Data.Map line 188, column 1 - line 188, column 26: " + [ v.constructor.name, v1.constructor.name ]);
          };
      };
  };
  var findMax = function (v) {
      if (v instanceof Leaf) {
          return Data_Maybe.Nothing.value;
      };
      if (v instanceof Two) {
          return Data_Maybe.Just.create(Data_Maybe.fromMaybe({
              key: v.value1, 
              value: v.value2
          })(findMax(v.value3)));
      };
      if (v instanceof Three) {
          return Data_Maybe.Just.create(Data_Maybe.fromMaybe({
              key: v.value4, 
              value: v.value5
          })(findMax(v.value6)));
      };
      throw new Error("Failed pattern match at Data.Map line 200, column 1 - line 200, column 23: " + [ v.constructor.name ]);
  };
  var lookupLT = function (dictOrd) {
      return function (v) {
          return function (v1) {
              if (v1 instanceof Leaf) {
                  return Data_Maybe.Nothing.value;
              };
              if (v1 instanceof Two) {
                  var $568 = Data_Ord.compare(dictOrd)(v)(v1.value1);
                  if ($568 instanceof Data_Ordering.EQ) {
                      return findMax(v1.value0);
                  };
                  if ($568 instanceof Data_Ordering.GT) {
                      return Data_Maybe.Just.create(Data_Maybe.fromMaybe({
                          key: v1.value1, 
                          value: v1.value2
                      })(lookupLT(dictOrd)(v)(v1.value3)));
                  };
                  if ($568 instanceof Data_Ordering.LT) {
                      return lookupLT(dictOrd)(v)(v1.value0);
                  };
                  throw new Error("Failed pattern match at Data.Map line 165, column 37 - line 168, column 24: " + [ $568.constructor.name ]);
              };
              if (v1 instanceof Three) {
                  var $573 = Data_Ord.compare(dictOrd)(v)(v1.value4);
                  if ($573 instanceof Data_Ordering.EQ) {
                      return findMax(new Two(v1.value0, v1.value1, v1.value2, v1.value3));
                  };
                  if ($573 instanceof Data_Ordering.GT) {
                      return Data_Maybe.Just.create(Data_Maybe.fromMaybe({
                          key: v1.value4, 
                          value: v1.value5
                      })(lookupLT(dictOrd)(v)(v1.value6)));
                  };
                  if ($573 instanceof Data_Ordering.LT) {
                      return lookupLT(dictOrd)(v)(new Two(v1.value0, v1.value1, v1.value2, v1.value3));
                  };
                  throw new Error("Failed pattern match at Data.Map line 169, column 49 - line 172, column 40: " + [ $573.constructor.name ]);
              };
              throw new Error("Failed pattern match at Data.Map line 164, column 1 - line 164, column 26: " + [ v.constructor.name, v1.constructor.name ]);
          };
      };
  };
  var eqMap = function (dictEq) {
      return function (dictEq1) {
          return new Data_Eq.Eq(function (m1) {
              return function (m2) {
                  return Data_Eq.eq(Data_List_Types.eqList(Data_Tuple.eqTuple(dictEq)(dictEq1)))(toList(m1))(toList(m2));
              };
          });
      };
  };
  var ordMap = function (dictOrd) {
      return function (dictOrd1) {
          return new Data_Ord.Ord(function () {
              return eqMap(dictOrd["__superclass_Data.Eq.Eq_0"]())(dictOrd1["__superclass_Data.Eq.Eq_0"]());
          }, function (m1) {
              return function (m2) {
                  return Data_Ord.compare(Data_List_Types.ordList(Data_Tuple.ordTuple(dictOrd)(dictOrd1)))(toList(m1))(toList(m2));
              };
          });
      };
  };

  /**
 *  | An empty map
 */  
  var empty = Leaf.value;

  /**
 *  | Convert any foldable collection of key/value pairs to a map.
 *  | On key collision, later values take precedence over earlier ones.
 */  
  var fromFoldable = function (dictOrd) {
      return function (dictFoldable) {
          return Data_Foldable.foldl(dictFoldable)(function (m) {
              return function (v) {
                  return insert(dictOrd)(v.value0)(v.value1)(m);
              };
          })(empty);
      };
  };

  /**
 *  | Delete a key and its corresponding value from a map.
 */  
  var $$delete = function (dictOrd) {
      return function (k) {
          return function (m) {
              return Data_Maybe.maybe(m)(Data_Tuple.snd)(pop(dictOrd)(k)(m));
          };
      };
  };

  /**
 *  | Check whether the underlying tree satisfies the 2-3 invariant
 *  |
 *  | This function is provided for internal use.
 */  
  var checkValid = function (tree) {
      var allHeights = function (v) {
          if (v instanceof Leaf) {
              return Control_Applicative.pure(Data_List_Types.applicativeList)(0);
          };
          if (v instanceof Two) {
              return Data_Functor.map(Data_List_Types.functorList)(function (n) {
                  return n + 1 | 0;
              })(Data_Semigroup.append(Data_List_Types.semigroupList)(allHeights(v.value0))(allHeights(v.value3)));
          };
          if (v instanceof Three) {
              return Data_Functor.map(Data_List_Types.functorList)(function (n) {
                  return n + 1 | 0;
              })(Data_Semigroup.append(Data_List_Types.semigroupList)(allHeights(v.value0))(Data_Semigroup.append(Data_List_Types.semigroupList)(allHeights(v.value3))(allHeights(v.value6))));
          };
          throw new Error("Failed pattern match at Data.Map line 121, column 3 - line 121, column 30: " + [ v.constructor.name ]);
      };
      return Data_List.length(Data_List.nub(Data_Eq.eqInt)(allHeights(tree))) === 1;
  };

  /**
 *  | Insert the value, delete a value, or update a value for a key in a map
 */  
  var alter = function (dictOrd) {
      return function (f) {
          return function (k) {
              return function (m) {
                  var $596 = f(lookup(dictOrd)(k)(m));
                  if ($596 instanceof Data_Maybe.Nothing) {
                      return $$delete(dictOrd)(k)(m);
                  };
                  if ($596 instanceof Data_Maybe.Just) {
                      return insert(dictOrd)(k)($596.value0)(m);
                  };
                  throw new Error("Failed pattern match at Data.Map line 348, column 15 - line 350, column 25: " + [ $596.constructor.name ]);
              };
          };
      };
  };

  /**
 *  | Convert any foldable collection of key/value pairs to a map.
 *  | On key collision, the values are configurably combined.
 */  
  var fromFoldableWith = function (dictOrd) {
      return function (dictFoldable) {
          return function (f) {
              var combine = function (v) {
                  return function (v1) {
                      if (v1 instanceof Data_Maybe.Just) {
                          return Data_Maybe.Just.create(f(v)(v1.value0));
                      };
                      if (v1 instanceof Data_Maybe.Nothing) {
                          return new Data_Maybe.Just(v);
                      };
                      throw new Error("Failed pattern match at Data.Map line 365, column 3 - line 365, column 38: " + [ v.constructor.name, v1.constructor.name ]);
                  };
              };
              return Data_Foldable.foldl(dictFoldable)(function (m) {
                  return function (v) {
                      return alter(dictOrd)(combine(v.value1))(v.value0)(m);
                  };
              })(empty);
          };
      };
  };

  /**
 *  | Compute the union of two maps, using the specified function
 *  | to combine values for duplicate keys.
 */  
  var unionWith = function (dictOrd) {
      return function (f) {
          return function (m1) {
              return function (m2) {
                  var go = function (m) {
                      return function (v) {
                          return alter(dictOrd)(function ($621) {
                              return Data_Maybe.Just.create(Data_Maybe.maybe(v.value1)(f(v.value1))($621));
                          })(v.value0)(m);
                      };
                  };
                  return Data_Foldable.foldl(Data_List_Types.foldableList)(go)(m2)(toList(m1));
              };
          };
      };
  };

  /**
 *  | Compute the union of two maps, preferring values from the first map in the case
 *  | of duplicate keys
 */  
  var union = function (dictOrd) {
      return unionWith(dictOrd)(Data_Function["const"]);
  };
  var semigroupMap = function (dictOrd) {
      return new Data_Semigroup.Semigroup(union(dictOrd));
  };
  var monoidMap = function (dictOrd) {
      return new Data_Monoid.Monoid(function () {
          return semigroupMap(dictOrd);
      }, empty);
  };

  /**
 *  | Convert a map to an unfoldable structure of key/value pairs
 */  
  var toUnfoldable = function (dictOrd) {
      return function (dictUnfoldable) {
          var go = function (v) {
              if (v instanceof Leaf) {
                  return Data_Maybe.Nothing.value;
              };
              if (v instanceof Two) {
                  return Data_Maybe.Just.create(new Data_Tuple.Tuple(new Data_Tuple.Tuple(v.value1, v.value2), Data_Semigroup.append(semigroupMap(dictOrd))(v.value0)(v.value3)));
              };
              if (v instanceof Three) {
                  return Data_Maybe.Just.create(new Data_Tuple.Tuple(new Data_Tuple.Tuple(v.value1, v.value2), new Two(v.value0, v.value4, v.value5, v.value6)));
              };
              throw new Error("Failed pattern match at Data.Map line 379, column 3 - line 379, column 20: " + [ v.constructor.name ]);
          };
          return Data_Unfoldable.unfoldr(dictUnfoldable)(go);
      };
  };
  var traversableMap = function (dictOrd) {
      return new Data_Traversable.Traversable(function () {
          return foldableMap;
      }, function () {
          return functorMap;
      }, function (dictApplicative) {
          return Data_Traversable.traverse(traversableMap(dictOrd))(dictApplicative)(Control_Category.id(Control_Category.categoryFn));
      }, function (dictApplicative) {
          return function (f) {
              return function (ms) {
                  return Data_Foldable.foldr(Data_List_Types.foldableList)(function (x) {
                      return function (acc) {
                          return Control_Apply.apply(dictApplicative["__superclass_Control.Apply.Apply_0"]())(Data_Functor.map((dictApplicative["__superclass_Control.Apply.Apply_0"]())["__superclass_Data.Functor.Functor_0"]())(union(dictOrd))(x))(acc);
                      };
                  })(Control_Applicative.pure(dictApplicative)(empty))(Data_Functor.map(Data_List_Types.functorList)(Data_Functor.map((dictApplicative["__superclass_Control.Apply.Apply_0"]())["__superclass_Data.Functor.Functor_0"]())(Data_Tuple.uncurry(singleton)))(Data_Functor.map(Data_List_Types.functorList)(Data_Traversable.traverse(Data_Tuple.traversableTuple)(dictApplicative)(f))(toList(ms))));
              };
          };
      });
  };

  /**
 *  | Compute the union of a collection of maps
 */  
  var unions = function (dictOrd) {
      return function (dictFoldable) {
          return Data_Foldable.foldl(dictFoldable)(union(dictOrd))(empty);
      };
  };

  /**
 *  | Update or delete the value for a key in a map
 */  
  var update = function (dictOrd) {
      return function (f) {
          return function (k) {
              return function (m) {
                  return alter(dictOrd)(Data_Maybe.maybe(Data_Maybe.Nothing.value)(f))(k)(m);
              };
          };
      };
  };
  exports["alter"] = alter;
  exports["checkValid"] = checkValid;
  exports["delete"] = $$delete;
  exports["empty"] = empty;
  exports["findMax"] = findMax;
  exports["findMin"] = findMin;
  exports["fromFoldable"] = fromFoldable;
  exports["fromFoldableWith"] = fromFoldableWith;
  exports["insert"] = insert;
  exports["isEmpty"] = isEmpty;
  exports["keys"] = keys;
  exports["lookup"] = lookup;
  exports["lookupGE"] = lookupGE;
  exports["lookupGT"] = lookupGT;
  exports["lookupLE"] = lookupLE;
  exports["lookupLT"] = lookupLT;
  exports["mapWithKey"] = mapWithKey;
  exports["member"] = member;
  exports["pop"] = pop;
  exports["showTree"] = showTree;
  exports["singleton"] = singleton;
  exports["size"] = size;
  exports["toList"] = toList;
  exports["toUnfoldable"] = toUnfoldable;
  exports["union"] = union;
  exports["unionWith"] = unionWith;
  exports["unions"] = unions;
  exports["update"] = update;
  exports["values"] = values;
  exports["eqMap"] = eqMap;
  exports["ordMap"] = ordMap;
  exports["showMap"] = showMap;
  exports["semigroupMap"] = semigroupMap;
  exports["monoidMap"] = monoidMap;
  exports["functorMap"] = functorMap;
  exports["foldableMap"] = foldableMap;
  exports["traversableMap"] = traversableMap;
})(PS["Data.Map"] = PS["Data.Map"] || {});
(function(exports) {
  
  /**
 *  | A data structure and functions for graphs
 */  
  "use strict";
  var Prelude = PS["Prelude"];
  var Data_Bifunctor = PS["Data.Bifunctor"];
  var Data_CatList = PS["Data.CatList"];
  var Data_Foldable = PS["Data.Foldable"];
  var Data_List = PS["Data.List"];
  var Data_Map = PS["Data.Map"];
  var Data_Maybe = PS["Data.Maybe"];
  var Data_Monoid = PS["Data.Monoid"];
  var Data_Tuple = PS["Data.Tuple"];
  var Data_Functor = PS["Data.Functor"];
  var Data_List_Types = PS["Data.List.Types"];
  var Data_Semigroup = PS["Data.Semigroup"];
  var Data_Boolean = PS["Data.Boolean"];        

  /**
 *  To defunctionalize the `topologicalSort` function and make it tail-recursive,
 *  we introduce this data type which captures what we intend to do at each stage
 *  of the recursion.
 */  
  var Emit = (function () {
      function Emit(value0) {
          this.value0 = value0;
      };
      Emit.create = function (value0) {
          return new Emit(value0);
      };
      return Emit;
  })();

  /**
 *  To defunctionalize the `topologicalSort` function and make it tail-recursive,
 *  we introduce this data type which captures what we intend to do at each stage
 *  of the recursion.
 */  
  var Visit = (function () {
      function Visit(value0) {
          this.value0 = value0;
      };
      Visit.create = function (value0) {
          return new Visit(value0);
      };
      return Visit;
  })();

  /**
 *  | A graph with vertices of type `v`.
 *  |
 *  | Edges refer to vertices using keys of type `k`.
 */  
  var Graph = function (x) {
      return x;
  };

  /**
 *  | List all vertices in a graph.
 */  
  var vertices = function (v) {
      return Data_Functor.map(Data_List_Types.functorList)(Data_Tuple.fst)(Data_Map.values(v));
  };

  /**
 *  | Unfold a `Graph` from a collection of keys and functions which label keys
 *  | and specify out-edges.
 */  
  var unfoldGraph = function (dictOrd) {
      return function (dictFunctor) {
          return function (dictFoldable) {
              return function (dictFoldable1) {
                  return function (ks) {
                      return function (label) {
                          return function (edges) {
                              return Data_Map.fromFoldable(dictOrd)(dictFoldable)(Data_Functor.map(dictFunctor)(function (k) {
                                  return new Data_Tuple.Tuple(k, new Data_Tuple.Tuple(label(k), Data_List.fromFoldable(dictFoldable1)(edges(k))));
                              })(ks));
                          };
                      };
                  };
              };
          };
      };
  };

  /**
 *  | Topologically sort the vertices of a graph.
 *  |
 *  | If the graph contains cycles, then the behavior is undefined.
 */  
  var topologicalSort = function (dictOrd) {
      return function (v) {
          var visit = function (__copy_state) {
              return function (__copy_stack) {
                  var state = __copy_state;
                  var stack = __copy_stack;
                  tco: while (true) {
                      var $15 = Data_CatList.uncons(stack);
                      if ($15 instanceof Data_Maybe.Nothing) {
                          return state;
                      };
                      if ($15 instanceof Data_Maybe.Just && $15.value0.value0 instanceof Emit) {
                          var state$prime = {
                              result: new Data_List_Types.Cons($15.value0.value0.value0, state.result), 
                              unvisited: state.unvisited
                          };
                          state = state$prime;
                          stack = $15.value0.value1;
                          continue tco;
                      };
                      if ($15 instanceof Data_Maybe.Just && $15.value0.value0 instanceof Visit) {
                          if (Data_Map.member(dictOrd)($15.value0.value0.value0)(state.unvisited)) {
                              var start = {
                                  result: state.result, 
                                  unvisited: Data_Map["delete"](dictOrd)($15.value0.value0.value0)(state.unvisited)
                              };
                              var next = Data_Maybe.maybe(Data_Monoid.mempty(Data_List_Types.monoidList))(Data_Tuple.snd)(Data_Map.lookup(dictOrd)($15.value0.value0.value0)(v));
                              var __tco_stack = Data_Semigroup.append(Data_CatList.semigroupCatList)(Data_CatList.fromFoldable(Data_List_Types.foldableList)(Data_Functor.map(Data_List_Types.functorList)(Visit.create)(next)))(Data_CatList.cons(new Emit($15.value0.value0.value0))($15.value0.value1));
                              state = start;
                              stack = __tco_stack;
                              continue tco;
                          };
                          if (Data_Boolean.otherwise) {
                              var __tco_state = state;
                              state = __tco_state;
                              stack = $15.value0.value1;
                              continue tco;
                          };
                      };
                      throw new Error("Failed pattern match at Data.Graph line 89, column 7 - line 107, column 40: " + [ $15.constructor.name ]);
                  };
              };
          };
          var initialState = {
              unvisited: v, 
              result: Data_List_Types.Nil.value
          };
          var go = function (__copy_v1) {
              var v1 = __copy_v1;
              tco: while (true) {
                  var $25 = Data_Map.findMin(v1.unvisited);
                  if ($25 instanceof Data_Maybe.Just) {
                      var __tco_v1 = visit(v1)(Data_CatList.fromFoldable(Data_Foldable.foldableArray)([ new Visit($25.value0.key) ]));
                      v1 = __tco_v1;
                      continue tco;
                  };
                  if ($25 instanceof Data_Maybe.Nothing) {
                      return v1.result;
                  };
                  throw new Error("Failed pattern match at Data.Graph line 83, column 7 - line 85, column 26: " + [ $25.constructor.name ]);
              };
          };
          return go(initialState);
      };
  };

  /**
 *  | Get the keys which are directly accessible from the given key.
 */  
  var outEdges = function (dictOrd) {
      return function (k) {
          return function (v) {
              return Data_Functor.map(Data_Maybe.functorMaybe)(Data_Tuple.snd)(Data_Map.lookup(dictOrd)(k)(v));
          };
      };
  };

  /**
 *  | Lookup a vertex by its key.
 */  
  var lookup = function (dictOrd) {
      return function (k) {
          return function (v) {
              return Data_Functor.map(Data_Maybe.functorMaybe)(Data_Tuple.fst)(Data_Map.lookup(dictOrd)(k)(v));
          };
      };
  };
  var functorGraph = new Data_Functor.Functor(function (f) {
      return function (v) {
          return Data_Functor.map(Data_Map.functorMap)(Data_Bifunctor.lmap(Data_Tuple.bifunctorTuple)(f))(v);
      };
  });

  /**
 *  | Create a `Graph` from a `Map` which maps vertices to their labels and
 *  | outgoing edges.
 */  
  var fromMap = Graph;
  exports["fromMap"] = fromMap;
  exports["lookup"] = lookup;
  exports["outEdges"] = outEdges;
  exports["topologicalSort"] = topologicalSort;
  exports["unfoldGraph"] = unfoldGraph;
  exports["vertices"] = vertices;
  exports["functorGraph"] = functorGraph;
})(PS["Data.Graph"] = PS["Data.Graph"] || {});
(function(exports) {
    "use strict";
  var Prelude = PS["Prelude"];
  var Control_Alt = PS["Control.Alt"];
  var Control_Alternative = PS["Control.Alternative"];
  var Control_Extend = PS["Control.Extend"];
  var Control_Comonad = PS["Control.Comonad"];
  var Control_Lazy = PS["Control.Lazy"];
  var Control_MonadPlus = PS["Control.MonadPlus"];
  var Control_MonadZero = PS["Control.MonadZero"];
  var Control_Plus = PS["Control.Plus"];
  var Data_Foldable = PS["Data.Foldable"];
  var Data_Lazy = PS["Data.Lazy"];
  var Data_Maybe = PS["Data.Maybe"];
  var Data_Monoid = PS["Data.Monoid"];
  var Data_Newtype = PS["Data.Newtype"];
  var Data_NonEmpty = PS["Data.NonEmpty"];
  var Data_Traversable = PS["Data.Traversable"];
  var Data_Tuple = PS["Data.Tuple"];
  var Data_Unfoldable = PS["Data.Unfoldable"];
  var Data_Show = PS["Data.Show"];
  var Data_Semigroup = PS["Data.Semigroup"];
  var Data_Eq = PS["Data.Eq"];
  var Data_Ord = PS["Data.Ord"];
  var Data_Ordering = PS["Data.Ordering"];
  var Data_Function = PS["Data.Function"];
  var Control_Semigroupoid = PS["Control.Semigroupoid"];
  var Data_Functor = PS["Data.Functor"];
  var Control_Applicative = PS["Control.Applicative"];
  var Control_Apply = PS["Control.Apply"];
  var Control_Monad = PS["Control.Monad"];
  var Control_Bind = PS["Control.Bind"];        

  /**
 *  | A lazy linked list.
 */  
  var List = function (x) {
      return x;
  };

  /**
 *  | A list is either empty (represented by the `Nil` constructor) or non-empty, in
 *  | which case it consists of a head element, and another list (represented by the
 *  | `Cons` constructor).
 */  
  var Nil = (function () {
      function Nil() {

      };
      Nil.value = new Nil();
      return Nil;
  })();

  /**
 *  | A list is either empty (represented by the `Nil` constructor) or non-empty, in
 *  | which case it consists of a head element, and another list (represented by the
 *  | `Cons` constructor).
 */  
  var Cons = (function () {
      function Cons(value0, value1) {
          this.value0 = value0;
          this.value1 = value1;
      };
      Cons.create = function (value0) {
          return function (value1) {
              return new Cons(value0, value1);
          };
      };
      return Cons;
  })();
  var NonEmptyList = function (x) {
      return x;
  };

  /**
 *  | The empty list.
 *  |
 *  | Running time: `O(1)`
 */  
  var nil = List(Data_Lazy.defer(function (v) {
      return Nil.value;
  }));
  var newtypeNonEmptyList = new Data_Newtype.Newtype(function (n) {
      return n;
  }, NonEmptyList);
  var newtypeList = new Data_Newtype.Newtype(function (n) {
      return n;
  }, List);

  /**
 *  | Unwrap a lazy linked list
 */  
  var step = function ($170) {
      return Data_Lazy.force(Data_Newtype.unwrap(newtypeList)($170));
  };
  var semigroupList = new Data_Semigroup.Semigroup(function (xs) {
      return function (ys) {
          var go = function (v) {
              if (v instanceof Nil) {
                  return step(ys);
              };
              if (v instanceof Cons) {
                  return new Cons(v.value0, Data_Semigroup.append(semigroupList)(v.value1)(ys));
              };
              throw new Error("Failed pattern match at Data.List.Lazy.Types line 88, column 5 - line 88, column 21: " + [ v.constructor.name ]);
          };
          return Data_Functor.map(Data_Lazy.functorLazy)(go)(Data_Newtype.unwrap(newtypeList)(xs));
      };
  });
  var showList = function (dictShow) {
      return new Data_Show.Show(function (xs) {
          var go = function (v) {
              if (v instanceof Nil) {
                  return "Nil";
              };
              if (v instanceof Cons) {
                  return "(Cons " + (Data_Show.show(dictShow)(v.value0) + (" " + (go(step(v.value1)) + ")")));
              };
              throw new Error("Failed pattern match at Data.List.Lazy.Types line 58, column 3 - line 63, column 1: " + [ v.constructor.name ]);
          };
          return "fromStrict (" + (go(step(xs)) + ")");
      });
  };
  var showNonEmptyList = function (dictShow) {
      return new Data_Show.Show(function (v) {
          return "(NonEmptyList " + (Data_Show.show(Data_Lazy.showLazy(Data_NonEmpty.showNonEmpty(dictShow)(showList(dictShow))))(v) + ")");
      });
  };
  var monoidList = new Data_Monoid.Monoid(function () {
      return semigroupList;
  }, nil);
  var lazyList = new Control_Lazy.Lazy(function (f) {
      return List(Data_Lazy.defer(function ($171) {
          return step(f($171));
      }));
  });
  var functorList = new Data_Functor.Functor(function (f) {
      return function (xs) {
          var go = function (v) {
              if (v instanceof Nil) {
                  return Nil.value;
              };
              if (v instanceof Cons) {
                  return new Cons(f(v.value0), Data_Functor.map(functorList)(f)(v.value1));
              };
              throw new Error("Failed pattern match at Data.List.Lazy.Types line 97, column 5 - line 97, column 17: " + [ v.constructor.name ]);
          };
          return Data_Functor.map(Data_Lazy.functorLazy)(go)(Data_Newtype.unwrap(newtypeList)(xs));
      };
  });
  var functorNonEmptyList = new Data_Functor.Functor(function (f) {
      return function (v) {
          return Data_Functor.map(Data_Lazy.functorLazy)(Data_Functor.map(Data_NonEmpty.functorNonEmpty(functorList))(f))(v);
      };
  });
  var foldableList = new Data_Foldable.Foldable(function (dictMonoid) {
      return function (f) {
          return function (xs) {
              var go = function (v) {
                  if (v instanceof Nil) {
                      return Data_Monoid.mempty(dictMonoid);
                  };
                  if (v instanceof Cons) {
                      return Data_Semigroup.append(dictMonoid["__superclass_Data.Semigroup.Semigroup_0"]())(f(v.value0))(Data_Foldable.foldMap(foldableList)(dictMonoid)(f)(v.value1));
                  };
                  throw new Error("Failed pattern match at Data.List.Lazy.Types line 113, column 5 - line 113, column 20: " + [ v.constructor.name ]);
              };
              return go(step(xs));
          };
      };
  }, function (o) {
      return function (b) {
          return function (xs) {
              var go = function (v) {
                  if (v instanceof Nil) {
                      return b;
                  };
                  if (v instanceof Cons) {
                      return Data_Foldable.foldl(foldableList)(o)(o(b)(v.value0))(v.value1);
                  };
                  throw new Error("Failed pattern match at Data.List.Lazy.Types line 108, column 5 - line 108, column 15: " + [ v.constructor.name ]);
              };
              return go(step(xs));
          };
      };
  }, function (o) {
      return function (b) {
          return function (xs) {
              var go = function (v) {
                  if (v instanceof Nil) {
                      return b;
                  };
                  if (v instanceof Cons) {
                      return o(v.value0)(Data_Foldable.foldr(foldableList)(o)(b)(v.value1));
                  };
                  throw new Error("Failed pattern match at Data.List.Lazy.Types line 103, column 5 - line 103, column 15: " + [ v.constructor.name ]);
              };
              return go(step(xs));
          };
      };
  });
  var foldableNonEmptyList = new Data_Foldable.Foldable(function (dictMonoid) {
      return function (f) {
          return function (v) {
              return Data_Foldable.foldMap(Data_NonEmpty.foldableNonEmpty(foldableList))(dictMonoid)(f)(Data_Lazy.force(v));
          };
      };
  }, function (f) {
      return function (b) {
          return function (v) {
              return Data_Foldable.foldl(Data_NonEmpty.foldableNonEmpty(foldableList))(f)(b)(Data_Lazy.force(v));
          };
      };
  }, function (f) {
      return function (b) {
          return function (v) {
              return Data_Foldable.foldr(Data_NonEmpty.foldableNonEmpty(foldableList))(f)(b)(Data_Lazy.force(v));
          };
      };
  });
  var eqList = function (dictEq) {
      return new Data_Eq.Eq(function (xs) {
          return function (ys) {
              var go = function (__copy_v) {
                  return function (__copy_v1) {
                      var v = __copy_v;
                      var v1 = __copy_v1;
                      tco: while (true) {
                          if (v instanceof Nil && v1 instanceof Nil) {
                              return true;
                          };
                          if (v instanceof Cons && (v1 instanceof Cons && Data_Eq.eq(dictEq)(v.value0)(v1.value0))) {
                              var __tco_v = step(v.value1);
                              var __tco_v1 = step(v1.value1);
                              v = __tco_v;
                              v1 = __tco_v1;
                              continue tco;
                          };
                          return false;
                      };
                  };
              };
              return go(step(xs))(step(ys));
          };
      });
  };
  var eqNonEmptyList = function (dictEq) {
      return Data_Lazy.eqLazy(Data_NonEmpty.eqNonEmpty(dictEq)(eqList(dictEq)));
  };
  var ordList = function (dictOrd) {
      return new Data_Ord.Ord(function () {
          return eqList(dictOrd["__superclass_Data.Eq.Eq_0"]());
      }, function (xs) {
          return function (ys) {
              var go = function (__copy_v) {
                  return function (__copy_v1) {
                      var v = __copy_v;
                      var v1 = __copy_v1;
                      tco: while (true) {
                          if (v instanceof Nil && v1 instanceof Nil) {
                              return Data_Ordering.EQ.value;
                          };
                          if (v instanceof Nil) {
                              return Data_Ordering.LT.value;
                          };
                          if (v1 instanceof Nil) {
                              return Data_Ordering.GT.value;
                          };
                          if (v instanceof Cons && v1 instanceof Cons) {
                              var $97 = Data_Ord.compare(dictOrd)(v.value0)(v1.value0);
                              if ($97 instanceof Data_Ordering.EQ) {
                                  var __tco_v = step(v.value1);
                                  var __tco_v1 = step(v1.value1);
                                  v = __tco_v;
                                  v1 = __tco_v1;
                                  continue tco;
                              };
                              return $97;
                          };
                          throw new Error("Failed pattern match at Data.List.Lazy.Types line 72, column 3 - line 80, column 23: " + [ v.constructor.name, v1.constructor.name ]);
                      };
                  };
              };
              return go(step(xs))(step(ys));
          };
      });
  };
  var ordNonEmptyList = function (dictOrd) {
      return Data_Lazy.ordLazy(Data_NonEmpty.ordNonEmpty(dictOrd)(ordList(dictOrd)));
  };

  /**
 *  | Attach an element to the front of a lazy list.
 *  |
 *  | Running time: `O(1)`
 */  
  var cons = function (x) {
      return function (xs) {
          return List(Data_Lazy.defer(function (v) {
              return new Cons(x, xs);
          }));
      };
  };
  var extendList = new Control_Extend.Extend(function () {
      return functorList;
  }, function (f) {
      return function (l) {
          var go = function (a) {
              return function (v) {
                  var acc$prime = cons(a)(v.acc);
                  return {
                      val: cons(f(acc$prime))(v.val), 
                      acc: acc$prime
                  };
              };
          };
          var $107 = step(l);
          if ($107 instanceof Nil) {
              return nil;
          };
          if ($107 instanceof Cons) {
              return cons(f(l))((Data_Foldable.foldr(foldableList)(go)({
                  val: nil, 
                  acc: nil
              })($107.value1)).val);
          };
          throw new Error("Failed pattern match at Data.List.Lazy.Types line 161, column 5 - line 164, column 55: " + [ $107.constructor.name ]);
      };
  });
  var extendNonEmptyList = new Control_Extend.Extend(function () {
      return functorNonEmptyList;
  }, function (f) {
      return function (v) {
          var go = function (a) {
              return function (v1) {
                  return {
                      val: cons(f(Data_Lazy.defer(function (v2) {
                          return new Data_NonEmpty.NonEmpty(a, v1.acc);
                      })))(v1.val), 
                      acc: cons(a)(v1.acc)
                  };
              };
          };
          var $117 = Data_Lazy.force(v);
          return NonEmptyList(Data_Lazy.defer(function (v1) {
              return new Data_NonEmpty.NonEmpty(f(v), (Data_Foldable.foldr(foldableList)(go)({
                  val: nil, 
                  acc: nil
              })($117.value1)).val);
          }));
      };
  });
  var toList = function (v) {
      var $122 = Data_Lazy.force(v);
      return cons($122.value0)($122.value1);
  };
  var semigroupNonEmptyList = new Data_Semigroup.Semigroup(function (v) {
      return function (as$prime) {
          var $127 = Data_Lazy.force(v);
          return Data_Lazy.defer(function (v1) {
              return new Data_NonEmpty.NonEmpty($127.value0, Data_Semigroup.append(semigroupList)($127.value1)(toList(as$prime)));
          });
      };
  });
  var traversableList = new Data_Traversable.Traversable(function () {
      return foldableList;
  }, function () {
      return functorList;
  }, function (dictApplicative) {
      return function (xs) {
          var go = function (v) {
              if (v instanceof Nil) {
                  return Control_Applicative.pure(dictApplicative)(nil);
              };
              if (v instanceof Cons) {
                  return Control_Apply.apply(dictApplicative["__superclass_Control.Apply.Apply_0"]())(Data_Functor.map((dictApplicative["__superclass_Control.Apply.Apply_0"]())["__superclass_Data.Functor.Functor_0"]())(cons)(v.value0))(Data_Traversable.sequence(traversableList)(dictApplicative)(v.value1));
              };
              throw new Error("Failed pattern match at Data.List.Lazy.Types line 130, column 5 - line 130, column 22: " + [ v.constructor.name ]);
          };
          return go(step(xs));
      };
  }, function (dictApplicative) {
      return function (f) {
          return function (xs) {
              var go = function (v) {
                  if (v instanceof Nil) {
                      return Control_Applicative.pure(dictApplicative)(nil);
                  };
                  if (v instanceof Cons) {
                      return Control_Apply.apply(dictApplicative["__superclass_Control.Apply.Apply_0"]())(Data_Functor.map((dictApplicative["__superclass_Control.Apply.Apply_0"]())["__superclass_Data.Functor.Functor_0"]())(cons)(f(v.value0)))(Data_Traversable.traverse(traversableList)(dictApplicative)(f)(v.value1));
                  };
                  throw new Error("Failed pattern match at Data.List.Lazy.Types line 125, column 5 - line 125, column 22: " + [ v.constructor.name ]);
              };
              return go(step(xs));
          };
      };
  });
  var traversableNonEmptyList = new Data_Traversable.Traversable(function () {
      return foldableNonEmptyList;
  }, function () {
      return functorNonEmptyList;
  }, function (dictApplicative) {
      return function (v) {
          return Data_Functor.map((dictApplicative["__superclass_Control.Apply.Apply_0"]())["__superclass_Data.Functor.Functor_0"]())(function (xxs) {
              return NonEmptyList(Data_Lazy.defer(function (v1) {
                  return xxs;
              }));
          })(Data_Traversable.sequence(Data_NonEmpty.traversableNonEmpty(traversableList))(dictApplicative)(Data_Lazy.force(v)));
      };
  }, function (dictApplicative) {
      return function (f) {
          return function (v) {
              return Data_Functor.map((dictApplicative["__superclass_Control.Apply.Apply_0"]())["__superclass_Data.Functor.Functor_0"]())(function (xxs) {
                  return NonEmptyList(Data_Lazy.defer(function (v1) {
                      return xxs;
                  }));
              })(Data_Traversable.traverse(Data_NonEmpty.traversableNonEmpty(traversableList))(dictApplicative)(f)(Data_Lazy.force(v)));
          };
      };
  });
  var unfoldableList = new Data_Unfoldable.Unfoldable(function (f) {
      return function (b) {
          var go = function (v) {
              if (v instanceof Data_Maybe.Nothing) {
                  return nil;
              };
              if (v instanceof Data_Maybe.Just) {
                  return cons(v.value0.value0)(Control_Lazy.defer(lazyList)(function (v1) {
                      return go(f(v.value0.value1));
                  }));
              };
              throw new Error("Failed pattern match at Data.List.Lazy.Types line 117, column 3 - line 120, column 55: " + [ v.constructor.name ]);
          };
          return go(f(b));
      };
  });
  var comonadNonEmptyList = new Control_Comonad.Comonad(function () {
      return extendNonEmptyList;
  }, function (v) {
      return Data_NonEmpty.head(Data_Lazy.force(v));
  });
  var monadList = new Control_Monad.Monad(function () {
      return applicativeList;
  }, function () {
      return bindList;
  });
  var bindList = new Control_Bind.Bind(function () {
      return applyList;
  }, function (xs) {
      return function (f) {
          var go = function (v) {
              if (v instanceof Nil) {
                  return Nil.value;
              };
              if (v instanceof Cons) {
                  return step(Data_Semigroup.append(semigroupList)(f(v.value0))(Control_Bind.bind(bindList)(v.value1)(f)));
              };
              throw new Error("Failed pattern match at Data.List.Lazy.Types line 142, column 5 - line 142, column 17: " + [ v.constructor.name ]);
          };
          return Data_Functor.map(Data_Lazy.functorLazy)(go)(Data_Newtype.unwrap(newtypeList)(xs));
      };
  });
  var applyList = new Control_Apply.Apply(function () {
      return functorList;
  }, Control_Monad.ap(monadList));
  var applicativeList = new Control_Applicative.Applicative(function () {
      return applyList;
  }, Data_Function.flip(cons)(nil));
  var applyNonEmptyList = new Control_Apply.Apply(function () {
      return functorNonEmptyList;
  }, function (v) {
      return function (v1) {
          var $153 = Data_Lazy.force(v);
          var $154 = Data_Lazy.force(v1);
          return Data_Lazy.defer(function (v2) {
              return new Data_NonEmpty.NonEmpty($153.value0($154.value0), Data_Semigroup.append(semigroupList)(Control_Apply.apply(applyList)($153.value1)(cons($154.value0)(nil)))(Control_Apply.apply(applyList)(cons($153.value0)($153.value1))($154.value1)));
          });
      };
  });
  var bindNonEmptyList = new Control_Bind.Bind(function () {
      return applyNonEmptyList;
  }, function (v) {
      return function (f) {
          var $162 = Data_Lazy.force(v);
          var $163 = Data_Lazy.force(Data_Newtype.unwrap(newtypeNonEmptyList)(f($162.value0)));
          return Data_Lazy.defer(function (v1) {
              return new Data_NonEmpty.NonEmpty($163.value0, Data_Semigroup.append(semigroupList)($163.value1)(Control_Bind.bind(bindList)($162.value1)(function ($172) {
                  return toList(f($172));
              })));
          });
      };
  });
  var altNonEmptyList = new Control_Alt.Alt(function () {
      return functorNonEmptyList;
  }, Data_Semigroup.append(semigroupNonEmptyList));
  var altList = new Control_Alt.Alt(function () {
      return functorList;
  }, Data_Semigroup.append(semigroupList));
  var plusList = new Control_Plus.Plus(function () {
      return altList;
  }, nil);
  var alternativeList = new Control_Alternative.Alternative(function () {
      return applicativeList;
  }, function () {
      return plusList;
  });
  var monadZeroList = new Control_MonadZero.MonadZero(function () {
      return alternativeList;
  }, function () {
      return monadList;
  });
  var monadPlusList = new Control_MonadPlus.MonadPlus(function () {
      return monadZeroList;
  });
  var applicativeNonEmptyList = new Control_Applicative.Applicative(function () {
      return applyNonEmptyList;
  }, function (a) {
      return Data_Lazy.defer(function (v) {
          return Data_NonEmpty.singleton(plusList)(a);
      });
  });
  var monadNonEmptyList = new Control_Monad.Monad(function () {
      return applicativeNonEmptyList;
  }, function () {
      return bindNonEmptyList;
  });
  exports["List"] = List;
  exports["NonEmptyList"] = NonEmptyList;
  exports["Nil"] = Nil;
  exports["Cons"] = Cons;
  exports["cons"] = cons;
  exports["nil"] = nil;
  exports["step"] = step;
  exports["toList"] = toList;
  exports["newtypeList"] = newtypeList;
  exports["showList"] = showList;
  exports["eqList"] = eqList;
  exports["ordList"] = ordList;
  exports["lazyList"] = lazyList;
  exports["semigroupList"] = semigroupList;
  exports["monoidList"] = monoidList;
  exports["functorList"] = functorList;
  exports["foldableList"] = foldableList;
  exports["unfoldableList"] = unfoldableList;
  exports["traversableList"] = traversableList;
  exports["applyList"] = applyList;
  exports["applicativeList"] = applicativeList;
  exports["bindList"] = bindList;
  exports["monadList"] = monadList;
  exports["altList"] = altList;
  exports["plusList"] = plusList;
  exports["alternativeList"] = alternativeList;
  exports["monadZeroList"] = monadZeroList;
  exports["monadPlusList"] = monadPlusList;
  exports["extendList"] = extendList;
  exports["newtypeNonEmptyList"] = newtypeNonEmptyList;
  exports["eqNonEmptyList"] = eqNonEmptyList;
  exports["ordNonEmptyList"] = ordNonEmptyList;
  exports["showNonEmptyList"] = showNonEmptyList;
  exports["functorNonEmptyList"] = functorNonEmptyList;
  exports["applyNonEmptyList"] = applyNonEmptyList;
  exports["applicativeNonEmptyList"] = applicativeNonEmptyList;
  exports["bindNonEmptyList"] = bindNonEmptyList;
  exports["monadNonEmptyList"] = monadNonEmptyList;
  exports["altNonEmptyList"] = altNonEmptyList;
  exports["extendNonEmptyList"] = extendNonEmptyList;
  exports["comonadNonEmptyList"] = comonadNonEmptyList;
  exports["semigroupNonEmptyList"] = semigroupNonEmptyList;
  exports["foldableNonEmptyList"] = foldableNonEmptyList;
  exports["traversableNonEmptyList"] = traversableNonEmptyList;
})(PS["Data.List.Lazy.Types"] = PS["Data.List.Lazy.Types"] || {});
(function(exports) {
  
  /**
 *  | This module defines a type of _lazy_ linked lists, and associated helper
 *  | functions and type class instances.
 *  |
 *  | _Note_: Depending on your use-case, you may prefer to use
 *  | `Data.Sequence` instead, which might give better performance for certain
 *  | use cases. This module is an improvement over `Data.Array` when working with
 *  | immutable lists of data in a purely-functional setting, but does not have
 *  | good random-access performance.
 */  
  "use strict";
  var Prelude = PS["Prelude"];
  var Control_Lazy = PS["Control.Lazy"];
  var Data_Foldable = PS["Data.Foldable"];
  var Data_Lazy = PS["Data.Lazy"];
  var Data_List_Lazy_Types = PS["Data.List.Lazy.Types"];
  var Data_Maybe = PS["Data.Maybe"];
  var Data_Newtype = PS["Data.Newtype"];
  var Data_NonEmpty = PS["Data.NonEmpty"];
  var Data_Traversable = PS["Data.Traversable"];
  var Data_Tuple = PS["Data.Tuple"];
  var Data_Unfoldable = PS["Data.Unfoldable"];
  var Control_Apply = PS["Control.Apply"];
  var Data_Functor = PS["Data.Functor"];
  var Data_Ring = PS["Data.Ring"];
  var Data_Ord = PS["Data.Ord"];
  var Data_Semiring = PS["Data.Semiring"];
  var Control_Applicative = PS["Control.Applicative"];
  var Data_Boolean = PS["Data.Boolean"];
  var Control_Bind = PS["Control.Bind"];
  var Control_Semigroupoid = PS["Control.Semigroupoid"];
  var Data_Eq = PS["Data.Eq"];
  var Data_Ordering = PS["Data.Ordering"];
  var Data_HeytingAlgebra = PS["Data.HeytingAlgebra"];
  var Data_Semigroup = PS["Data.Semigroup"];
  var Data_Function = PS["Data.Function"];
  var Control_Category = PS["Control.Category"];        
  var zipWith = function (f) {
      return function (xs) {
          return function (ys) {
              var go = function (v) {
                  return function (v1) {
                      if (v instanceof Data_List_Lazy_Types.Nil) {
                          return Data_List_Lazy_Types.Nil.value;
                      };
                      if (v1 instanceof Data_List_Lazy_Types.Nil) {
                          return Data_List_Lazy_Types.Nil.value;
                      };
                      if (v instanceof Data_List_Lazy_Types.Cons && v1 instanceof Data_List_Lazy_Types.Cons) {
                          return new Data_List_Lazy_Types.Cons(f(v.value0)(v1.value0), zipWith(f)(v.value1)(v1.value1));
                      };
                      throw new Error("Failed pattern match at Data.List.Lazy line 638, column 3 - line 638, column 17: " + [ v.constructor.name, v1.constructor.name ]);
                  };
              };
              return Control_Apply.apply(Data_Lazy.applyLazy)(Data_Functor.map(Data_Lazy.functorLazy)(go)(Data_Newtype.unwrap(Data_List_Lazy_Types.newtypeList)(xs)))(Data_Newtype.unwrap(Data_List_Lazy_Types.newtypeList)(ys));
          };
      };
  };

  /**
 *  | A generalization of `zipWith` which accumulates results in some `Applicative`
 *  | functor.
 */  
  var zipWithA = function (dictApplicative) {
      return function (f) {
          return function (xs) {
              return function (ys) {
                  return Data_Traversable.sequence(Data_List_Lazy_Types.traversableList)(dictApplicative)(zipWith(f)(xs)(ys));
              };
          };
      };
  };

  /**
 *  | Collect pairs of elements at the same positions in two lists.
 *  |
 *  | Running time: `O(min(m, n))`
 */  
  var zip = zipWith(Data_Tuple.Tuple.create);
  var updateAt = function (n) {
      return function (x) {
          return function (xs) {
              var go = function (v) {
                  return function (v1) {
                      if (v1 instanceof Data_List_Lazy_Types.Nil) {
                          return Data_List_Lazy_Types.Nil.value;
                      };
                      if (v === 0 && v1 instanceof Data_List_Lazy_Types.Cons) {
                          return new Data_List_Lazy_Types.Cons(x, v1.value1);
                      };
                      if (v1 instanceof Data_List_Lazy_Types.Cons) {
                          return new Data_List_Lazy_Types.Cons(v1.value0, updateAt(v - 1)(x)(v1.value1));
                      };
                      throw new Error("Failed pattern match at Data.List.Lazy line 347, column 3 - line 347, column 17: " + [ v.constructor.name, v1.constructor.name ]);
                  };
              };
              return Data_Functor.map(Data_Lazy.functorLazy)(go(n))(Data_Newtype.unwrap(Data_List_Lazy_Types.newtypeList)(xs));
          };
      };
  };

  /**
 *  | Transforms a list of pairs into a list of first components and a list of
 *  | second components.
 */  
  var unzip = Data_Foldable.foldr(Data_List_Lazy_Types.foldableList)(function (v) {
      return function (v1) {
          return new Data_Tuple.Tuple(Data_List_Lazy_Types.cons(v.value0)(v1.value0), Data_List_Lazy_Types.cons(v.value1)(v1.value1));
      };
  })(new Data_Tuple.Tuple(Data_List_Lazy_Types.nil, Data_List_Lazy_Types.nil));

  /**
 *  | Break a list into its first element, and the remaining elements,
 *  | or `Nothing` if the list is empty.
 *  |
 *  | Running time: `O(1)`
 */  
  var uncons = function (xs) {
      var $75 = Data_List_Lazy_Types.step(xs);
      if ($75 instanceof Data_List_Lazy_Types.Nil) {
          return Data_Maybe.Nothing.value;
      };
      if ($75 instanceof Data_List_Lazy_Types.Cons) {
          return new Data_Maybe.Just({
              head: $75.value0, 
              tail: $75.value1
          });
      };
      throw new Error("Failed pattern match at Data.List.Lazy line 265, column 13 - line 267, column 54: " + [ $75.constructor.name ]);
  };

  /**
 *  | Convert a list into any unfoldable structure.
 *  |
 *  | Running time: `O(n)`
 */  
  var toUnfoldable = function (dictUnfoldable) {
      return Data_Unfoldable.unfoldr(dictUnfoldable)(function (xs) {
          return Data_Functor.map(Data_Maybe.functorMaybe)(function (rec) {
              return new Data_Tuple.Tuple(rec.head, rec.tail);
          })(uncons(xs));
      });
  };
  var takeWhile = function (p) {
      return function (xs) {
          var go = function (v) {
              if (v instanceof Data_List_Lazy_Types.Cons && p(v.value0)) {
                  return new Data_List_Lazy_Types.Cons(v.value0, takeWhile(p)(v.value1));
              };
              return Data_List_Lazy_Types.Nil.value;
          };
          return Data_Functor.map(Data_Lazy.functorLazy)(go)(Data_Newtype.unwrap(Data_List_Lazy_Types.newtypeList)(xs));
      };
  };
  var take = function (n) {
      return function (xs) {
          var go = function (v) {
              return function (v1) {
                  if (v <= 0) {
                      return Data_List_Lazy_Types.Nil.value;
                  };
                  if (v1 instanceof Data_List_Lazy_Types.Nil) {
                      return Data_List_Lazy_Types.Nil.value;
                  };
                  if (v1 instanceof Data_List_Lazy_Types.Cons) {
                      return new Data_List_Lazy_Types.Cons(v1.value0, take(v - 1)(v1.value1));
                  };
                  throw new Error("Failed pattern match at Data.List.Lazy line 471, column 3 - line 471, column 24: " + [ v.constructor.name, v1.constructor.name ]);
              };
          };
          return Data_Functor.map(Data_Lazy.functorLazy)(go(n))(Data_Newtype.unwrap(Data_List_Lazy_Types.newtypeList)(xs));
      };
  };

  /**
 *  | Get all but the first element of a list, or `Nothing` if the list is empty.
 *  |
 *  | Running time: `O(1)`
 */  
  var tail = function (xs) {
      return Data_Functor.map(Data_Maybe.functorMaybe)(function (v) {
          return v.tail;
      })(uncons(xs));
  };
  var span = function (p) {
      return function (xs) {
          var $85 = uncons(xs);
          if ($85 instanceof Data_Maybe.Just && p($85.value0.head)) {
              var $86 = span(p)($85.value0.tail);
              return {
                  init: Data_List_Lazy_Types.cons($85.value0.head)($86.init), 
                  rest: $86.rest
              };
          };
          return {
              init: Data_List_Lazy_Types.nil, 
              rest: xs
          };
      };
  };

  /**
 * ------------------------------------------------------------------------------
 *  Extending arrays ------------------------------------------------------------
 * ------------------------------------------------------------------------------
 *  | Append an element to the end of a list, creating a new list.
 *  |
 *  | Running time: `O(n)`
 */  
  var snoc = function (xs) {
      return function (x) {
          return Data_Foldable.foldr(Data_List_Lazy_Types.foldableList)(Data_List_Lazy_Types.cons)(Data_List_Lazy_Types.cons(x)(Data_List_Lazy_Types.nil))(xs);
      };
  };

  /**
 * ------------------------------------------------------------------------------
 *  List creation ---------------------------------------------------------------
 * ------------------------------------------------------------------------------
 *  | Create a list with a single element.
 *  |
 *  | Running time: `O(1)`
 */  
  var singleton = function (a) {
      return Data_List_Lazy_Types.cons(a)(Data_List_Lazy_Types.nil);
  };

  /**
 * ------------------------------------------------------------------------------
 *  Transformations -------------------------------------------------------------
 * ------------------------------------------------------------------------------
 *  | Reverse a list.
 *  |
 *  | Running time: `O(n)`
 */  
  var reverse = function (xs) {
      var go = function (__copy_acc) {
          return function (__copy_v) {
              var acc = __copy_acc;
              var v = __copy_v;
              tco: while (true) {
                  if (v instanceof Data_List_Lazy_Types.Nil) {
                      return acc;
                  };
                  if (v instanceof Data_List_Lazy_Types.Cons) {
                      var __tco_acc = Data_List_Lazy_Types.cons(v.value0)(acc);
                      var __tco_v = Data_List_Lazy_Types.step(v.value1);
                      acc = __tco_acc;
                      v = __tco_v;
                      continue tco;
                  };
                  throw new Error("Failed pattern match at Data.List.Lazy line 387, column 1 - line 390, column 49: " + [ acc.constructor.name, v.constructor.name ]);
              };
          };
      };
      return go(Data_List_Lazy_Types.nil)(Data_List_Lazy_Types.step(xs));
  };
  var replicateM = function (dictMonad) {
      return function (n) {
          return function (m) {
              if (n < 1) {
                  return Control_Applicative.pure(dictMonad["__superclass_Control.Applicative.Applicative_0"]())(Data_List_Lazy_Types.nil);
              };
              if (Data_Boolean.otherwise) {
                  return Control_Bind.bind(dictMonad["__superclass_Control.Bind.Bind_1"]())(m)(function (v) {
                      return Control_Bind.bind(dictMonad["__superclass_Control.Bind.Bind_1"]())(replicateM(dictMonad)(n - 1)(m))(function (v1) {
                          return Control_Applicative.pure(dictMonad["__superclass_Control.Applicative.Applicative_0"]())(Data_List_Lazy_Types.cons(v)(v1));
                      });
                  });
              };
              throw new Error("Failed pattern match at Data.List.Lazy line 156, column 1 - line 161, column 23: " + [ n.constructor.name, m.constructor.name ]);
          };
      };
  };

  /**
 *  | Create a list by repeating an element
 */  
  var repeat = function (x) {
      return Control_Lazy.fix(Data_List_Lazy_Types.lazyList)(function (xs) {
          return Data_List_Lazy_Types.cons(x)(xs);
      });
  };

  /**
 *  | Create a list with repeated instances of a value.
 */  
  var replicate = function (i) {
      return function (xs) {
          return take(i)(repeat(xs));
      };
  };

  /**
 *  | Create a list containing a range of integers, including both endpoints.
 */  
  var range = function (start) {
      return function (end) {
          if (start > end) {
              var g = function (x) {
                  if (x >= end) {
                      return new Data_Maybe.Just(new Data_Tuple.Tuple(x, x - 1));
                  };
                  if (Data_Boolean.otherwise) {
                      return Data_Maybe.Nothing.value;
                  };
                  throw new Error("Failed pattern match at Data.List.Lazy line 142, column 13 - line 143, column 38: " + [ x.constructor.name ]);
              };
              return Data_Unfoldable.unfoldr(Data_List_Lazy_Types.unfoldableList)(g)(start);
          };
          if (Data_Boolean.otherwise) {
              var f = function (x) {
                  if (x <= end) {
                      return new Data_Maybe.Just(new Data_Tuple.Tuple(x, x + 1 | 0));
                  };
                  if (Data_Boolean.otherwise) {
                      return Data_Maybe.Nothing.value;
                  };
                  throw new Error("Failed pattern match at Data.List.Lazy line 147, column 5 - line 148, column 30: " + [ x.constructor.name ]);
              };
              return Data_Unfoldable.unfoldr(Data_List_Lazy_Types.unfoldableList)(f)(start);
          };
          throw new Error("Failed pattern match at Data.List.Lazy line 140, column 1 - line 148, column 30: " + [ start.constructor.name, end.constructor.name ]);
      };
  };

  /**
 * ------------------------------------------------------------------------------
 *  List size -------------------------------------------------------------------
 * ------------------------------------------------------------------------------
 *  | Test whether a list is empty.
 *  |
 *  | Running time: `O(1)`
 */  
  var $$null = function ($192) {
      return Data_Maybe.isNothing(uncons($192));
  };
  var mapMaybe = function (f) {
      return function (xs) {
          var go = function (__copy_v) {
              var v = __copy_v;
              tco: while (true) {
                  if (v instanceof Data_List_Lazy_Types.Nil) {
                      return Data_List_Lazy_Types.Nil.value;
                  };
                  if (v instanceof Data_List_Lazy_Types.Cons) {
                      var $105 = f(v.value0);
                      if ($105 instanceof Data_Maybe.Nothing) {
                          var __tco_v = Data_List_Lazy_Types.step(v.value1);
                          v = __tco_v;
                          continue tco;
                      };
                      if ($105 instanceof Data_Maybe.Just) {
                          return new Data_List_Lazy_Types.Cons($105.value0, mapMaybe(f)(v.value1));
                      };
                      throw new Error("Failed pattern match at Data.List.Lazy line 443, column 5 - line 445, column 39: " + [ $105.constructor.name ]);
                  };
                  throw new Error("Failed pattern match at Data.List.Lazy line 439, column 1 - line 445, column 39: " + [ v.constructor.name ]);
              };
          };
          return Data_Functor.map(Data_Lazy.functorLazy)(go)(Data_Newtype.unwrap(Data_List_Lazy_Types.newtypeList)(xs));
      };
  };

  /**
 *  | Get the length of a list
 *  |
 *  | Running time: `O(n)`
 */  
  var length = function (xs) {
      var go = function (v) {
          if (v instanceof Data_List_Lazy_Types.Nil) {
              return 0;
          };
          if (v instanceof Data_List_Lazy_Types.Cons) {
              return 1 + go(Data_List_Lazy_Types.step(v.value1)) | 0;
          };
          throw new Error("Failed pattern match at Data.List.Lazy line 189, column 1 - line 192, column 36: " + [ v.constructor.name ]);
      };
      return go(Data_List_Lazy_Types.step(xs));
  };

  /**
 *  | Get the last element in a list, or `Nothing` if the list is empty.
 *  |
 *  | Running time: `O(n)`.
 */  
  var last = function (xs) {
      var go = function (__copy_v) {
          var v = __copy_v;
          tco: while (true) {
              if (v instanceof Data_List_Lazy_Types.Cons) {
                  if ($$null(v.value1)) {
                      return new Data_Maybe.Just(v.value0);
                  };
                  if (Data_Boolean.otherwise) {
                      var __tco_v = Data_List_Lazy_Types.step(v.value1);
                      v = __tco_v;
                      continue tco;
                  };
              };
              return Data_Maybe.Nothing.value;
          };
      };
      return go(Data_List_Lazy_Types.step(xs));
  };

  /**
 *  | Create a list by iterating a function
 */  
  var iterate = function (f) {
      return function (x) {
          return Control_Lazy.fix(Data_List_Lazy_Types.lazyList)(function (xs) {
              return Data_List_Lazy_Types.cons(x)(Data_Functor.map(Data_List_Lazy_Types.functorList)(f)(xs));
          });
      };
  };
  var insertAt = function (v) {
      return function (x) {
          return function (xs) {
              if (v === 0) {
                  return Data_List_Lazy_Types.cons(x)(xs);
              };
              var go = function (v1) {
                  if (v1 instanceof Data_List_Lazy_Types.Nil) {
                      return new Data_List_Lazy_Types.Cons(x, Data_List_Lazy_Types.nil);
                  };
                  if (v1 instanceof Data_List_Lazy_Types.Cons) {
                      return new Data_List_Lazy_Types.Cons(v1.value0, insertAt(v - 1)(x)(v1.value1));
                  };
                  throw new Error("Failed pattern match at Data.List.Lazy line 320, column 3 - line 320, column 22: " + [ v1.constructor.name ]);
              };
              return Data_Functor.map(Data_Lazy.functorLazy)(go)(Data_Newtype.unwrap(Data_List_Lazy_Types.newtypeList)(xs));
          };
      };
  };

  /**
 *  | Get all but the last element of a list, or `Nothing` if the list is empty.
 *  |
 *  | Running time: `O(n)`
 */  
  var init = function (xs) {
      var go = function (v) {
          if (v instanceof Data_List_Lazy_Types.Cons) {
              if ($$null(v.value1)) {
                  return new Data_Maybe.Just(Data_List_Lazy_Types.nil);
              };
              if (Data_Boolean.otherwise) {
                  return Data_Functor.map(Data_Maybe.functorMaybe)(Data_List_Lazy_Types.cons(v.value0))(go(Data_List_Lazy_Types.step(v.value1)));
              };
          };
          return Data_Maybe.Nothing.value;
      };
      return go(Data_List_Lazy_Types.step(xs));
  };

  /**
 * ------------------------------------------------------------------------------
 *  Indexed operations ----------------------------------------------------------
 * ------------------------------------------------------------------------------
 *  | Get the element at the specified index, or `Nothing` if the index is out-of-bounds.
 *  |
 *  | Running time: `O(n)` where `n` is the required index.
 */  
  var index = function (xs) {
      var go = function (__copy_v) {
          return function (__copy_v1) {
              var v = __copy_v;
              var v1 = __copy_v1;
              tco: while (true) {
                  if (v instanceof Data_List_Lazy_Types.Nil) {
                      return Data_Maybe.Nothing.value;
                  };
                  if (v instanceof Data_List_Lazy_Types.Cons && v1 === 0) {
                      return new Data_Maybe.Just(v.value0);
                  };
                  if (v instanceof Data_List_Lazy_Types.Cons) {
                      var __tco_v = Data_List_Lazy_Types.step(v.value1);
                      var __tco_v1 = v1 - 1;
                      v = __tco_v;
                      v1 = __tco_v1;
                      continue tco;
                  };
                  throw new Error("Failed pattern match at Data.List.Lazy line 277, column 1 - line 281, column 42: " + [ v.constructor.name, v1.constructor.name ]);
              };
          };
      };
      return go(Data_List_Lazy_Types.step(xs));
  };

  /**
 * ------------------------------------------------------------------------------
 *  Non-indexed reads -----------------------------------------------------------
 * ------------------------------------------------------------------------------
 *  | Get the first element in a list, or `Nothing` if the list is empty.
 *  |
 *  | Running time: `O(1)`.
 */  
  var head = function (xs) {
      return Data_Functor.map(Data_Maybe.functorMaybe)(function (v) {
          return v.head;
      })(uncons(xs));
  };
  var transpose = function (xs) {
      var $130 = uncons(xs);
      if ($130 instanceof Data_Maybe.Nothing) {
          return xs;
      };
      if ($130 instanceof Data_Maybe.Just) {
          var $131 = uncons($130.value0.head);
          if ($131 instanceof Data_Maybe.Nothing) {
              return transpose($130.value0.tail);
          };
          if ($131 instanceof Data_Maybe.Just) {
              return Data_List_Lazy_Types.cons(Data_List_Lazy_Types.cons($131.value0.head)(mapMaybe(head)($130.value0.tail)))(transpose(Data_List_Lazy_Types.cons($131.value0.tail)(mapMaybe(tail)($130.value0.tail))));
          };
          throw new Error("Failed pattern match at Data.List.Lazy line 678, column 7 - line 682, column 71: " + [ $131.constructor.name ]);
      };
      throw new Error("Failed pattern match at Data.List.Lazy line 674, column 3 - line 682, column 71: " + [ $130.constructor.name ]);
  };
  var groupBy = function (eq) {
      return function (xs) {
          var go = function (v) {
              if (v instanceof Data_List_Lazy_Types.Nil) {
                  return Data_List_Lazy_Types.Nil.value;
              };
              if (v instanceof Data_List_Lazy_Types.Cons) {
                  var $139 = span(eq(v.value0))(v.value1);
                  return new Data_List_Lazy_Types.Cons(Data_Lazy.defer(function (v1) {
                      return new Data_NonEmpty.NonEmpty(v.value0, $139.init);
                  }), groupBy(eq)($139.rest));
              };
              throw new Error("Failed pattern match at Data.List.Lazy line 542, column 3 - line 542, column 15: " + [ v.constructor.name ]);
          };
          return Data_Functor.map(Data_Lazy.functorLazy)(go)(Data_Newtype.unwrap(Data_List_Lazy_Types.newtypeList)(xs));
      };
  };

  /**
 *  | Group equal, consecutive elements of a list into lists.
 *  |
 *  | For example,
 *  |
 *  | ```purescript
 *  | group (1 : 1 : 2 : 2 : 1 : Nil) == (1 : 1 : Nil) : (2 : 2 : Nil) : (1 : Nil) : Nil
 *  | ```
 *  |
 *  | Running time: `O(n)`
 */  
  var group = function (dictEq) {
      return groupBy(Data_Eq.eq(dictEq));
  };
  var fromStep = function ($193) {
      return Data_List_Lazy_Types.List(Control_Applicative.pure(Data_Lazy.applicativeLazy)($193));
  };
  var insertBy = function (cmp) {
      return function (x) {
          return function (xs) {
              var go = function (v) {
                  if (v instanceof Data_List_Lazy_Types.Nil) {
                      return new Data_List_Lazy_Types.Cons(x, Data_List_Lazy_Types.nil);
                  };
                  if (v instanceof Data_List_Lazy_Types.Cons) {
                      var $146 = cmp(x)(v.value0);
                      if ($146 instanceof Data_Ordering.GT) {
                          return new Data_List_Lazy_Types.Cons(v.value0, insertBy(cmp)(x)(v.value1));
                      };
                      return new Data_List_Lazy_Types.Cons(x, fromStep(v));
                  };
                  throw new Error("Failed pattern match at Data.List.Lazy line 217, column 3 - line 217, column 22: " + [ v.constructor.name ]);
              };
              return Data_Functor.map(Data_Lazy.functorLazy)(go)(Data_Newtype.unwrap(Data_List_Lazy_Types.newtypeList)(xs));
          };
      };
  };

  /**
 *  | Insert an element into a sorted list.
 *  |
 *  | Running time: `O(n)`
 */  
  var insert = function (dictOrd) {
      return insertBy(Data_Ord.compare(dictOrd));
  };

  /**
 *  | Construct a list from a foldable structure.
 *  |
 *  | Running time: `O(n)`
 */  
  var fromFoldable = function (dictFoldable) {
      return Data_Foldable.foldr(dictFoldable)(Data_List_Lazy_Types.cons)(Data_List_Lazy_Types.nil);
  };
  var foldM = function (dictMonad) {
      return function (f) {
          return function (a) {
              return function (xs) {
                  var $149 = uncons(xs);
                  if ($149 instanceof Data_Maybe.Nothing) {
                      return Control_Applicative.pure(dictMonad["__superclass_Control.Applicative.Applicative_0"]())(a);
                  };
                  if ($149 instanceof Data_Maybe.Just) {
                      return Control_Bind.bind(dictMonad["__superclass_Control.Bind.Bind_1"]())(f(a)($149.value0.head))(function (a$prime) {
                          return foldM(dictMonad)(f)(a$prime)($149.value0.tail);
                      });
                  };
                  throw new Error("Failed pattern match at Data.List.Lazy line 691, column 5 - line 694, column 52: " + [ $149.constructor.name ]);
              };
          };
      };
  };

  /**
 *  | Find the first index for which a predicate holds.
 */  
  var findIndex = function (fn) {
      var go = function (n) {
          return function (list) {
              return Control_Bind.bind(Data_Maybe.bindMaybe)(uncons(list))(function (v) {
                  var $154 = fn(v.head);
                  if ($154) {
                      return Control_Applicative.pure(Data_Maybe.applicativeMaybe)(n);
                  };
                  if (!$154) {
                      return go(n + 1 | 0)(v.tail);
                  };
                  throw new Error("Failed pattern match at Data.List.Lazy line 301, column 7 - line 303, column 32: " + [ $154.constructor.name ]);
              });
          };
      };
      return go(0);
  };

  /**
 *  | Find the last index for which a predicate holds.
 */  
  var findLastIndex = function (fn) {
      return function (xs) {
          return Data_Functor.map(Data_Maybe.functorMaybe)(function (v) {
              return length(xs) - 1 - v;
          })(findIndex(fn)(reverse(xs)));
      };
  };
  var filterM = function (dictMonad) {
      return function (p) {
          return function (list) {
              var $155 = uncons(list);
              if ($155 instanceof Data_Maybe.Nothing) {
                  return Control_Applicative.pure(dictMonad["__superclass_Control.Applicative.Applicative_0"]())(Data_List_Lazy_Types.nil);
              };
              if ($155 instanceof Data_Maybe.Just) {
                  return Control_Bind.bind(dictMonad["__superclass_Control.Bind.Bind_1"]())(p($155.value0.head))(function (v) {
                      return Control_Bind.bind(dictMonad["__superclass_Control.Bind.Bind_1"]())(filterM(dictMonad)(p)($155.value0.tail))(function (v1) {
                          return Control_Applicative.pure(dictMonad["__superclass_Control.Applicative.Applicative_0"]())((function () {
                              if (v) {
                                  return Data_List_Lazy_Types.cons($155.value0.head)(v1);
                              };
                              if (!v) {
                                  return v1;
                              };
                              throw new Error("Failed pattern match at Data.List.Lazy line 431, column 19 - line 431, column 48: " + [ v.constructor.name ]);
                          })());
                      });
                  });
              };
              throw new Error("Failed pattern match at Data.List.Lazy line 426, column 5 - line 431, column 48: " + [ $155.constructor.name ]);
          };
      };
  };
  var filter = function (p) {
      return function (xs) {
          var go = function (__copy_v) {
              var v = __copy_v;
              tco: while (true) {
                  if (v instanceof Data_List_Lazy_Types.Nil) {
                      return Data_List_Lazy_Types.Nil.value;
                  };
                  if (v instanceof Data_List_Lazy_Types.Cons) {
                      if (p(v.value0)) {
                          return new Data_List_Lazy_Types.Cons(v.value0, filter(p)(v.value1));
                      };
                      if (Data_Boolean.otherwise) {
                          var __tco_v = Data_List_Lazy_Types.step(v.value1);
                          v = __tco_v;
                          continue tco;
                      };
                  };
                  throw new Error("Failed pattern match at Data.List.Lazy line 409, column 1 - line 414, column 31: " + [ v.constructor.name ]);
              };
          };
          return Data_Functor.map(Data_Lazy.functorLazy)(go)(Data_Newtype.unwrap(Data_List_Lazy_Types.newtypeList)(xs));
      };
  };

  /**
 *  | Calculate the intersection of two lists, using the specified
 *  | function to determine equality of elements.
 *  |
 *  | Running time: `O(n^2)`
 */  
  var intersectBy = function (eq) {
      return function (xs) {
          return function (ys) {
              return filter(function (x) {
                  return Data_Foldable.any(Data_List_Lazy_Types.foldableList)(Data_HeytingAlgebra.heytingAlgebraBoolean)(eq(x))(ys);
              })(xs);
          };
      };
  };

  /**
 *  | Calculate the intersection of two lists.
 *  |
 *  | Running time: `O(n^2)`
 */  
  var intersect = function (dictEq) {
      return intersectBy(Data_Eq.eq(dictEq));
  };
  var nubBy = function (eq) {
      return function (xs) {
          var go = function (v) {
              if (v instanceof Data_List_Lazy_Types.Nil) {
                  return Data_List_Lazy_Types.Nil.value;
              };
              if (v instanceof Data_List_Lazy_Types.Cons) {
                  return new Data_List_Lazy_Types.Cons(v.value0, nubBy(eq)(filter(function (y) {
                      return !eq(v.value0)(y);
                  })(v.value1)));
              };
              throw new Error("Failed pattern match at Data.List.Lazy line 565, column 3 - line 565, column 15: " + [ v.constructor.name ]);
          };
          return Data_Functor.map(Data_Lazy.functorLazy)(go)(Data_Newtype.unwrap(Data_List_Lazy_Types.newtypeList)(xs));
      };
  };

  /**
 * ------------------------------------------------------------------------------
 *  Set-like operations ---------------------------------------------------------
 * ------------------------------------------------------------------------------
 *  | Remove duplicate elements from a list.
 *  |
 *  | Running time: `O(n^2)`
 */  
  var nub = function (dictEq) {
      return nubBy(Data_Eq.eq(dictEq));
  };

  /**
 *  | Find the index of the last element equal to the specified element.
 */  
  var elemLastIndex = function (dictEq) {
      return function (x) {
          return findLastIndex(function (v) {
              return Data_Eq.eq(dictEq)(v)(x);
          });
      };
  };

  /**
 *  | Find the index of the first element equal to the specified element.
 */  
  var elemIndex = function (dictEq) {
      return function (x) {
          return findIndex(function (v) {
              return Data_Eq.eq(dictEq)(v)(x);
          });
      };
  };

  /**
 *  | Drop those elements from the front of a list which match a predicate.
 *  |
 *  | Running time (worst case): `O(n)`
 */  
  var dropWhile = function (p) {
      return function (xs) {
          var go = function (__copy_v) {
              var v = __copy_v;
              tco: while (true) {
                  if (v instanceof Data_List_Lazy_Types.Cons && p(v.value0)) {
                      var __tco_v = Data_List_Lazy_Types.step(v.value1);
                      v = __tco_v;
                      continue tco;
                  };
                  return fromStep(v);
              };
          };
          return go(Data_List_Lazy_Types.step(xs));
      };
  };

  /**
 *  | Drop the specified number of elements from the front of a list.
 *  |
 *  | Running time: `O(n)` where `n` is the number of elements to drop.
 */  
  var drop = function (n) {
      return function (xs) {
          var go = function (__copy_v) {
              return function (__copy_v1) {
                  var v = __copy_v;
                  var v1 = __copy_v1;
                  tco: while (true) {
                      if (v === 0) {
                          return v1;
                      };
                      if (v1 instanceof Data_List_Lazy_Types.Nil) {
                          return Data_List_Lazy_Types.Nil.value;
                      };
                      if (v1 instanceof Data_List_Lazy_Types.Cons) {
                          var __tco_v = v - 1;
                          var __tco_v1 = Data_List_Lazy_Types.step(v1.value1);
                          v = __tco_v;
                          v1 = __tco_v1;
                          continue tco;
                      };
                      throw new Error("Failed pattern match at Data.List.Lazy line 488, column 1 - line 492, column 42: " + [ v.constructor.name, v1.constructor.name ]);
                  };
              };
          };
          return Data_Functor.map(Data_Lazy.functorLazy)(go(n))(Data_Newtype.unwrap(Data_List_Lazy_Types.newtypeList)(xs));
      };
  };

  /**
 * ------------------------------------------------------------------------------
 *  Sorting ---------------------------------------------------------------------
 * ------------------------------------------------------------------------------
 * ------------------------------------------------------------------------------
 *  Sublists --------------------------------------------------------------------
 * ------------------------------------------------------------------------------
 *  | Extract a sublist by a start and end index.
 */  
  var slice = function (start) {
      return function (end) {
          return function (xs) {
              return take(end - start)(drop(start)(xs));
          };
      };
  };
  var deleteBy = function (eq) {
      return function (x) {
          return function (xs) {
              var go = function (v) {
                  if (v instanceof Data_List_Lazy_Types.Nil) {
                      return Data_List_Lazy_Types.Nil.value;
                  };
                  if (v instanceof Data_List_Lazy_Types.Cons) {
                      if (eq(x)(v.value0)) {
                          return Data_List_Lazy_Types.step(v.value1);
                      };
                      if (Data_Boolean.otherwise) {
                          return new Data_List_Lazy_Types.Cons(v.value0, deleteBy(eq)(x)(v.value1));
                      };
                  };
                  throw new Error("Failed pattern match at Data.List.Lazy line 594, column 3 - line 594, column 15: " + [ v.constructor.name ]);
              };
              return Data_Functor.map(Data_Lazy.functorLazy)(go)(Data_Newtype.unwrap(Data_List_Lazy_Types.newtypeList)(xs));
          };
      };
  };

  /**
 *  | Calculate the union of two lists, using the specified
 *  | function to determine equality of elements.
 *  |
 *  | Running time: `O(n^2)`
 */  
  var unionBy = function (eq) {
      return function (xs) {
          return function (ys) {
              return Data_Semigroup.append(Data_List_Lazy_Types.semigroupList)(xs)(Data_Foldable.foldl(Data_List_Lazy_Types.foldableList)(Data_Function.flip(deleteBy(eq)))(nubBy(eq)(ys))(xs));
          };
      };
  };

  /**
 *  | Calculate the union of two lists.
 *  |
 *  | Running time: `O(n^2)`
 */  
  var union = function (dictEq) {
      return unionBy(Data_Eq.eq(dictEq));
  };
  var deleteAt = function (n) {
      return function (xs) {
          var go = function (v) {
              return function (v1) {
                  if (v1 instanceof Data_List_Lazy_Types.Nil) {
                      return Data_List_Lazy_Types.Nil.value;
                  };
                  if (v === 0 && v1 instanceof Data_List_Lazy_Types.Cons) {
                      return Data_List_Lazy_Types.step(v1.value1);
                  };
                  if (v1 instanceof Data_List_Lazy_Types.Cons) {
                      return new Data_List_Lazy_Types.Cons(v1.value0, deleteAt(v - 1)(v1.value1));
                  };
                  throw new Error("Failed pattern match at Data.List.Lazy line 333, column 3 - line 333, column 17: " + [ v.constructor.name, v1.constructor.name ]);
              };
          };
          return Data_Functor.map(Data_Lazy.functorLazy)(go(n))(Data_Newtype.unwrap(Data_List_Lazy_Types.newtypeList)(xs));
      };
  };

  /**
 *  | Delete the first occurrence of an element from a list.
 *  |
 *  | Running time: `O(n)`
 */  
  var $$delete = function (dictEq) {
      return deleteBy(Data_Eq.eq(dictEq));
  };

  /**
 *  | Delete the first occurrence of each element in the second list from the first list.
 *  |
 *  | Running time: `O(n^2)`
 */  
  var difference = function (dictEq) {
      return Data_Foldable.foldl(Data_List_Lazy_Types.foldableList)(Data_Function.flip($$delete(dictEq)));
  };

  /**
 *  | Create a list by repeating another list
 */  
  var cycle = function (xs) {
      return Control_Lazy.fix(Data_List_Lazy_Types.lazyList)(function (ys) {
          return Data_Semigroup.append(Data_List_Lazy_Types.semigroupList)(xs)(ys);
      });
  };

  /**
 *  | Apply a function to each element in a list, and flatten the results
 *  | into a single, new list.
 *  |
 *  | Running time: `O(n)`, where `n` is the total number of elements.
 */  
  var concatMap = Data_Function.flip(Control_Bind.bind(Data_List_Lazy_Types.bindList));

  /**
 *  | Flatten a list of lists.
 *  |
 *  | Running time: `O(n)`, where `n` is the total number of elements.
 */  
  var concat = function (v) {
      return Control_Bind.bind(Data_List_Lazy_Types.bindList)(v)(Control_Category.id(Control_Category.categoryFn));
  };

  /**
 *  | Filter a list of optional values, keeping only the elements which contain
 *  | a value.
 */  
  var catMaybes = mapMaybe(Control_Category.id(Control_Category.categoryFn));
  var alterAt = function (n) {
      return function (f) {
          return function (xs) {
              var go = function (v) {
                  return function (v1) {
                      if (v1 instanceof Data_List_Lazy_Types.Nil) {
                          return Data_List_Lazy_Types.Nil.value;
                      };
                      if (v === 0 && v1 instanceof Data_List_Lazy_Types.Cons) {
                          var $186 = f(v1.value0);
                          if ($186 instanceof Data_Maybe.Nothing) {
                              return Data_List_Lazy_Types.step(v1.value1);
                          };
                          if ($186 instanceof Data_Maybe.Just) {
                              return new Data_List_Lazy_Types.Cons($186.value0, v1.value1);
                          };
                          throw new Error("Failed pattern match at Data.List.Lazy line 374, column 22 - line 376, column 26: " + [ $186.constructor.name ]);
                      };
                      if (v1 instanceof Data_List_Lazy_Types.Cons) {
                          return new Data_List_Lazy_Types.Cons(v1.value0, alterAt(v - 1)(f)(v1.value1));
                      };
                      throw new Error("Failed pattern match at Data.List.Lazy line 373, column 3 - line 373, column 17: " + [ v.constructor.name, v1.constructor.name ]);
                  };
              };
              return Data_Functor.map(Data_Lazy.functorLazy)(go(n))(Data_Newtype.unwrap(Data_List_Lazy_Types.newtypeList)(xs));
          };
      };
  };

  /**
 *  | Update the element at the specified index by applying a function to
 *  | the current value, returning a new list or `Nothing` if the index is
 *  | out-of-bounds.
 *  |
 *  | This function differs from the strict equivalent in that out-of-bounds arguments
 *  | result in the original list being returned unchanged.
 *  |
 *  | Running time: `O(n)`
 */  
  var modifyAt = function (n) {
      return function (f) {
          return alterAt(n)(function ($194) {
              return Data_Maybe.Just.create(f($194));
          });
      };
  };
  exports["alterAt"] = alterAt;
  exports["catMaybes"] = catMaybes;
  exports["concat"] = concat;
  exports["concatMap"] = concatMap;
  exports["cycle"] = cycle;
  exports["delete"] = $$delete;
  exports["deleteAt"] = deleteAt;
  exports["deleteBy"] = deleteBy;
  exports["difference"] = difference;
  exports["drop"] = drop;
  exports["dropWhile"] = dropWhile;
  exports["elemIndex"] = elemIndex;
  exports["elemLastIndex"] = elemLastIndex;
  exports["filter"] = filter;
  exports["filterM"] = filterM;
  exports["findIndex"] = findIndex;
  exports["findLastIndex"] = findLastIndex;
  exports["foldM"] = foldM;
  exports["fromFoldable"] = fromFoldable;
  exports["group"] = group;
  exports["groupBy"] = groupBy;
  exports["head"] = head;
  exports["index"] = index;
  exports["init"] = init;
  exports["insert"] = insert;
  exports["insertAt"] = insertAt;
  exports["insertBy"] = insertBy;
  exports["intersect"] = intersect;
  exports["intersectBy"] = intersectBy;
  exports["iterate"] = iterate;
  exports["last"] = last;
  exports["length"] = length;
  exports["mapMaybe"] = mapMaybe;
  exports["modifyAt"] = modifyAt;
  exports["nub"] = nub;
  exports["nubBy"] = nubBy;
  exports["null"] = $$null;
  exports["range"] = range;
  exports["repeat"] = repeat;
  exports["replicate"] = replicate;
  exports["replicateM"] = replicateM;
  exports["reverse"] = reverse;
  exports["singleton"] = singleton;
  exports["slice"] = slice;
  exports["snoc"] = snoc;
  exports["span"] = span;
  exports["tail"] = tail;
  exports["take"] = take;
  exports["takeWhile"] = takeWhile;
  exports["toUnfoldable"] = toUnfoldable;
  exports["transpose"] = transpose;
  exports["uncons"] = uncons;
  exports["union"] = union;
  exports["unionBy"] = unionBy;
  exports["unzip"] = unzip;
  exports["updateAt"] = updateAt;
  exports["zip"] = zip;
  exports["zipWith"] = zipWith;
  exports["zipWithA"] = zipWithA;
})(PS["Data.List.Lazy"] = PS["Data.List.Lazy"] || {});
(function(exports) {
    "use strict";
  var Prelude = PS["Prelude"];
  var Data_Foldable = PS["Data.Foldable"];
  var Data_Lazy = PS["Data.Lazy"];
  var Data_List_Lazy = PS["Data.List.Lazy"];
  var Data_List_Lazy_Types = PS["Data.List.Lazy.Types"];
  var Data_Maybe = PS["Data.Maybe"];
  var Data_NonEmpty = PS["Data.NonEmpty"];
  var Data_Tuple = PS["Data.Tuple"];
  var Data_Unfoldable = PS["Data.Unfoldable"];
  var Control_Semigroupoid = PS["Control.Semigroupoid"];
  var Data_Functor = PS["Data.Functor"];
  var Control_Applicative = PS["Control.Applicative"];
  var Data_Semiring = PS["Data.Semiring"];
  var Data_Function = PS["Data.Function"];
  var Control_Bind = PS["Control.Bind"];        
  var uncons = function (v) {
      var $12 = Data_Lazy.force(v);
      return {
          head: $12.value0, 
          tail: $12.value1
      };
  };
  var toList = function (v) {
      var $16 = Data_Lazy.force(v);
      return Data_List_Lazy_Types.cons($16.value0)($16.value1);
  };
  var toUnfoldable = function (dictUnfoldable) {
      return function ($43) {
          return Data_Unfoldable.unfoldr(dictUnfoldable)(function (xs) {
              return Data_Functor.map(Data_Maybe.functorMaybe)(function (rec) {
                  return new Data_Tuple.Tuple(rec.head, rec.tail);
              })(Data_List_Lazy.uncons(xs));
          })(toList($43));
      };
  };
  var tail = function (v) {
      var $20 = Data_Lazy.force(v);
      return $20.value1;
  };
  var singleton = Control_Applicative.pure(Data_List_Lazy_Types.applicativeNonEmptyList);
  var length = function (v) {
      var $24 = Data_Lazy.force(v);
      return 1 + Data_List_Lazy.length($24.value1) | 0;
  };
  var last = function (v) {
      var $28 = Data_Lazy.force(v);
      return Data_Maybe.fromMaybe($28.value0)(Data_List_Lazy.last($28.value1));
  };
  var init = function (v) {
      var $32 = Data_Lazy.force(v);
      return Data_Maybe.maybe(Data_List_Lazy_Types.nil)(function (v1) {
          return Data_List_Lazy_Types.cons($32.value0)(v1);
      })(Data_List_Lazy.init($32.value1));
  };
  var head = function (v) {
      var $36 = Data_Lazy.force(v);
      return $36.value0;
  };
  var fromList = function (l) {
      var $39 = Data_List_Lazy_Types.step(l);
      if ($39 instanceof Data_List_Lazy_Types.Nil) {
          return Data_Maybe.Nothing.value;
      };
      if ($39 instanceof Data_List_Lazy_Types.Cons) {
          return new Data_Maybe.Just(Data_Lazy.defer(function (v) {
              return new Data_NonEmpty.NonEmpty($39.value0, $39.value1);
          }));
      };
      throw new Error("Failed pattern match at Data.List.Lazy.NonEmpty line 37, column 3 - line 39, column 61: " + [ $39.constructor.name ]);
  };
  var fromFoldable = function (dictFoldable) {
      return function ($44) {
          return fromList(Data_List_Lazy.fromFoldable(dictFoldable)($44));
      };
  };
  var concatMap = Data_Function.flip(Control_Bind.bind(Data_List_Lazy_Types.bindNonEmptyList));
  exports["concatMap"] = concatMap;
  exports["fromFoldable"] = fromFoldable;
  exports["fromList"] = fromList;
  exports["head"] = head;
  exports["init"] = init;
  exports["length"] = length;
  exports["singleton"] = singleton;
  exports["tail"] = tail;
  exports["toList"] = toList;
  exports["toUnfoldable"] = toUnfoldable;
  exports["uncons"] = uncons;
})(PS["Data.List.Lazy.NonEmpty"] = PS["Data.List.Lazy.NonEmpty"] || {});
(function(exports) {
  
  /**
 *  | Partial helper functions for working with strict linked lists.
 */  
  "use strict";
  var Data_List = PS["Data.List"];
  var Data_List_Types = PS["Data.List.Types"];        

  /**
 *  | Get all but the first element of a non-empty list.
 *  |
 *  | Running time: `O(1)`
 */  
  var tail = function (dictPartial) {
      return function (v) {
          var __unused = function (dictPartial1) {
              return function ($dollar5) {
                  return $dollar5;
              };
          };
          return __unused(dictPartial)((function () {
              if (v instanceof Data_List_Types.Cons) {
                  return v.value1;
              };
              throw new Error("Failed pattern match at Data.List.Partial line 16, column 1 - line 16, column 22: " + [ v.constructor.name ]);
          })());
      };
  };
  var last = function (dictPartial) {
      return function (v) {
          var __unused = function (dictPartial1) {
              return function ($dollar9) {
                  return $dollar9;
              };
          };
          return __unused(dictPartial)((function () {
              if (v instanceof Data_List_Types.Cons && v.value1 instanceof Data_List_Types.Nil) {
                  return v.value0;
              };
              if (v instanceof Data_List_Types.Cons) {
                  return last(dictPartial)(v.value1);
              };
              throw new Error("Failed pattern match at Data.List.Partial line 22, column 1 - line 22, column 22: " + [ v.constructor.name ]);
          })());
      };
  };
  var init = function (dictPartial) {
      return function (v) {
          var __unused = function (dictPartial1) {
              return function ($dollar13) {
                  return $dollar13;
              };
          };
          return __unused(dictPartial)((function () {
              if (v instanceof Data_List_Types.Cons && v.value1 instanceof Data_List_Types.Nil) {
                  return Data_List_Types.Nil.value;
              };
              if (v instanceof Data_List_Types.Cons) {
                  return new Data_List_Types.Cons(v.value0, init(dictPartial)(v.value1));
              };
              throw new Error("Failed pattern match at Data.List.Partial line 29, column 1 - line 29, column 24: " + [ v.constructor.name ]);
          })());
      };
  };

  /**
 *  | Get the first element of a non-empty list.
 *  |
 *  | Running time: `O(1)`.
 */  
  var head = function (dictPartial) {
      return function (v) {
          var __unused = function (dictPartial1) {
              return function ($dollar17) {
                  return $dollar17;
              };
          };
          return __unused(dictPartial)((function () {
              if (v instanceof Data_List_Types.Cons) {
                  return v.value0;
              };
              throw new Error("Failed pattern match at Data.List.Partial line 10, column 1 - line 10, column 20: " + [ v.constructor.name ]);
          })());
      };
  };
  exports["head"] = head;
  exports["init"] = init;
  exports["last"] = last;
  exports["tail"] = tail;
})(PS["Data.List.Partial"] = PS["Data.List.Partial"] || {});
(function(exports) {
  
  /**
 *  | This module defines the type of _zip lists_, i.e. linked lists
 *  | with a zippy `Applicative` instance.
 */  
  "use strict";
  var Prelude = PS["Prelude"];
  var Control_Alt = PS["Control.Alt"];
  var Control_Alternative = PS["Control.Alternative"];
  var Control_Plus = PS["Control.Plus"];
  var Data_Foldable = PS["Data.Foldable"];
  var Data_List_Lazy = PS["Data.List.Lazy"];
  var Data_Monoid = PS["Data.Monoid"];
  var Data_Newtype = PS["Data.Newtype"];
  var Data_Traversable = PS["Data.Traversable"];
  var Partial_Unsafe = PS["Partial.Unsafe"];
  var Data_Show = PS["Data.Show"];
  var Data_Semigroup = PS["Data.Semigroup"];
  var Data_Eq = PS["Data.Eq"];
  var Data_Ord = PS["Data.Ord"];
  var Data_Functor = PS["Data.Functor"];
  var Control_Apply = PS["Control.Apply"];
  var Data_Function = PS["Data.Function"];
  var Control_Applicative = PS["Control.Applicative"];
  var Control_Semigroupoid = PS["Control.Semigroupoid"];
  var Control_Bind = PS["Control.Bind"];
  var Data_List_Lazy_Types = PS["Data.List.Lazy.Types"];        

  /**
 *  | `ZipList` is a newtype around `List` which provides a zippy
 *  | `Applicative` instance.
 */  
  var ZipList = function (x) {
      return x;
  };
  var traversableZipList = Data_List_Lazy_Types.traversableList;
  var showZipList = function (dictShow) {
      return new Data_Show.Show(function (v) {
          return "(ZipList " + (Data_Show.show(Data_List_Lazy_Types.showList(dictShow))(v) + ")");
      });
  };
  var semigroupZipList = Data_List_Lazy_Types.semigroupList;
  var ordZipList = function (dictOrd) {
      return Data_List_Lazy_Types.ordList(dictOrd);
  };
  var newtypeZipList = new Data_Newtype.Newtype(function (n) {
      return n;
  }, ZipList);
  var monoidZipList = Data_List_Lazy_Types.monoidList;
  var functorZipList = Data_List_Lazy_Types.functorList;
  var foldableZipList = Data_List_Lazy_Types.foldableList;
  var eqZipList = function (dictEq) {
      return Data_List_Lazy_Types.eqList(dictEq);
  };
  var applyZipList = new Control_Apply.Apply(function () {
      return functorZipList;
  }, function (v) {
      return function (v1) {
          return Data_List_Lazy.zipWith(Data_Function.apply)(v)(v1);
      };
  });
  var zipListIsNotBind = function (dictFail) {
      return new Control_Bind.Bind(function () {
          return applyZipList;
      }, Partial_Unsafe.unsafeCrashWith("bind: unreachable"));
  };
  var applicativeZipList = new Control_Applicative.Applicative(function () {
      return applyZipList;
  }, function ($13) {
      return ZipList(Data_List_Lazy.repeat($13));
  });
  var altZipList = new Control_Alt.Alt(function () {
      return functorZipList;
  }, Data_Semigroup.append(semigroupZipList));
  var plusZipList = new Control_Plus.Plus(function () {
      return altZipList;
  }, Data_Monoid.mempty(monoidZipList));
  var alternativeZipList = new Control_Alternative.Alternative(function () {
      return applicativeZipList;
  }, function () {
      return plusZipList;
  });
  exports["ZipList"] = ZipList;
  exports["showZipList"] = showZipList;
  exports["newtypeZipList"] = newtypeZipList;
  exports["eqZipList"] = eqZipList;
  exports["ordZipList"] = ordZipList;
  exports["semigroupZipList"] = semigroupZipList;
  exports["monoidZipList"] = monoidZipList;
  exports["foldableZipList"] = foldableZipList;
  exports["traversableZipList"] = traversableZipList;
  exports["functorZipList"] = functorZipList;
  exports["applyZipList"] = applyZipList;
  exports["applicativeZipList"] = applicativeZipList;
  exports["altZipList"] = altZipList;
  exports["plusZipList"] = plusZipList;
  exports["alternativeZipList"] = alternativeZipList;
  exports["zipListIsNotBind"] = zipListIsNotBind;
})(PS["Data.List.ZipList"] = PS["Data.List.ZipList"] || {});
(function(exports) {
    "use strict";
  var Prelude = PS["Prelude"];
  var Data_Newtype = PS["Data.Newtype"];
  var Control_Semigroupoid = PS["Control.Semigroupoid"];
  var Control_Category = PS["Control.Category"];        

  /**
 *  | A `Profunctor` is a `Functor` from the pair category `(Type^op, Type)`
 *  | to `Type`.
 *  |
 *  | In other words, a `Profunctor` is a type constructor of two type
 *  | arguments, which is contravariant in its first argument and covariant
 *  | in its second argument.
 *  |
 *  | The `dimap` function can be used to map functions over both arguments
 *  | simultaneously.
 *  |
 *  | A straightforward example of a profunctor is the function arrow `(->)`.
 *  |
 *  | Laws:
 *  |
 *  | - Identity: `dimap id id = id`
 *  | - Composition: `dimap f1 g1 <<< dimap f2 g2 = dimap (f1 >>> f2) (g1 <<< g2)`
 */  
  var Profunctor = function (dimap) {
      this.dimap = dimap;
  };
  var profunctorFn = new Profunctor(function (a2b) {
      return function (c2d) {
          return function (b2c) {
              return function ($9) {
                  return c2d(b2c(a2b($9)));
              };
          };
      };
  });

  /**
 *  | A `Profunctor` is a `Functor` from the pair category `(Type^op, Type)`
 *  | to `Type`.
 *  |
 *  | In other words, a `Profunctor` is a type constructor of two type
 *  | arguments, which is contravariant in its first argument and covariant
 *  | in its second argument.
 *  |
 *  | The `dimap` function can be used to map functions over both arguments
 *  | simultaneously.
 *  |
 *  | A straightforward example of a profunctor is the function arrow `(->)`.
 *  |
 *  | Laws:
 *  |
 *  | - Identity: `dimap id id = id`
 *  | - Composition: `dimap f1 g1 <<< dimap f2 g2 = dimap (f1 >>> f2) (g1 <<< g2)`
 */  
  var dimap = function (dict) {
      return dict.dimap;
  };

  /**
 *  | Map a function over the (contravariant) first type argument only.
 */  
  var lmap = function (dictProfunctor) {
      return function (a2b) {
          return dimap(dictProfunctor)(a2b)(Control_Category.id(Control_Category.categoryFn));
      };
  };

  /**
 *  | Map a function over the (covariant) second type argument only.
 */  
  var rmap = function (dictProfunctor) {
      return function (b2c) {
          return dimap(dictProfunctor)(Control_Category.id(Control_Category.categoryFn))(b2c);
      };
  };
  var unwrapIso = function (dictProfunctor) {
      return function (dictNewtype) {
          return dimap(dictProfunctor)(Data_Newtype.wrap(dictNewtype))(Data_Newtype.unwrap(dictNewtype));
      };
  };
  var wrapIso = function (dictProfunctor) {
      return function (dictNewtype) {
          return function (v) {
              return dimap(dictProfunctor)(Data_Newtype.unwrap(dictNewtype))(Data_Newtype.wrap(dictNewtype));
          };
      };
  };

  /**
 *  | Lift a pure function into any `Profunctor` which is also a `Category`.
 */  
  var arr = function (dictCategory) {
      return function (dictProfunctor) {
          return function (f) {
              return rmap(dictProfunctor)(f)(Control_Category.id(dictCategory));
          };
      };
  };
  exports["Profunctor"] = Profunctor;
  exports["arr"] = arr;
  exports["dimap"] = dimap;
  exports["lmap"] = lmap;
  exports["rmap"] = rmap;
  exports["unwrapIso"] = unwrapIso;
  exports["wrapIso"] = wrapIso;
  exports["profunctorFn"] = profunctorFn;
})(PS["Data.Profunctor"] = PS["Data.Profunctor"] || {});
(function(exports) {
    "use strict";
  var Prelude = PS["Prelude"];
  var Data_Either = PS["Data.Either"];
  var Data_Profunctor = PS["Data.Profunctor"];
  var Data_Function = PS["Data.Function"];
  var Data_Functor = PS["Data.Functor"];
  var Control_Semigroupoid = PS["Control.Semigroupoid"];
  var Control_Category = PS["Control.Category"];        

  /**
 *  | The `Choice` class extends `Profunctor` with combinators for working with
 *  | sum types.
 *  |
 *  | `left` and `right` lift values in a `Profunctor` to act on the `Left` and
 *  | `Right` components of a sum, respectively.
 *  |
 *  | Looking at `Choice` through the intuition of inputs and outputs
 *  | yields the following type signature:
 *  | ```
 *  | left ::  forall input output a. p input output -> p (Either input a) (Either output a)
 *  | right :: forall input output a. p input output -> p (Either a input) (Either a output)
 *  | ```
 *  | If we specialize the profunctor `p` to the `function` arrow, we get the following type
 *  | signatures:
 *  | ```
 *  | left ::  forall input output a. (input -> output) -> (Either input a) -> (Either output a)
 *  | right :: forall input output a. (input -> output) -> (Either a input) -> (Either a output)
 *  | ```
 *  | When the `profunctor` is `Function` application, `left` allows you to map a function over the
 *  | left side of an `Either`, and `right` maps it over the right side (same as `map` would do).
 */  
  var Choice = function (__superclass_Data$dotProfunctor$dotProfunctor_0, left, right) {
      this["__superclass_Data.Profunctor.Profunctor_0"] = __superclass_Data$dotProfunctor$dotProfunctor_0;
      this.left = left;
      this.right = right;
  };

  /**
 *  | The `Choice` class extends `Profunctor` with combinators for working with
 *  | sum types.
 *  |
 *  | `left` and `right` lift values in a `Profunctor` to act on the `Left` and
 *  | `Right` components of a sum, respectively.
 *  |
 *  | Looking at `Choice` through the intuition of inputs and outputs
 *  | yields the following type signature:
 *  | ```
 *  | left ::  forall input output a. p input output -> p (Either input a) (Either output a)
 *  | right :: forall input output a. p input output -> p (Either a input) (Either a output)
 *  | ```
 *  | If we specialize the profunctor `p` to the `function` arrow, we get the following type
 *  | signatures:
 *  | ```
 *  | left ::  forall input output a. (input -> output) -> (Either input a) -> (Either output a)
 *  | right :: forall input output a. (input -> output) -> (Either a input) -> (Either a output)
 *  | ```
 *  | When the `profunctor` is `Function` application, `left` allows you to map a function over the
 *  | left side of an `Either`, and `right` maps it over the right side (same as `map` would do).
 */  
  var right = function (dict) {
      return dict.right;
  };

  /**
 *  | The `Choice` class extends `Profunctor` with combinators for working with
 *  | sum types.
 *  |
 *  | `left` and `right` lift values in a `Profunctor` to act on the `Left` and
 *  | `Right` components of a sum, respectively.
 *  |
 *  | Looking at `Choice` through the intuition of inputs and outputs
 *  | yields the following type signature:
 *  | ```
 *  | left ::  forall input output a. p input output -> p (Either input a) (Either output a)
 *  | right :: forall input output a. p input output -> p (Either a input) (Either a output)
 *  | ```
 *  | If we specialize the profunctor `p` to the `function` arrow, we get the following type
 *  | signatures:
 *  | ```
 *  | left ::  forall input output a. (input -> output) -> (Either input a) -> (Either output a)
 *  | right :: forall input output a. (input -> output) -> (Either a input) -> (Either a output)
 *  | ```
 *  | When the `profunctor` is `Function` application, `left` allows you to map a function over the
 *  | left side of an `Either`, and `right` maps it over the right side (same as `map` would do).
 */  
  var left = function (dict) {
      return dict.left;
  };

  /**
 *  | Compose a value acting on a sum from two values, each acting on one of
 *  | the components of the sum.
 *  |
 *  | Specializing `(+++)` to function application would look like this:
 *  | ```
 *  | (+++) :: forall a b c d. (a -> b) -> (c -> d) -> (Either a c) -> (Either b d)
 *  | ```
 *  | We take two functions, `f` and `g`, and we transform them into a single function which
 *  | takes an `Either`and maps `f` over the left side and `g` over the right side.  Just like
 *  | `bi-map` would do for the `bi-functor` instance of `Either`.
 */  
  var splitChoice = function (dictCategory) {
      return function (dictChoice) {
          return function (l) {
              return function (r) {
                  return Control_Semigroupoid.composeFlipped(dictCategory["__superclass_Control.Semigroupoid.Semigroupoid_0"]())(left(dictChoice)(l))(right(dictChoice)(r));
              };
          };
      };
  };

  /**
 *  | Compose a value which eliminates a sum from two values, each eliminating
 *  | one side of the sum.
 *  |
 *  | This combinator is useful when assembling values from smaller components,
 *  | because it provides a way to support two different types of input.
 *  |
 *  | Specializing `(|||)` to function application would look like this:
 *  | ```
 *  | (|||) :: forall a b c d. (a -> c) -> (b -> c) -> Either a b -> c
 *  | ```
 *  | We take two functions, `f` and `g`, which both return the same type `c` and we transform them into a
 *  | single function which takes an `Either` value with the parameter type of `f` on the left side and
 *  | the parameter type of `g` on the right side. The function then runs either `f` or `g`, depending on
 *  | whether the `Either` value is a `Left` or a `Right`.
 *  | This allows us to bundle two different computations which both have the same result type into one
 *  | function which will run the approriate computation based on the parameter supplied in the `Either` value.
 */  
  var fanin = function (dictCategory) {
      return function (dictChoice) {
          return function (l) {
              return function (r) {
                  var join = Data_Profunctor.dimap(dictChoice["__superclass_Data.Profunctor.Profunctor_0"]())(Data_Either.either(Control_Category.id(Control_Category.categoryFn))(Control_Category.id(Control_Category.categoryFn)))(Control_Category.id(Control_Category.categoryFn))(Control_Category.id(dictCategory));
                  return Control_Semigroupoid.composeFlipped(dictCategory["__superclass_Control.Semigroupoid.Semigroupoid_0"]())(splitChoice(dictCategory)(dictChoice)(l)(r))(join);
              };
          };
      };
  };
  var choiceFn = new Choice(function () {
      return Data_Profunctor.profunctorFn;
  }, function (v) {
      return function (v1) {
          if (v1 instanceof Data_Either.Left) {
              return Data_Either.Left.create(v(v1.value0));
          };
          if (v1 instanceof Data_Either.Right) {
              return new Data_Either.Right(v1.value0);
          };
          throw new Error("Failed pattern match at Data.Profunctor.Choice line 33, column 3 - line 33, column 36: " + [ v.constructor.name, v1.constructor.name ]);
      };
  }, Data_Functor.map(Data_Either.functorEither));
  exports["Choice"] = Choice;
  exports["fanin"] = fanin;
  exports["left"] = left;
  exports["right"] = right;
  exports["splitChoice"] = splitChoice;
  exports["choiceFn"] = choiceFn;
})(PS["Data.Profunctor.Choice"] = PS["Data.Profunctor.Choice"] || {});
(function(exports) {
    "use strict";
  var Prelude = PS["Prelude"];
  var Data_Profunctor = PS["Data.Profunctor"];
  var Control_Semigroupoid = PS["Control.Semigroupoid"];        

  /**
 *  | The `Closed` class extends the `Profunctor` class to work with functions.
 */  
  var Closed = function (__superclass_Data$dotProfunctor$dotProfunctor_0, closed) {
      this["__superclass_Data.Profunctor.Profunctor_0"] = __superclass_Data$dotProfunctor$dotProfunctor_0;
      this.closed = closed;
  };
  var closedFunction = new Closed(function () {
      return Data_Profunctor.profunctorFn;
  }, Control_Semigroupoid.compose(Control_Semigroupoid.semigroupoidFn));

  /**
 *  | The `Closed` class extends the `Profunctor` class to work with functions.
 */  
  var closed = function (dict) {
      return dict.closed;
  };
  exports["Closed"] = Closed;
  exports["closed"] = closed;
  exports["closedFunction"] = closedFunction;
})(PS["Data.Profunctor.Closed"] = PS["Data.Profunctor.Closed"] || {});
(function(exports) {
    "use strict";
  var Data_Either = PS["Data.Either"];
  var Data_Profunctor = PS["Data.Profunctor"];        

  /**
 *  | The `Cochoice` class provides the dual operations of the `Choice` class.
 */  
  var Cochoice = function (__superclass_Data$dotProfunctor$dotProfunctor_0, unleft, unright) {
      this["__superclass_Data.Profunctor.Profunctor_0"] = __superclass_Data$dotProfunctor$dotProfunctor_0;
      this.unleft = unleft;
      this.unright = unright;
  };

  /**
 *  | The `Cochoice` class provides the dual operations of the `Choice` class.
 */  
  var unright = function (dict) {
      return dict.unright;
  };

  /**
 *  | The `Cochoice` class provides the dual operations of the `Choice` class.
 */  
  var unleft = function (dict) {
      return dict.unleft;
  };
  exports["Cochoice"] = Cochoice;
  exports["unleft"] = unleft;
  exports["unright"] = unright;
})(PS["Data.Profunctor.Cochoice"] = PS["Data.Profunctor.Cochoice"] || {});
(function(exports) {
    "use strict";
  var Data_Tuple = PS["Data.Tuple"];
  var Data_Profunctor = PS["Data.Profunctor"];        

  /**
 *  | The `Costrong` class provides the dual operations of the `Strong` class.
 */  
  var Costrong = function (__superclass_Data$dotProfunctor$dotProfunctor_0, unfirst, unsecond) {
      this["__superclass_Data.Profunctor.Profunctor_0"] = __superclass_Data$dotProfunctor$dotProfunctor_0;
      this.unfirst = unfirst;
      this.unsecond = unsecond;
  };

  /**
 *  | The `Costrong` class provides the dual operations of the `Strong` class.
 */  
  var unsecond = function (dict) {
      return dict.unsecond;
  };

  /**
 *  | The `Costrong` class provides the dual operations of the `Strong` class.
 */  
  var unfirst = function (dict) {
      return dict.unfirst;
  };
  exports["Costrong"] = Costrong;
  exports["unfirst"] = unfirst;
  exports["unsecond"] = unsecond;
})(PS["Data.Profunctor.Costrong"] = PS["Data.Profunctor.Costrong"] || {});
(function(exports) {
    "use strict";
  var Prelude = PS["Prelude"];
  var Data_Profunctor = PS["Data.Profunctor"];
  var Data_Tuple = PS["Data.Tuple"];
  var Data_Functor = PS["Data.Functor"];
  var Control_Semigroupoid = PS["Control.Semigroupoid"];
  var Control_Category = PS["Control.Category"];        

  /**
 *  | The `Strong` class extends `Profunctor` with combinators for working with
 *  | product types.
 *  |
 *  | `first` and `second` lift values in a `Profunctor` to act on the first and
 *  | second components of a `Tuple`, respectively.
 *  |
 *  | Another way to think about Strong is to piggyback on the intuition of
 *  | inputs and outputs.  Rewriting the type signature in this light then yields:
 *  | ```
 *  | first ::  forall input output a. p input output -> p (Tuple input a) (Tuple output a)
 *  | second :: forall input output a. p input output -> p (Tuple a input) (Tuple a output)
 *  | ```
 *  | If we specialize the profunctor p to the function arrow, we get the following type
 *  | signatures, which may look a bit more familiar:
 *  | ```
 *  | first ::  forall input output a. (input -> output) -> (Tuple input a) -> (Tuple output a)
 *  | second :: forall input output a. (input -> output) -> (Tuple a input) -> (Tuple a output)
 *  | ```
 *  | So, when the `profunctor` is `Function` application, `first` essentially applies your function
 *  | to the first element of a `Tuple`, and `second` applies it to the second element (same as `map` would do).
 */  
  var Strong = function (__superclass_Data$dotProfunctor$dotProfunctor_0, first, second) {
      this["__superclass_Data.Profunctor.Profunctor_0"] = __superclass_Data$dotProfunctor$dotProfunctor_0;
      this.first = first;
      this.second = second;
  };
  var strongFn = new Strong(function () {
      return Data_Profunctor.profunctorFn;
  }, function (a2b) {
      return function (v) {
          return new Data_Tuple.Tuple(a2b(v.value0), v.value1);
      };
  }, Data_Functor.map(Data_Tuple.functorTuple));

  /**
 *  | The `Strong` class extends `Profunctor` with combinators for working with
 *  | product types.
 *  |
 *  | `first` and `second` lift values in a `Profunctor` to act on the first and
 *  | second components of a `Tuple`, respectively.
 *  |
 *  | Another way to think about Strong is to piggyback on the intuition of
 *  | inputs and outputs.  Rewriting the type signature in this light then yields:
 *  | ```
 *  | first ::  forall input output a. p input output -> p (Tuple input a) (Tuple output a)
 *  | second :: forall input output a. p input output -> p (Tuple a input) (Tuple a output)
 *  | ```
 *  | If we specialize the profunctor p to the function arrow, we get the following type
 *  | signatures, which may look a bit more familiar:
 *  | ```
 *  | first ::  forall input output a. (input -> output) -> (Tuple input a) -> (Tuple output a)
 *  | second :: forall input output a. (input -> output) -> (Tuple a input) -> (Tuple a output)
 *  | ```
 *  | So, when the `profunctor` is `Function` application, `first` essentially applies your function
 *  | to the first element of a `Tuple`, and `second` applies it to the second element (same as `map` would do).
 */  
  var second = function (dict) {
      return dict.second;
  };

  /**
 *  | The `Strong` class extends `Profunctor` with combinators for working with
 *  | product types.
 *  |
 *  | `first` and `second` lift values in a `Profunctor` to act on the first and
 *  | second components of a `Tuple`, respectively.
 *  |
 *  | Another way to think about Strong is to piggyback on the intuition of
 *  | inputs and outputs.  Rewriting the type signature in this light then yields:
 *  | ```
 *  | first ::  forall input output a. p input output -> p (Tuple input a) (Tuple output a)
 *  | second :: forall input output a. p input output -> p (Tuple a input) (Tuple a output)
 *  | ```
 *  | If we specialize the profunctor p to the function arrow, we get the following type
 *  | signatures, which may look a bit more familiar:
 *  | ```
 *  | first ::  forall input output a. (input -> output) -> (Tuple input a) -> (Tuple output a)
 *  | second :: forall input output a. (input -> output) -> (Tuple a input) -> (Tuple a output)
 *  | ```
 *  | So, when the `profunctor` is `Function` application, `first` essentially applies your function
 *  | to the first element of a `Tuple`, and `second` applies it to the second element (same as `map` would do).
 */  
  var first = function (dict) {
      return dict.first;
  };

  /**
 *  | Compose a value acting on a `Tuple` from two values, each acting on one of
 *  | the components of the `Tuple`.
 *  |
 *  | Specializing `(***)` to function application would look like this:
 *  | ```
 *  | (***) :: forall a b c d. (a -> b) -> (c -> d) -> (Tuple a c) -> (Tuple b d)
 *  | ```
 *  | We take two functions, `f` and `g`, and we transform them into a single function which
 *  | takes a `Tuple` and maps `f` over the first element and `g` over the second.  Just like `bi-map`
 *  | would do for the `bi-functor` instance of `Tuple`.
 */  
  var splitStrong = function (dictCategory) {
      return function (dictStrong) {
          return function (l) {
              return function (r) {
                  return Control_Semigroupoid.composeFlipped(dictCategory["__superclass_Control.Semigroupoid.Semigroupoid_0"]())(first(dictStrong)(l))(second(dictStrong)(r));
              };
          };
      };
  };

  /**
 *  | Compose a value which introduces a `Tuple` from two values, each introducing
 *  | one side of the `Tuple`.
 *  |
 *  | This combinator is useful when assembling values from smaller components,
 *  | because it provides a way to support two different types of output.
 *  |
 *  | Specializing `(&&&)` to function application would look like this:
 *  | ```
 *  | (&&&) :: forall a b c d. (a -> b) -> (a -> c) -> (a -> (Tuple b c))
 *  | ```
 *  | We take two functions, `f` and `g`, with the same parameter type and we transform them into a
 *  | single function which takes one parameter and returns a `Tuple` of the results of running
 *  | `f` and `g` on the parameter, respectively.  This allows us to run two parallel computations
 *  | on the same input and return both results in a `Tuple`.
 */  
  var fanout = function (dictCategory) {
      return function (dictStrong) {
          return function (l) {
              return function (r) {
                  var split = Data_Profunctor.dimap(dictStrong["__superclass_Data.Profunctor.Profunctor_0"]())(Control_Category.id(Control_Category.categoryFn))(function (a) {
                      return new Data_Tuple.Tuple(a, a);
                  })(Control_Category.id(dictCategory));
                  return Control_Semigroupoid.composeFlipped(dictCategory["__superclass_Control.Semigroupoid.Semigroupoid_0"]())(split)(splitStrong(dictCategory)(dictStrong)(l)(r));
              };
          };
      };
  };
  exports["Strong"] = Strong;
  exports["fanout"] = fanout;
  exports["first"] = first;
  exports["second"] = second;
  exports["splitStrong"] = splitStrong;
  exports["strongFn"] = strongFn;
})(PS["Data.Profunctor.Strong"] = PS["Data.Profunctor.Strong"] || {});
(function(exports) {
    "use strict";
  var Prelude = PS["Prelude"];
  var Control_Comonad = PS["Control.Comonad"];
  var Control_Extend = PS["Control.Extend"];
  var Data_Distributive = PS["Data.Distributive"];
  var Data_Either = PS["Data.Either"];
  var Data_Functor_Invariant = PS["Data.Functor.Invariant"];
  var Data_Newtype = PS["Data.Newtype"];
  var Data_Profunctor = PS["Data.Profunctor"];
  var Data_Profunctor_Closed = PS["Data.Profunctor.Closed"];
  var Data_Profunctor_Cochoice = PS["Data.Profunctor.Cochoice"];
  var Data_Profunctor_Costrong = PS["Data.Profunctor.Costrong"];
  var Data_Profunctor_Strong = PS["Data.Profunctor.Strong"];
  var Data_Tuple = PS["Data.Tuple"];
  var Control_Semigroupoid = PS["Control.Semigroupoid"];
  var Control_Category = PS["Control.Category"];
  var Data_Functor = PS["Data.Functor"];
  var Control_Apply = PS["Control.Apply"];
  var Control_Applicative = PS["Control.Applicative"];
  var Control_Bind = PS["Control.Bind"];
  var Control_Monad = PS["Control.Monad"];
  var Data_Function = PS["Data.Function"];        

  /**
 *  | `Costar` turns a `Functor` into a `Profunctor` "backwards".
 *  |
 *  | `Costar f` is also the co-Kleisli category for `f`.
 */  
  var Costar = function (x) {
      return x;
  };
  var semigroupoidCostar = function (dictExtend) {
      return new Control_Semigroupoid.Semigroupoid(function (v) {
          return function (v1) {
              return Control_Extend.composeCoKleisliFlipped(dictExtend)(v)(v1);
          };
      });
  };
  var profunctorCostar = function (dictFunctor) {
      return new Data_Profunctor.Profunctor(function (f) {
          return function (g) {
              return function (v) {
                  return function ($50) {
                      return g(v(Data_Functor.map(dictFunctor)(f)($50)));
                  };
              };
          };
      });
  };
  var strongCostar = function (dictComonad) {
      return new Data_Profunctor_Strong.Strong(function () {
          return profunctorCostar((dictComonad["__superclass_Control.Extend.Extend_0"]())["__superclass_Data.Functor.Functor_0"]());
      }, function (v) {
          return function (x) {
              return new Data_Tuple.Tuple(v(Data_Functor.map((dictComonad["__superclass_Control.Extend.Extend_0"]())["__superclass_Data.Functor.Functor_0"]())(Data_Tuple.fst)(x)), Data_Tuple.snd(Control_Comonad.extract(dictComonad)(x)));
          };
      }, function (v) {
          return function (x) {
              return new Data_Tuple.Tuple(Data_Tuple.fst(Control_Comonad.extract(dictComonad)(x)), v(Data_Functor.map((dictComonad["__superclass_Control.Extend.Extend_0"]())["__superclass_Data.Functor.Functor_0"]())(Data_Tuple.snd)(x)));
          };
      });
  };
  var newtypeCostar = new Data_Newtype.Newtype(function (n) {
      return n;
  }, Costar);
  var functorCostar = new Data_Functor.Functor(function (f) {
      return function (v) {
          return function ($51) {
              return f(v($51));
          };
      };
  });
  var invariantCostar = new Data_Functor_Invariant.Invariant(Data_Functor_Invariant.imapF(functorCostar));
  var distributiveCostar = new Data_Distributive.Distributive(function () {
      return functorCostar;
  }, function (dictFunctor) {
      return function (f) {
          return function ($52) {
              return Data_Distributive.distribute(distributiveCostar)(dictFunctor)(Data_Functor.map(dictFunctor)(f)($52));
          };
      };
  }, function (dictFunctor) {
      return function (f) {
          return function (a) {
              return Data_Functor.map(dictFunctor)(function (v) {
                  return v(a);
              })(f);
          };
      };
  });
  var costrongCostar = function (dictFunctor) {
      return new Data_Profunctor_Costrong.Costrong(function () {
          return profunctorCostar(dictFunctor);
      }, function (v) {
          return function (fb) {
              var bd = v(Data_Functor.map(dictFunctor)(function (a) {
                  return new Data_Tuple.Tuple(a, Data_Tuple.snd(bd));
              })(fb));
              return Data_Tuple.fst(bd);
          };
      }, function (v) {
          return function (fb) {
              var db = v(Data_Functor.map(dictFunctor)(function (a) {
                  return new Data_Tuple.Tuple(Data_Tuple.fst(db), a);
              })(fb));
              return Data_Tuple.snd(db);
          };
      });
  };
  var cochoiceCostar = function (dictApplicative) {
      return new Data_Profunctor_Cochoice.Cochoice(function () {
          return profunctorCostar((dictApplicative["__superclass_Control.Apply.Apply_0"]())["__superclass_Data.Functor.Functor_0"]());
      }, function (v) {
          var g = function ($53) {
              return Data_Either.either(Control_Category.id(Control_Category.categoryFn))(function (r) {
                  return g(Control_Applicative.pure(dictApplicative)(new Data_Either.Right(r)));
              })(v($53));
          };
          return function ($54) {
              return g(Data_Functor.map((dictApplicative["__superclass_Control.Apply.Apply_0"]())["__superclass_Data.Functor.Functor_0"]())(Data_Either.Left.create)($54));
          };
      }, function (v) {
          var g = function ($55) {
              return Data_Either.either(function (l) {
                  return g(Control_Applicative.pure(dictApplicative)(new Data_Either.Left(l)));
              })(Control_Category.id(Control_Category.categoryFn))(v($55));
          };
          return function ($56) {
              return g(Data_Functor.map((dictApplicative["__superclass_Control.Apply.Apply_0"]())["__superclass_Data.Functor.Functor_0"]())(Data_Either.Right.create)($56));
          };
      });
  };
  var closedCostar = function (dictFunctor) {
      return new Data_Profunctor_Closed.Closed(function () {
          return profunctorCostar(dictFunctor);
      }, function (v) {
          return function (g) {
              return function (x) {
                  return v(Data_Functor.map(dictFunctor)(function (v1) {
                      return v1(x);
                  })(g));
              };
          };
      });
  };
  var categoryCostar = function (dictComonad) {
      return new Control_Category.Category(function () {
          return semigroupoidCostar(dictComonad["__superclass_Control.Extend.Extend_0"]());
      }, Control_Comonad.extract(dictComonad));
  };
  var applyCostar = new Control_Apply.Apply(function () {
      return functorCostar;
  }, function (v) {
      return function (v1) {
          return function (a) {
              return v(a)(v1(a));
          };
      };
  });
  var bindCostar = new Control_Bind.Bind(function () {
      return applyCostar;
  }, function (v) {
      return function (f) {
          return function (x) {
              var $48 = f(v(x));
              return $48(x);
          };
      };
  });
  var applicativeCostar = new Control_Applicative.Applicative(function () {
      return applyCostar;
  }, function (a) {
      return function (v) {
          return a;
      };
  });
  var monadCostar = new Control_Monad.Monad(function () {
      return applicativeCostar;
  }, function () {
      return bindCostar;
  });
  exports["Costar"] = Costar;
  exports["newtypeCostar"] = newtypeCostar;
  exports["semigroupoidCostar"] = semigroupoidCostar;
  exports["categoryCostar"] = categoryCostar;
  exports["functorCostar"] = functorCostar;
  exports["invariantCostar"] = invariantCostar;
  exports["applyCostar"] = applyCostar;
  exports["applicativeCostar"] = applicativeCostar;
  exports["bindCostar"] = bindCostar;
  exports["monadCostar"] = monadCostar;
  exports["distributiveCostar"] = distributiveCostar;
  exports["profunctorCostar"] = profunctorCostar;
  exports["strongCostar"] = strongCostar;
  exports["costrongCostar"] = costrongCostar;
  exports["cochoiceCostar"] = cochoiceCostar;
  exports["closedCostar"] = closedCostar;
})(PS["Data.Profunctor.Costar"] = PS["Data.Profunctor.Costar"] || {});
(function(exports) {
    "use strict";
  var Prelude = PS["Prelude"];
  var Control_Alt = PS["Control.Alt"];
  var Control_Alternative = PS["Control.Alternative"];
  var Control_MonadPlus = PS["Control.MonadPlus"];
  var Control_MonadZero = PS["Control.MonadZero"];
  var Control_Plus = PS["Control.Plus"];
  var Data_Distributive = PS["Data.Distributive"];
  var Data_Either = PS["Data.Either"];
  var Data_Functor_Invariant = PS["Data.Functor.Invariant"];
  var Data_Newtype = PS["Data.Newtype"];
  var Data_Profunctor = PS["Data.Profunctor"];
  var Data_Profunctor_Choice = PS["Data.Profunctor.Choice"];
  var Data_Profunctor_Closed = PS["Data.Profunctor.Closed"];
  var Data_Profunctor_Strong = PS["Data.Profunctor.Strong"];
  var Data_Tuple = PS["Data.Tuple"];
  var Control_Semigroupoid = PS["Control.Semigroupoid"];
  var Control_Bind = PS["Control.Bind"];
  var Control_Category = PS["Control.Category"];
  var Control_Applicative = PS["Control.Applicative"];
  var Data_Functor = PS["Data.Functor"];
  var Control_Apply = PS["Control.Apply"];
  var Control_Monad = PS["Control.Monad"];
  var Data_Function = PS["Data.Function"];        

  /**
 *  | `Star` turns a `Functor` into a `Profunctor`.
 *  |
 *  | `Star f` is also the Kleisli category for `f`
 */  
  var Star = function (x) {
      return x;
  };
  var semigroupoidStar = function (dictBind) {
      return new Control_Semigroupoid.Semigroupoid(function (v) {
          return function (v1) {
              return function (x) {
                  return Control_Bind.bind(dictBind)(v1(x))(v);
              };
          };
      });
  };
  var profunctorStar = function (dictFunctor) {
      return new Data_Profunctor.Profunctor(function (f) {
          return function (g) {
              return function (v) {
                  return function ($75) {
                      return Data_Functor.map(dictFunctor)(g)(v(f($75)));
                  };
              };
          };
      });
  };
  var strongStar = function (dictFunctor) {
      return new Data_Profunctor_Strong.Strong(function () {
          return profunctorStar(dictFunctor);
      }, function (v) {
          return function (v1) {
              return Data_Functor.map(dictFunctor)(function (v2) {
                  return new Data_Tuple.Tuple(v2, v1.value1);
              })(v(v1.value0));
          };
      }, function (v) {
          return function (v1) {
              return Data_Functor.map(dictFunctor)(Data_Tuple.Tuple.create(v1.value0))(v(v1.value1));
          };
      });
  };
  var newtypeStar = new Data_Newtype.Newtype(function (n) {
      return n;
  }, Star);
  var invariantStar = function (dictInvariant) {
      return new Data_Functor_Invariant.Invariant(function (f) {
          return function (g) {
              return function (v) {
                  return function ($76) {
                      return Data_Functor_Invariant.imap(dictInvariant)(f)(g)(v($76));
                  };
              };
          };
      });
  };
  var functorStar = function (dictFunctor) {
      return new Data_Functor.Functor(function (f) {
          return function (v) {
              return function ($77) {
                  return Data_Functor.map(dictFunctor)(f)(v($77));
              };
          };
      });
  };
  var distributiveStar = function (dictDistributive) {
      return new Data_Distributive.Distributive(function () {
          return functorStar(dictDistributive["__superclass_Data.Functor.Functor_0"]());
      }, function (dictFunctor) {
          return function (f) {
              return function ($78) {
                  return Data_Distributive.distribute(distributiveStar(dictDistributive))(dictFunctor)(Data_Functor.map(dictFunctor)(f)($78));
              };
          };
      }, function (dictFunctor) {
          return function (f) {
              return function (a) {
                  return Data_Distributive.collect(dictDistributive)(dictFunctor)(function (v) {
                      return v(a);
                  })(f);
              };
          };
      });
  };
  var closedStar = function (dictDistributive) {
      return new Data_Profunctor_Closed.Closed(function () {
          return profunctorStar(dictDistributive["__superclass_Data.Functor.Functor_0"]());
      }, function (v) {
          return function (g) {
              return Data_Distributive.distribute(dictDistributive)(Data_Functor.functorFn)(function ($79) {
                  return v(g($79));
              });
          };
      });
  };
  var choiceStar = function (dictApplicative) {
      return new Data_Profunctor_Choice.Choice(function () {
          return profunctorStar((dictApplicative["__superclass_Control.Apply.Apply_0"]())["__superclass_Data.Functor.Functor_0"]());
      }, function (v) {
          return Star(Data_Either.either(function ($80) {
              return Data_Functor.map((dictApplicative["__superclass_Control.Apply.Apply_0"]())["__superclass_Data.Functor.Functor_0"]())(Data_Either.Left.create)(v($80));
          })(function ($81) {
              return Control_Applicative.pure(dictApplicative)(Data_Either.Right.create($81));
          }));
      }, function (v) {
          return Star(Data_Either.either(function ($82) {
              return Control_Applicative.pure(dictApplicative)(Data_Either.Left.create($82));
          })(function ($83) {
              return Data_Functor.map((dictApplicative["__superclass_Control.Apply.Apply_0"]())["__superclass_Data.Functor.Functor_0"]())(Data_Either.Right.create)(v($83));
          }));
      });
  };
  var categoryStar = function (dictMonad) {
      return new Control_Category.Category(function () {
          return semigroupoidStar(dictMonad["__superclass_Control.Bind.Bind_1"]());
      }, Control_Applicative.pure(dictMonad["__superclass_Control.Applicative.Applicative_0"]()));
  };
  var applyStar = function (dictApply) {
      return new Control_Apply.Apply(function () {
          return functorStar(dictApply["__superclass_Data.Functor.Functor_0"]());
      }, function (v) {
          return function (v1) {
              return function (a) {
                  return Control_Apply.apply(dictApply)(v(a))(v1(a));
              };
          };
      });
  };
  var bindStar = function (dictBind) {
      return new Control_Bind.Bind(function () {
          return applyStar(dictBind["__superclass_Control.Apply.Apply_0"]());
      }, function (v) {
          return function (f) {
              return function (x) {
                  return Control_Bind.bind(dictBind)(v(x))(function (a) {
                      var $70 = f(a);
                      return $70(x);
                  });
              };
          };
      });
  };
  var applicativeStar = function (dictApplicative) {
      return new Control_Applicative.Applicative(function () {
          return applyStar(dictApplicative["__superclass_Control.Apply.Apply_0"]());
      }, function (a) {
          return function (v) {
              return Control_Applicative.pure(dictApplicative)(a);
          };
      });
  };
  var monadStar = function (dictMonad) {
      return new Control_Monad.Monad(function () {
          return applicativeStar(dictMonad["__superclass_Control.Applicative.Applicative_0"]());
      }, function () {
          return bindStar(dictMonad["__superclass_Control.Bind.Bind_1"]());
      });
  };
  var altStar = function (dictAlt) {
      return new Control_Alt.Alt(function () {
          return functorStar(dictAlt["__superclass_Data.Functor.Functor_0"]());
      }, function (v) {
          return function (v1) {
              return function (a) {
                  return Control_Alt.alt(dictAlt)(v(a))(v1(a));
              };
          };
      });
  };
  var plusStar = function (dictPlus) {
      return new Control_Plus.Plus(function () {
          return altStar(dictPlus["__superclass_Control.Alt.Alt_0"]());
      }, function (v) {
          return Control_Plus.empty(dictPlus);
      });
  };
  var alternativeStar = function (dictAlternative) {
      return new Control_Alternative.Alternative(function () {
          return applicativeStar(dictAlternative["__superclass_Control.Applicative.Applicative_0"]());
      }, function () {
          return plusStar(dictAlternative["__superclass_Control.Plus.Plus_1"]());
      });
  };
  var monadZeroStar = function (dictMonadZero) {
      return new Control_MonadZero.MonadZero(function () {
          return alternativeStar(dictMonadZero["__superclass_Control.Alternative.Alternative_1"]());
      }, function () {
          return monadStar(dictMonadZero["__superclass_Control.Monad.Monad_0"]());
      });
  };
  var monadPlusStar = function (dictMonadPlus) {
      return new Control_MonadPlus.MonadPlus(function () {
          return monadZeroStar(dictMonadPlus["__superclass_Control.MonadZero.MonadZero_0"]());
      });
  };
  exports["Star"] = Star;
  exports["newtypeStar"] = newtypeStar;
  exports["semigroupoidStar"] = semigroupoidStar;
  exports["categoryStar"] = categoryStar;
  exports["functorStar"] = functorStar;
  exports["invariantStar"] = invariantStar;
  exports["applyStar"] = applyStar;
  exports["applicativeStar"] = applicativeStar;
  exports["bindStar"] = bindStar;
  exports["monadStar"] = monadStar;
  exports["altStar"] = altStar;
  exports["plusStar"] = plusStar;
  exports["alternativeStar"] = alternativeStar;
  exports["monadZeroStar"] = monadZeroStar;
  exports["monadPlusStar"] = monadPlusStar;
  exports["distributiveStar"] = distributiveStar;
  exports["profunctorStar"] = profunctorStar;
  exports["strongStar"] = strongStar;
  exports["choiceStar"] = choiceStar;
  exports["closedStar"] = closedStar;
})(PS["Data.Profunctor.Star"] = PS["Data.Profunctor.Star"] || {});
(function(exports) {
    "use strict";
  var Prelude = PS["Prelude"];
  var Data_Foldable = PS["Data.Foldable"];
  var Data_List = PS["Data.List"];
  var Data_Newtype = PS["Data.Newtype"];
  var Data_Traversable = PS["Data.Traversable"];
  var Data_Show = PS["Data.Show"];
  var Data_Semigroup = PS["Data.Semigroup"];
  var Data_Eq = PS["Data.Eq"];
  var Data_Ord = PS["Data.Ord"];
  var Data_Semiring = PS["Data.Semiring"];
  var Data_List_Types = PS["Data.List.Types"];
  var Control_Bind = PS["Control.Bind"];
  var Control_Applicative = PS["Control.Applicative"];
  var Data_Functor = PS["Data.Functor"];
  var Data_Function = PS["Data.Function"];
  var Control_Apply = PS["Control.Apply"];
  var Control_Semigroupoid = PS["Control.Semigroupoid"];        

  /**
 *  | The free `Semiring` for a type `a`.
 */  
  var Free = function (x) {
      return x;
  };
  var showFree = function (dictShow) {
      return new Data_Show.Show(function (v) {
          return "(Free " + (Data_Show.show(Data_List_Types.showList(Data_List_Types.showList(dictShow)))(v) + ")");
      });
  };
  var semiringFree = new Data_Semiring.Semiring(function (v) {
      return function (v1) {
          return Data_Semigroup.append(Data_List_Types.semigroupList)(v)(v1);
      };
  }, function (v) {
      return function (v1) {
          return Control_Bind.bind(Data_List_Types.bindList)(v)(function (v2) {
              return Control_Bind.bind(Data_List_Types.bindList)(v1)(function (v3) {
                  return Control_Applicative.pure(Data_List_Types.applicativeList)(Data_Semigroup.append(Data_List_Types.semigroupList)(v2)(v3));
              });
          });
      };
  }, Data_List.singleton(Data_List_Types.Nil.value), Data_List_Types.Nil.value);
  var newtypeFree = new Data_Newtype.Newtype(function (n) {
      return n;
  }, Free);

  /**
 *  | `Free` is left adjoint to the forgetful functor from `Semiring`s to types.
 */  
  var liftFree = function (dictSemiring) {
      return function (f) {
          return function (v) {
              return Data_Foldable.sum(Data_List_Types.foldableList)(dictSemiring)(Data_Functor.map(Data_List_Types.functorList)(function ($60) {
                  return Data_Foldable.product(Data_List_Types.foldableList)(dictSemiring)(Data_Functor.map(Data_List_Types.functorList)(f)($60));
              })(v));
          };
      };
  };
  var functorFree = new Data_Functor.Functor(function (fn) {
      return function (v) {
          return Free(Data_Functor.map(Data_List_Types.functorList)(Data_Functor.map(Data_List_Types.functorList)(fn))(v));
      };
  });

  /**
 *  | Lift a value of type `a` to a value of type `Free a`
 */  
  var free = function (a) {
      return Data_List.singleton(Data_List.singleton(a));
  };

  /**
 *  | `Free` is left adjoint to the forgetful functor from `Semiring`s to types.
 */  
  var lowerFree = function (dictSemiring) {
      return function (f) {
          return function (a) {
              return f(free(a));
          };
      };
  };
  var foldableFree = new Data_Foldable.Foldable(function (dictMonoid) {
      return function (fn) {
          return function (v) {
              return Data_Foldable.fold(Data_List_Types.foldableList)(dictMonoid)(Data_Foldable.foldMap(Data_List_Types.foldableList)(Data_List_Types.monoidList)(Data_Functor.map(Data_List_Types.functorList)(fn))(v));
          };
      };
  }, function (fn) {
      return function (accum) {
          return function (v) {
              return Data_Foldable.foldl(Data_List_Types.foldableList)(Data_Foldable.foldl(Data_List_Types.foldableList)(fn))(accum)(v);
          };
      };
  }, function (fn) {
      return function (accum) {
          return function (v) {
              return Data_Foldable.foldr(Data_List_Types.foldableList)(Data_Function.flip(Data_Foldable.foldr(Data_List_Types.foldableList)(fn)))(accum)(v);
          };
      };
  });
  var traversableFree = new Data_Traversable.Traversable(function () {
      return foldableFree;
  }, function () {
      return functorFree;
  }, function (dictApplicative) {
      return function (v) {
          return Data_Functor.map((dictApplicative["__superclass_Control.Apply.Apply_0"]())["__superclass_Data.Functor.Functor_0"]())(Free)(Data_Traversable.sequence(Data_List_Types.traversableList)(dictApplicative)(Data_Functor.map(Data_List_Types.functorList)(Data_Traversable.sequence(Data_List_Types.traversableList)(dictApplicative))(v)));
      };
  }, function (dictApplicative) {
      return function (fn) {
          return function (freeA) {
              return Data_Traversable.sequence(traversableFree)(dictApplicative)(Data_Functor.map(functorFree)(fn)(freeA));
          };
      };
  });
  var eqFree = function (dictEq) {
      return new Data_Eq.Eq(function (v) {
          return function (v1) {
              return Data_Eq.eq(Data_List_Types.eqList(Data_List_Types.eqList(dictEq)))(v)(v1);
          };
      });
  };
  var ordFree = function (dictOrd) {
      return new Data_Ord.Ord(function () {
          return eqFree(dictOrd["__superclass_Data.Eq.Eq_0"]());
      }, function (v) {
          return function (v1) {
              return Data_Ord.compare(Data_List_Types.ordList(Data_List_Types.ordList(dictOrd)))(v)(v1);
          };
      });
  };
  var applyFree = new Control_Apply.Apply(function () {
      return functorFree;
  }, function (v) {
      return function (v1) {
          return Free(Control_Bind.bind(Data_List_Types.bindList)(v)(function (v2) {
              return Control_Bind.bind(Data_List_Types.bindList)(v1)(function (v3) {
                  return Control_Applicative.pure(Data_List_Types.applicativeList)(Control_Apply.apply(Data_List_Types.applyList)(v2)(v3));
              });
          }));
      };
  });
  var applicativeFree = new Control_Applicative.Applicative(function () {
      return applyFree;
  }, free);
  exports["Free"] = Free;
  exports["free"] = free;
  exports["liftFree"] = liftFree;
  exports["lowerFree"] = lowerFree;
  exports["newtypeFree"] = newtypeFree;
  exports["showFree"] = showFree;
  exports["eqFree"] = eqFree;
  exports["ordFree"] = ordFree;
  exports["semiringFree"] = semiringFree;
  exports["functorFree"] = functorFree;
  exports["applyFree"] = applyFree;
  exports["applicativeFree"] = applicativeFree;
  exports["foldableFree"] = foldableFree;
  exports["traversableFree"] = traversableFree;
})(PS["Data.Semiring.Free"] = PS["Data.Semiring.Free"] || {});
(function(exports) {
  
  /**
 *  | This module defines a type of sets as balanced 2-3 trees, based on
 *  | <http://www.cs.princeton.edu/~dpw/courses/cos326-12/ass/2-3-trees.pdf>
 *  |
 *  | Qualified import is encouraged, so as to avoid name clashes with other modules.
 */  
  "use strict";
  var Prelude = PS["Prelude"];
  var Control_Monad_Eff = PS["Control.Monad.Eff"];
  var Control_Monad_Rec_Class = PS["Control.Monad.Rec.Class"];
  var Control_Monad_ST = PS["Control.Monad.ST"];
  var Data_Array = PS["Data.Array"];
  var Data_Array_ST = PS["Data.Array.ST"];
  var Data_Foldable = PS["Data.Foldable"];
  var Data_List = PS["Data.List"];
  var Data_Map = PS["Data.Map"];
  var Data_Monoid = PS["Data.Monoid"];
  var Data_Unfoldable = PS["Data.Unfoldable"];
  var Partial_Unsafe = PS["Partial.Unsafe"];
  var Data_Eq = PS["Data.Eq"];
  var Data_Show = PS["Data.Show"];
  var Data_Semigroup = PS["Data.Semigroup"];
  var Data_Ord = PS["Data.Ord"];
  var Control_Semigroupoid = PS["Control.Semigroupoid"];
  var Data_Unit = PS["Data.Unit"];
  var Data_List_Types = PS["Data.List.Types"];
  var Data_HeytingAlgebra = PS["Data.HeytingAlgebra"];
  var Data_Ordering = PS["Data.Ordering"];
  var Control_Bind = PS["Control.Bind"];
  var Data_Function = PS["Data.Function"];
  var Control_Applicative = PS["Control.Applicative"];
  var Data_Semiring = PS["Data.Semiring"];        

  /**
 *  | `Set a` represents a set of values of type `a`
 */  
  var $$Set = (function () {
      function $$Set(value0) {
          this.value0 = value0;
      };
      $$Set.create = function (value0) {
          return new $$Set(value0);
      };
      return $$Set;
  })();

  /**
 *  | Form the union of two sets
 *  |
 *  | Running time: `O(n * log(m))`
 */  
  var union = function (dictOrd) {
      return function (v) {
          return function (v1) {
              return new $$Set(Data_Map.union(dictOrd)(v.value0)(v1.value0));
          };
      };
  };
  var toList = function (v) {
      return Data_Map.keys(v.value0);
  };

  /**
 *  | Convert a set to an unfoldable structure.
 */  
  var toUnfoldable = function (dictUnfoldable) {
      return function ($59) {
          return Data_List.toUnfoldable(dictUnfoldable)(toList($59));
      };
  };

  /**
 *  | Find the size of a set
 */  
  var size = function (v) {
      return Data_Map.size(v.value0);
  };

  /**
 *  | Create a set with one element
 */  
  var singleton = function (a) {
      return new $$Set(Data_Map.singleton(a)(Data_Unit.unit));
  };
  var showSet = function (dictShow) {
      return new Data_Show.Show(function (s) {
          return "(fromFoldable " + (Data_Show.show(Data_List_Types.showList(dictShow))(toList(s)) + ")");
      });
  };
  var semigroupSet = function (dictOrd) {
      return new Data_Semigroup.Semigroup(union(dictOrd));
  };

  /**
 *  | Test if a value is a member of a set
 */  
  var member = function (dictOrd) {
      return function (a) {
          return function (v) {
              return Data_Map.member(dictOrd)(a)(v.value0);
          };
      };
  };

  /**
 *  | Test if a set is empty
 */  
  var isEmpty = function (v) {
      return Data_Map.isEmpty(v.value0);
  };

  /**
 *  | Insert a value into a set
 */  
  var insert = function (dictOrd) {
      return function (a) {
          return function (v) {
              return new $$Set(Data_Map.insert(dictOrd)(a)(Data_Unit.unit)(v.value0));
          };
      };
  };
  var foldableSet = new Data_Foldable.Foldable(function (dictMonoid) {
      return function (f) {
          return function ($60) {
              return Data_Foldable.foldMap(Data_List_Types.foldableList)(dictMonoid)(f)(toList($60));
          };
      };
  }, function (f) {
      return function (x) {
          return function ($61) {
              return Data_Foldable.foldl(Data_List_Types.foldableList)(f)(x)(toList($61));
          };
      };
  }, function (f) {
      return function (x) {
          return function ($62) {
              return Data_Foldable.foldr(Data_List_Types.foldableList)(f)(x)(toList($62));
          };
      };
  });
  var eqSet = function (dictEq) {
      return new Data_Eq.Eq(function (v) {
          return function (v1) {
              return Data_Eq.eq(Data_Map.eqMap(dictEq)(Data_Eq.eqUnit))(v.value0)(v1.value0);
          };
      });
  };
  var ordSet = function (dictOrd) {
      return new Data_Ord.Ord(function () {
          return eqSet(dictOrd["__superclass_Data.Eq.Eq_0"]());
      }, function (s1) {
          return function (s2) {
              return Data_Ord.compare(Data_List_Types.ordList(dictOrd))(toList(s1))(toList(s2));
          };
      });
  };

  /**
 *  | An empty set
 */  
  var empty = new $$Set(Data_Map.empty);

  /**
 *  | Create a set from a foldable structure.
 */  
  var fromFoldable = function (dictFoldable) {
      return function (dictOrd) {
          return Data_Foldable.foldl(dictFoldable)(function (m) {
              return function (a) {
                  return insert(dictOrd)(a)(m);
              };
          })(empty);
      };
  };

  /**
 *  | The set of elements which are in both the first and second set
 */  
  var intersection = function (dictOrd) {
      return function (s1) {
          return function (s2) {
              var toArray = function ($63) {
                  return Data_Array.fromFoldable(Data_List_Types.foldableList)(toList($63));
              };
              var rs = toArray(s2);
              var rl = Data_Array.length(rs);
              var ls = toArray(s1);
              var ll = Data_Array.length(ls);
              var intersect = function (acc) {
                  var go = Partial_Unsafe.unsafePartial(function (dictPartial) {
                      return function (l) {
                          return function (r) {
                              var $52 = l < ll && r < rl;
                              if ($52) {
                                  var $53 = Data_Ord.compare(dictOrd)(ls[l])(rs[r]);
                                  if ($53 instanceof Data_Ordering.EQ) {
                                      return function __do() {
                                          Data_Array_ST.pushSTArray(acc)(ls[l])();
                                          return new Control_Monad_Rec_Class.Loop({
                                              a: l + 1 | 0, 
                                              b: r + 1 | 0
                                          });
                                      };
                                  };
                                  if ($53 instanceof Data_Ordering.LT) {
                                      return Control_Applicative.pure(Control_Monad_Eff.applicativeEff)(new Control_Monad_Rec_Class.Loop({
                                          a: l + 1 | 0, 
                                          b: r
                                      }));
                                  };
                                  if ($53 instanceof Data_Ordering.GT) {
                                      return Control_Applicative.pure(Control_Monad_Eff.applicativeEff)(new Control_Monad_Rec_Class.Loop({
                                          a: l, 
                                          b: r + 1 | 0
                                      }));
                                  };
                                  throw new Error("Failed pattern match at Data.Set line 158, column 12 - line 163, column 43: " + [ $53.constructor.name ]);
                              };
                              if (!$52) {
                                  return Control_Applicative.pure(Control_Monad_Eff.applicativeEff)(new Control_Monad_Rec_Class.Done(acc));
                              };
                              throw new Error("Failed pattern match at Data.Set line 157, column 7 - line 164, column 24: " + [ $52.constructor.name ]);
                          };
                      };
                  });
                  return Control_Monad_Rec_Class.tailRecM2(Control_Monad_Rec_Class.monadRecEff)(go)(0)(0);
              };
              return fromFoldable(Data_Foldable.foldableArray)(dictOrd)(Control_Monad_Eff.runPure(Data_Array_ST.runSTArray(Control_Bind.bind(Control_Monad_Eff.bindEff)(Data_Array_ST.emptySTArray)(intersect))));
          };
      };
  };

  /**
 *  | Maps over the values in a set.
 *  |
 *  | This operation is not structure-preserving for sets, so is not a valid
 *  | `Functor`. An example case: mapping `const x` over a set with `n > 0`
 *  | elements will result in a set with one element.
 */  
  var map = function (dictOrd) {
      return function (f) {
          return Data_Foldable.foldl(foldableSet)(function (m) {
              return function (a) {
                  return insert(dictOrd)(f(a))(m);
              };
          })(empty);
      };
  };
  var monoidSet = function (dictOrd) {
      return new Data_Monoid.Monoid(function () {
          return semigroupSet(dictOrd);
      }, empty);
  };

  /**
 *  | Form the union of a collection of sets
 */  
  var unions = function (dictFoldable) {
      return function (dictOrd) {
          return Data_Foldable.foldl(dictFoldable)(union(dictOrd))(empty);
      };
  };

  /**
 *  | Delete a value from a set
 */  
  var $$delete = function (dictOrd) {
      return function (a) {
          return function (v) {
              return new $$Set(Data_Map["delete"](dictOrd)(a)(v.value0));
          };
      };
  };

  /**
 *  | Form the set difference
 */  
  var difference = function (dictOrd) {
      return function (s1) {
          return function (s2) {
              return Data_Foldable.foldl(Data_List_Types.foldableList)(Data_Function.flip($$delete(dictOrd)))(s1)(toList(s2));
          };
      };
  };

  /**
 *  | True if and only if every element in the first set
 *  | is an element of the second set
 */  
  var subset = function (dictOrd) {
      return function (s1) {
          return function (s2) {
              return isEmpty(difference(dictOrd)(s1)(s2));
          };
      };
  };

  /**
 *  | True if and only if the first set is a subset of the second set
 *  | and the sets are not equal
 */  
  var properSubset = function (dictOrd) {
      return function (s1) {
          return function (s2) {
              return subset(dictOrd)(s1)(s2) && Data_Eq.notEq(eqSet(dictOrd["__superclass_Data.Eq.Eq_0"]()))(s1)(s2);
          };
      };
  };

  /**
 *  | Check whether the underlying tree satisfies the 2-3 invariant
 *  |
 *  | This function is provided for internal use.
 */  
  var checkValid = function (v) {
      return Data_Map.checkValid(v.value0);
  };
  exports["checkValid"] = checkValid;
  exports["delete"] = $$delete;
  exports["difference"] = difference;
  exports["empty"] = empty;
  exports["fromFoldable"] = fromFoldable;
  exports["insert"] = insert;
  exports["intersection"] = intersection;
  exports["isEmpty"] = isEmpty;
  exports["map"] = map;
  exports["member"] = member;
  exports["properSubset"] = properSubset;
  exports["singleton"] = singleton;
  exports["size"] = size;
  exports["subset"] = subset;
  exports["toUnfoldable"] = toUnfoldable;
  exports["union"] = union;
  exports["unions"] = unions;
  exports["eqSet"] = eqSet;
  exports["showSet"] = showSet;
  exports["ordSet"] = ordSet;
  exports["monoidSet"] = monoidSet;
  exports["semigroupSet"] = semigroupSet;
  exports["foldableSet"] = foldableSet;
})(PS["Data.Set"] = PS["Data.Set"] || {});
(function(exports) {
  /* global exports */
  "use strict";

  // module Data.StrMap

  exports._copy = function (m) {
    var r = {};
    for (var k in m) {
      if (m.hasOwnProperty(k)) {
        r[k] = m[k];
      }
    }
    return r;
  };

  exports._copyEff = function (m) {
    return function () {
      var r = {};
      for (var k in m) {
        if (m.hasOwnProperty(k)) {
          r[k] = m[k];
        }
      }
      return r;
    };
  };

  exports.empty = {};

  exports.runST = function (f) {
    return f;
  };

  // jshint maxparams: 2
  exports._fmapStrMap = function (m0, f) {
    var m = {};
    for (var k in m0) {
      if (m0.hasOwnProperty(k)) {
        m[k] = f(m0[k]);
      }
    }
    return m;
  };

  // jshint maxparams: 2
  exports._mapWithKey = function (m0, f) {
    var m = {};
    for (var k in m0) {
      if (m0.hasOwnProperty(k)) {
        m[k] = f(k)(m0[k]);
      }
    }
    return m;
  };

  // jshint maxparams: 1
  exports._foldM = function (bind) {
    return function (f) {
      return function (mz) {
        return function (m) {
          var acc = mz;
          function g(k) {
            return function (z) {
              return f(z)(k)(m[k]);
            };
          }
          for (var k in m) {
            if (m.hasOwnProperty(k)) {
              acc = bind(acc)(g(k));
            }
          }
          return acc;
        };
      };
    };
  };

  // jshint maxparams: 4
  exports._foldSCStrMap = function (m, z, f, fromMaybe) {
    for (var k in m) {
      if (m.hasOwnProperty(k)) {
        var maybeR = f(z)(k)(m[k]);
        var r = fromMaybe(null)(maybeR);
        if (r === null) return z;
        else z = r;
      }
    }
    return z;
  };

  // jshint maxparams: 1
  exports.all = function (f) {
    return function (m) {
      for (var k in m) {
        if (m.hasOwnProperty(k) && !f(k)(m[k])) return false;
      }
      return true;
    };
  };

  exports.size = function (m) {
    var s = 0;
    for (var k in m) {
      if (m.hasOwnProperty(k)) {
        ++s;
      }
    }
    return s;
  };

  // jshint maxparams: 4
  exports._lookup = function (no, yes, k, m) {
    return k in m ? yes(m[k]) : no;
  };

  // jshint maxparams: 2
  exports._unsafeDeleteStrMap = function (m, k) {
    delete m[k];
    return m;
  };

  // jshint maxparams: 4
  exports._lookupST = function (no, yes, k, m) {
    return function () {
      return k in m ? yes(m[k]) : no;
    };
  };

  function _collect(f) {
    return function (m) {
      var r = [];
      for (var k in m) {
        if (m.hasOwnProperty(k)) {
          r.push(f(k)(m[k]));
        }
      }
      return r;
    };
  }

  exports._collect = _collect;

  exports.keys = Object.keys || _collect(function (k) {
    return function () { return k; };
  });
})(PS["Data.StrMap"] = PS["Data.StrMap"] || {});
(function(exports) {
  /* global exports */
  "use strict";

  // module Data.StrMap.ST

  exports["new"] = function () {
    return {};
  };

  exports.peekImpl = function (just) {
    return function (nothing) {
      return function (m) {
        return function (k) {
          return function () {
            return {}.hasOwnProperty.call(m, k) ? just(m[k]) : nothing;
          };
        };
      };
    };
  };

  exports.poke = function (m) {
    return function (k) {
      return function (v) {
        return function () {
          m[k] = v;
          return m;
        };
      };
    };
  };

  exports["delete"] = function (m) {
    return function (k) {
      return function () {
        delete m[k];
        return m;
      };
    };
  };
})(PS["Data.StrMap.ST"] = PS["Data.StrMap.ST"] || {});
(function(exports) {
  
  /**
 *  | Helper functions for working with mutable maps using the `ST` effect.
 *  |
 *  | This module can be used when performance is important and mutation is a local effect.
 */  
  "use strict";
  var $foreign = PS["Data.StrMap.ST"];
  var Control_Monad_Eff = PS["Control.Monad.Eff"];
  var Control_Monad_ST = PS["Control.Monad.ST"];
  var Data_Maybe = PS["Data.Maybe"];        

  /**
 *  | Get the value for a key in a mutable map
 */  
  var peek = $foreign.peekImpl(Data_Maybe.Just.create)(Data_Maybe.Nothing.value);
  exports["peek"] = peek;
  exports["delete"] = $foreign["delete"];
  exports["new"] = $foreign["new"];
  exports["poke"] = $foreign.poke;
})(PS["Data.StrMap.ST"] = PS["Data.StrMap.ST"] || {});
(function(exports) {
  
  /**
 *  | This module defines a type of native Javascript maps which
 *  | require the keys to be strings.
 *  |
 *  | To maximize performance, Javascript objects are not wrapped,
 *  | and some native code is used even when it's not necessary.
 */  
  "use strict";
  var $foreign = PS["Data.StrMap"];
  var Prelude = PS["Prelude"];
  var Control_Monad_Eff = PS["Control.Monad.Eff"];
  var Control_Monad_ST = PS["Control.Monad.ST"];
  var Data_Foldable = PS["Data.Foldable"];
  var Data_Function_Uncurried = PS["Data.Function.Uncurried"];
  var Data_List = PS["Data.List"];
  var Data_Maybe = PS["Data.Maybe"];
  var Data_Monoid = PS["Data.Monoid"];
  var Data_StrMap_ST = PS["Data.StrMap.ST"];
  var Data_Traversable = PS["Data.Traversable"];
  var Data_Tuple = PS["Data.Tuple"];
  var Data_Unfoldable = PS["Data.Unfoldable"];
  var Data_Functor = PS["Data.Functor"];
  var Data_Function = PS["Data.Function"];
  var Control_Apply = PS["Control.Apply"];
  var Control_Applicative = PS["Control.Applicative"];
  var Control_Category = PS["Control.Category"];
  var Data_Eq = PS["Data.Eq"];
  var Data_HeytingAlgebra = PS["Data.HeytingAlgebra"];
  var Data_Show = PS["Data.Show"];
  var Data_Semigroup = PS["Data.Semigroup"];
  var Control_Semigroupoid = PS["Control.Semigroupoid"];
  var Data_List_Types = PS["Data.List.Types"];
  var Control_Bind = PS["Control.Bind"];        

  /**
 *  | Get a list of the values in a map
 */  
  var values = function ($39) {
      return Data_List.fromFoldable(Data_Foldable.foldableArray)($foreign._collect(function (v) {
          return function (v1) {
              return v1;
          };
      })($39));
  };

  /**
 *  | Convert a map into a list of key/value pairs
 */  
  var toList = function ($40) {
      return Data_List.fromFoldable(Data_Foldable.foldableArray)($foreign._collect(Data_Tuple.Tuple.create)($40));
  };
  var toUnfoldable = function (dictUnfoldable) {
      return function ($41) {
          return Data_List.toUnfoldable(dictUnfoldable)(toList($41));
      };
  };

  /**
 *  | Convert an immutable map into a mutable map
 */  
  var thawST = $foreign._copyEff;
  var showStrMap = function (dictShow) {
      return new Data_Show.Show(function (m) {
          return "fromList " + Data_Show.show(Data_List_Types.showList(Data_Tuple.showTuple(Data_Show.showString)(dictShow)))(toList(m));
      });
  };
  var pureST = function (f) {
      return Control_Monad_Eff.runPure($foreign.runST(f));
  };

  /**
 *  | Create a map with one key/value pair
 */  
  var singleton = function (k) {
      return function (v) {
          return pureST(function __do() {
              var v1 = Data_StrMap_ST["new"]();
              Data_StrMap_ST.poke(v1)(k)(v)();
              return v1;
          });
      };
  };
  var mutate = function (f) {
      return function (m) {
          return pureST(function __do() {
              var v = thawST(m)();
              f(v)();
              return v;
          });
      };
  };

  /**
 *  | Test whether a `String` appears as a key in a map
 */  
  var member = Data_Function_Uncurried.runFn4($foreign._lookup)(false)(Data_Function["const"](true));

  /**
 *  | Apply a function of two arguments to each key/value pair, producing a new map
 */  
  var mapWithKey = function (f) {
      return function (m) {
          return $foreign._mapWithKey(m, f);
      };
  };

  /**
 *  | Lookup the value for a key in a map
 */  
  var lookup = Data_Function_Uncurried.runFn4($foreign._lookup)(Data_Maybe.Nothing.value)(Data_Maybe.Just.create);

  /**
 *  | Test whether one map contains all of the keys and values contained in another map
 */  
  var isSubmap = function (dictEq) {
      return function (m1) {
          return function (m2) {
              var f = function (k) {
                  return function (v) {
                      return $foreign._lookup(false, Data_Eq.eq(dictEq)(v), k, m2);
                  };
              };
              return $foreign.all(f)(m1);
          };
      };
  };

  /**
 *  | Test whether a map is empty
 */  
  var isEmpty = $foreign.all(function (v) {
      return function (v1) {
          return false;
      };
  });

  /**
 *  | Insert a key and value into a map
 */  
  var insert = function (k) {
      return function (v) {
          return mutate(function (s) {
              return Data_StrMap_ST.poke(s)(k)(v);
          });
      };
  };
  var functorStrMap = new Data_Functor.Functor(function (f) {
      return function (m) {
          return $foreign._fmapStrMap(m, f);
      };
  });

  /**
 *  | Create a map from a foldable collection of key/value pairs, using the
 *  | specified function to combine values for duplicate keys.
 */  
  var fromFoldableWith = function (dictFoldable) {
      return function (f) {
          return function (l) {
              return pureST(function __do() {
                  var v = Data_StrMap_ST["new"]();
                  Data_Foldable.for_(Control_Monad_Eff.applicativeEff)(dictFoldable)(l)(function (v1) {
                      return Control_Bind.bind(Control_Monad_Eff.bindEff)($foreign._lookupST(v1.value1, f(v1.value1), v1.value0, v))(Data_StrMap_ST.poke(v)(v1.value0));
                  })();
                  return v;
              });
          };
      };
  };

  /**
 *  | Create a map from a foldable collection of key/value pairs
 */  
  var fromFoldable = function (dictFoldable) {
      return function (l) {
          return pureST(function __do() {
              var v = Data_StrMap_ST["new"]();
              Data_Foldable.for_(Control_Monad_Eff.applicativeEff)(dictFoldable)(l)(function (v1) {
                  return Data_StrMap_ST.poke(v)(v1.value0)(v1.value1);
              })();
              return v;
          });
      };
  };

  /**
 *  | Convert a mutable map into an immutable map
 */  
  var freezeST = $foreign._copyEff;

  /**
 *  | Fold the keys and values of a map.
 *  |
 *  | This function allows the folding function to terminate the fold early,
 *  | using `Maybe`.
 */  
  var foldMaybe = function (f) {
      return function (z) {
          return function (m) {
              return $foreign._foldSCStrMap(m, z, f, Data_Maybe.fromMaybe);
          };
      };
  };

  /**
 *  | Fold the keys and values of a map, accumulating values and effects in
 *  | some `Monad`.
 */  
  var foldM = function (dictMonad) {
      return function (f) {
          return function (z) {
              return $foreign._foldM(Control_Bind.bind(dictMonad["__superclass_Control.Bind.Bind_1"]()))(f)(Control_Applicative.pure(dictMonad["__superclass_Control.Applicative.Applicative_0"]())(z));
          };
      };
  };
  var semigroupStrMap = function (dictSemigroup) {
      return new Data_Semigroup.Semigroup(function (m1) {
          return function (m2) {
              return mutate(function (s1) {
                  return foldM(Control_Monad_Eff.monadEff)(function (s2) {
                      return function (k) {
                          return function (v2) {
                              return Data_StrMap_ST.poke(s2)(k)($foreign._lookup(v2, function (v1) {
                                  return Data_Semigroup.append(dictSemigroup)(v1)(v2);
                              }, k, m2));
                          };
                      };
                  })(s1)(m1);
              })(m2);
          };
      });
  };
  var monoidStrMap = function (dictSemigroup) {
      return new Data_Monoid.Monoid(function () {
          return semigroupStrMap(dictSemigroup);
      }, $foreign.empty);
  };

  /**
 *  | Compute the union of two maps, preferring the first map in the case of
 *  | duplicate keys.
 */  
  var union = function (m) {
      return mutate(function (s) {
          return foldM(Control_Monad_Eff.monadEff)(Data_StrMap_ST.poke)(s)(m);
      });
  };

  /**
 *  | Compute the union of a collection of maps
 */  
  var unions = Data_Foldable.foldl(Data_List_Types.foldableList)(union)($foreign.empty);

  /**
 *  | Fold the keys and values of a map
 */  
  var fold = $foreign._foldM(Data_Function.applyFlipped);

  /**
 *  | Fold the keys and values of a map, accumulating values using
 *  | some `Monoid`.
 */  
  var foldMap = function (dictMonoid) {
      return function (f) {
          return fold(function (acc) {
              return function (k) {
                  return function (v) {
                      return Data_Semigroup.append(dictMonoid["__superclass_Data.Semigroup.Semigroup_0"]())(acc)(f(k)(v));
                  };
              };
          })(Data_Monoid.mempty(dictMonoid));
      };
  };
  var foldableStrMap = new Data_Foldable.Foldable(function (dictMonoid) {
      return function (f) {
          return foldMap(dictMonoid)(Data_Function["const"](f));
      };
  }, function (f) {
      return fold(function (z) {
          return function (v) {
              return f(z);
          };
      });
  }, function (f) {
      return function (z) {
          return function (m) {
              return Data_Foldable.foldr(Data_List_Types.foldableList)(f)(z)(values(m));
          };
      };
  });
  var traversableStrMap = new Data_Traversable.Traversable(function () {
      return foldableStrMap;
  }, function () {
      return functorStrMap;
  }, function (dictApplicative) {
      return Data_Traversable.traverse(traversableStrMap)(dictApplicative)(Control_Category.id(Control_Category.categoryFn));
  }, function (dictApplicative) {
      return function (f) {
          return function (ms) {
              return Data_Foldable.foldr(Data_List_Types.foldableList)(function (x) {
                  return function (acc) {
                      return Control_Apply.apply(dictApplicative["__superclass_Control.Apply.Apply_0"]())(Data_Functor.map((dictApplicative["__superclass_Control.Apply.Apply_0"]())["__superclass_Data.Functor.Functor_0"]())(union)(x))(acc);
                  };
              })(Control_Applicative.pure(dictApplicative)($foreign.empty))(Data_Functor.map(Data_List_Types.functorList)(Data_Functor.map((dictApplicative["__superclass_Control.Apply.Apply_0"]())["__superclass_Data.Functor.Functor_0"]())(Data_Tuple.uncurry(singleton)))(Data_Functor.map(Data_List_Types.functorList)(Data_Traversable.traverse(Data_Tuple.traversableTuple)(dictApplicative)(f))(toList(ms))));
          };
      };
  });
  var eqStrMap = function (dictEq) {
      return new Data_Eq.Eq(function (m1) {
          return function (m2) {
              return isSubmap(dictEq)(m1)(m2) && isSubmap(dictEq)(m2)(m1);
          };
      });
  };

  /**
 *  | Delete a key and value from a map
 */  
  var $$delete = function (k) {
      return mutate(function (s) {
          return Data_StrMap_ST["delete"](s)(k);
      });
  };

  /**
 *  | Delete a key and value from a map, returning the value
 *  | as well as the subsequent map
 */  
  var pop = function (k) {
      return function (m) {
          return Data_Functor.mapFlipped(Data_Maybe.functorMaybe)(lookup(k)(m))(function (a) {
              return new Data_Tuple.Tuple(a, $$delete(k)(m));
          });
      };
  };

  /**
 *  | Insert, remove or update a value for a key in a map
 */  
  var alter = function (f) {
      return function (k) {
          return function (m) {
              var $37 = f(lookup(k)(m));
              if ($37 instanceof Data_Maybe.Nothing) {
                  return $$delete(k)(m);
              };
              if ($37 instanceof Data_Maybe.Just) {
                  return insert(k)($37.value0)(m);
              };
              throw new Error("Failed pattern match at Data.StrMap line 186, column 15 - line 188, column 25: " + [ $37.constructor.name ]);
          };
      };
  };

  /**
 *  | Remove or update a value for a key in a map
 */  
  var update = function (f) {
      return function (k) {
          return function (m) {
              return alter(Data_Maybe.maybe(Data_Maybe.Nothing.value)(f))(k)(m);
          };
      };
  };
  exports["alter"] = alter;
  exports["delete"] = $$delete;
  exports["fold"] = fold;
  exports["foldM"] = foldM;
  exports["foldMap"] = foldMap;
  exports["foldMaybe"] = foldMaybe;
  exports["freezeST"] = freezeST;
  exports["fromFoldable"] = fromFoldable;
  exports["fromFoldableWith"] = fromFoldableWith;
  exports["insert"] = insert;
  exports["isEmpty"] = isEmpty;
  exports["isSubmap"] = isSubmap;
  exports["lookup"] = lookup;
  exports["mapWithKey"] = mapWithKey;
  exports["member"] = member;
  exports["pop"] = pop;
  exports["pureST"] = pureST;
  exports["singleton"] = singleton;
  exports["thawST"] = thawST;
  exports["toList"] = toList;
  exports["toUnfoldable"] = toUnfoldable;
  exports["union"] = union;
  exports["unions"] = unions;
  exports["update"] = update;
  exports["values"] = values;
  exports["functorStrMap"] = functorStrMap;
  exports["foldableStrMap"] = foldableStrMap;
  exports["traversableStrMap"] = traversableStrMap;
  exports["eqStrMap"] = eqStrMap;
  exports["showStrMap"] = showStrMap;
  exports["semigroupStrMap"] = semigroupStrMap;
  exports["monoidStrMap"] = monoidStrMap;
  exports["all"] = $foreign.all;
  exports["empty"] = $foreign.empty;
  exports["keys"] = $foreign.keys;
  exports["runST"] = $foreign.runST;
  exports["size"] = $foreign.size;
})(PS["Data.StrMap"] = PS["Data.StrMap"] || {});
(function(exports) {
  /* global exports */
  "use strict";

  // module Data.StrMap.ST.Unsafe

  exports.unsafeGet = function (m) {
    return function () {
      return m;
    };
  };
})(PS["Data.StrMap.ST.Unsafe"] = PS["Data.StrMap.ST.Unsafe"] || {});
(function(exports) {
    "use strict";
  var $foreign = PS["Data.StrMap.ST.Unsafe"];
  var Control_Monad_Eff = PS["Control.Monad.Eff"];
  var Control_Monad_ST = PS["Control.Monad.ST"];
  var Data_StrMap = PS["Data.StrMap"];
  var Data_StrMap_ST = PS["Data.StrMap.ST"];
  exports["unsafeGet"] = $foreign.unsafeGet;
})(PS["Data.StrMap.ST.Unsafe"] = PS["Data.StrMap.ST.Unsafe"] || {});
(function(exports) {
  /* global exports */
  "use strict";

  // module Data.StrMap.Unsafe

  exports.unsafeIndex = function (m) {
    return function (k) {
      return m[k];
    };
  };
})(PS["Data.StrMap.Unsafe"] = PS["Data.StrMap.Unsafe"] || {});
(function(exports) {
    "use strict";
  var $foreign = PS["Data.StrMap.Unsafe"];
  var Data_StrMap = PS["Data.StrMap"];
  exports["unsafeIndex"] = $foreign.unsafeIndex;
})(PS["Data.StrMap.Unsafe"] = PS["Data.StrMap.Unsafe"] || {});
(function(exports) {
    "use strict";
  var Prelude = PS["Prelude"];
  var Data_Newtype = PS["Data.Newtype"];
  var Data_String = PS["Data.String"];
  var Data_Eq = PS["Data.Eq"];
  var Data_Ord = PS["Data.Ord"];
  var Data_Show = PS["Data.Show"];
  var Data_Semigroup = PS["Data.Semigroup"];        

  /**
 *  | A newtype for case insensitive string comparisons and ordering.
 */  
  var CaseInsensitiveString = function (x) {
      return x;
  };
  var showCaseInsensitiveString = new Data_Show.Show(function (v) {
      return "(CaseInsensitiveString " + (v + ")");
  });
  var newtypeCaseInsensitiveString = new Data_Newtype.Newtype(function (n) {
      return n;
  }, CaseInsensitiveString);
  var eqCaseInsensitiveString = new Data_Eq.Eq(function (v) {
      return function (v1) {
          return Data_String.toLower(v) === Data_String.toLower(v1);
      };
  });
  var ordCaseInsensitiveString = new Data_Ord.Ord(function () {
      return eqCaseInsensitiveString;
  }, function (v) {
      return function (v1) {
          return Data_Ord.compare(Data_Ord.ordString)(Data_String.toLower(v))(Data_String.toLower(v1));
      };
  });
  exports["CaseInsensitiveString"] = CaseInsensitiveString;
  exports["eqCaseInsensitiveString"] = eqCaseInsensitiveString;
  exports["ordCaseInsensitiveString"] = ordCaseInsensitiveString;
  exports["showCaseInsensitiveString"] = showCaseInsensitiveString;
  exports["newtypeCaseInsensitiveString"] = newtypeCaseInsensitiveString;
})(PS["Data.String.CaseInsensitive"] = PS["Data.String.CaseInsensitive"] || {});
(function(exports) {
    "use strict";

  exports["showRegex'"] = function (r) {
    return "" + r;
  };

  exports["regex'"] = function (left) {
    return function (right) {
      return function (s1) {
        return function (s2) {
          try {
            return right(new RegExp(s1, s2));
          } catch (e) {
            return left(e.message);
          }
        };
      };
    };
  };

  exports.source = function (r) {
    return r.source;
  };

  exports["flags'"] = function (r) {
    return {
      multiline: r.multiline,
      ignoreCase: r.ignoreCase,
      global: r.global,
      sticky: !!r.sticky,
      unicode: !!r.unicode
    };
  };

  exports.test = function (r) {
    return function (s) {
      var lastIndex = r.lastIndex;
      var result = r.test(s);
      r.lastIndex = lastIndex;
      return result;
    };
  };

  exports._match = function (just) {
    return function (nothing) {
      return function (r) {
        return function (s) {
          var m = s.match(r);
          if (m == null) {
            return nothing;
          } else {
            var list = [];
            for (var i = 0; i < m.length; i++) {
              list.push(m[i] == null ? nothing : just(m[i]));
            }
            return just(list);
          }
        };
      };
    };
  };

  exports.replace = function (r) {
    return function (s1) {
      return function (s2) {
        return s2.replace(r, s1);
      };
    };
  };

  exports["replace'"] = function (r) {
    return function (f) {
      return function (s2) {
        return s2.replace(r, function (match) {
          return f(match)(Array.prototype.splice.call(arguments, 1, arguments.length - 3));
        });
      };
    };
  };

  exports._search = function (just) {
    return function (nothing) {
      return function (r) {
        return function (s) {
          var result = s.search(r);
          return result === -1 ? nothing : just(result);
        };
      };
    };
  };

  exports.split = function (r) {
    return function (s) {
      return s.split(r);
    };
  };
})(PS["Data.String.Regex"] = PS["Data.String.Regex"] || {});
(function(exports) {
    "use strict";
  var Prelude = PS["Prelude"];
  var Control_MonadPlus = PS["Control.MonadPlus"];
  var Data_Monoid = PS["Data.Monoid"];
  var Data_String = PS["Data.String"];
  var Data_Semigroup = PS["Data.Semigroup"];
  var Data_HeytingAlgebra = PS["Data.HeytingAlgebra"];
  var Data_Eq = PS["Data.Eq"];
  var Data_Show = PS["Data.Show"];
  var Data_Functor = PS["Data.Functor"];
  var Control_MonadZero = PS["Control.MonadZero"];        

  /**
 *  | Flags that control matching.
 */  
  var RegexFlags = (function () {
      function RegexFlags(value0) {
          this.value0 = value0;
      };
      RegexFlags.create = function (value0) {
          return new RegexFlags(value0);
      };
      return RegexFlags;
  })();

  /**
 *  | Only unicode flag set to true
 */  
  var unicode = new RegexFlags({
      global: false, 
      ignoreCase: false, 
      multiline: false, 
      sticky: false, 
      unicode: true
  });

  /**
 *  | Only sticky flag set to true
 */  
  var sticky = new RegexFlags({
      global: false, 
      ignoreCase: false, 
      multiline: false, 
      sticky: true, 
      unicode: false
  });
  var showRegexFlags = new Data_Show.Show(function (v) {
      var usedFlags = Data_Semigroup.append(Data_Semigroup.semigroupArray)([  ])(Data_Semigroup.append(Data_Semigroup.semigroupArray)(Data_Functor.voidLeft(Data_Functor.functorArray)(Control_MonadZero.guard(Control_MonadZero.monadZeroArray)(v.value0.global))("global"))(Data_Semigroup.append(Data_Semigroup.semigroupArray)(Data_Functor.voidLeft(Data_Functor.functorArray)(Control_MonadZero.guard(Control_MonadZero.monadZeroArray)(v.value0.ignoreCase))("ignoreCase"))(Data_Semigroup.append(Data_Semigroup.semigroupArray)(Data_Functor.voidLeft(Data_Functor.functorArray)(Control_MonadZero.guard(Control_MonadZero.monadZeroArray)(v.value0.multiline))("multiline"))(Data_Semigroup.append(Data_Semigroup.semigroupArray)(Data_Functor.voidLeft(Data_Functor.functorArray)(Control_MonadZero.guard(Control_MonadZero.monadZeroArray)(v.value0.sticky))("sticky"))(Data_Functor.voidLeft(Data_Functor.functorArray)(Control_MonadZero.guard(Control_MonadZero.monadZeroArray)(v.value0.unicode))("unicode"))))));
      var $6 = Data_Eq.eq(Data_Eq.eqArray(Data_Eq.eqString))(usedFlags)([  ]);
      if ($6) {
          return "noFlags";
      };
      if (!$6) {
          return "(" + (Data_String.joinWith(" <> ")(usedFlags) + ")");
      };
      throw new Error("Failed pattern match at Data.String.Regex.Flags line 112, column 7 - line 114, column 48: " + [ $6.constructor.name ]);
  });
  var semigroupRegexFlags = new Data_Semigroup.Semigroup(function (v) {
      return function (v1) {
          return new RegexFlags({
              global: v.value0.global || v1.value0.global, 
              ignoreCase: v.value0.ignoreCase || v1.value0.ignoreCase, 
              multiline: v.value0.multiline || v1.value0.multiline, 
              sticky: v.value0.sticky || v1.value0.sticky, 
              unicode: v.value0.unicode || v1.value0.unicode
          });
      };
  });

  /**
 *  | All flags set to false.
 */  
  var noFlags = new RegexFlags({
      global: false, 
      ignoreCase: false, 
      multiline: false, 
      sticky: false, 
      unicode: false
  });

  /**
 *  | Only multiline flag set to true
 */  
  var multiline = new RegexFlags({
      global: false, 
      ignoreCase: false, 
      multiline: true, 
      sticky: false, 
      unicode: false
  });
  var monoidRegexFlags = new Data_Monoid.Monoid(function () {
      return semigroupRegexFlags;
  }, noFlags);

  /**
 *  | Only ignoreCase flag set to true
 */  
  var ignoreCase = new RegexFlags({
      global: false, 
      ignoreCase: true, 
      multiline: false, 
      sticky: false, 
      unicode: false
  });

  /**
 *  | Only global flag set to true
 */  
  var global = new RegexFlags({
      global: true, 
      ignoreCase: false, 
      multiline: false, 
      sticky: false, 
      unicode: false
  });
  var eqRegexFlags = new Data_Eq.Eq(function (v) {
      return function (v1) {
          return v.value0.global === v1.value0.global && (v.value0.ignoreCase === v1.value0.ignoreCase && (v.value0.multiline === v1.value0.multiline && (v.value0.sticky === v1.value0.sticky && v.value0.unicode === v1.value0.unicode)));
      };
  });
  exports["RegexFlags"] = RegexFlags;
  exports["global"] = global;
  exports["ignoreCase"] = ignoreCase;
  exports["multiline"] = multiline;
  exports["noFlags"] = noFlags;
  exports["sticky"] = sticky;
  exports["unicode"] = unicode;
  exports["semigroupRegexFlags"] = semigroupRegexFlags;
  exports["monoidRegexFlags"] = monoidRegexFlags;
  exports["eqRegexFlags"] = eqRegexFlags;
  exports["showRegexFlags"] = showRegexFlags;
})(PS["Data.String.Regex.Flags"] = PS["Data.String.Regex.Flags"] || {});
(function(exports) {
  
  /**
 *  | Wraps Javascript's `RegExp` object that enables matching strings with
 *  | patternes defined by regular expressions.
 *  | For details of the underlying implementation, see [RegExp Reference at MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RegExp).
 */  
  "use strict";
  var $foreign = PS["Data.String.Regex"];
  var Prelude = PS["Prelude"];
  var Data_Either = PS["Data.Either"];
  var Data_Maybe = PS["Data.Maybe"];
  var Data_String = PS["Data.String"];
  var Data_String_Regex_Flags = PS["Data.String.Regex.Flags"];
  var Data_Show = PS["Data.Show"];
  var Data_Semigroup = PS["Data.Semigroup"];
  var Data_Function = PS["Data.Function"];
  var Control_Semigroupoid = PS["Control.Semigroupoid"];        
  var showRegex = new Data_Show.Show($foreign["showRegex'"]);

  /**
 *  | Returns `Just` the index of the first match of the `Regex` in the string,
 *  | or `Nothing` if there is no match.
 */  
  var search = $foreign._search(Data_Maybe.Just.create)(Data_Maybe.Nothing.value);

  /**
 *  | Returns the string representation of the given `RegexFlags`.
 */  
  var renderFlags = function (v) {
      return (function () {
          if (v.value0.global) {
              return "g";
          };
          if (!v.value0.global) {
              return "";
          };
          throw new Error("Failed pattern match at Data.String.Regex line 59, column 4 - line 59, column 32: " + [ v.value0.global.constructor.name ]);
      })() + ((function () {
          if (v.value0.ignoreCase) {
              return "i";
          };
          if (!v.value0.ignoreCase) {
              return "";
          };
          throw new Error("Failed pattern match at Data.String.Regex line 60, column 4 - line 60, column 36: " + [ v.value0.ignoreCase.constructor.name ]);
      })() + ((function () {
          if (v.value0.multiline) {
              return "m";
          };
          if (!v.value0.multiline) {
              return "";
          };
          throw new Error("Failed pattern match at Data.String.Regex line 61, column 4 - line 61, column 35: " + [ v.value0.multiline.constructor.name ]);
      })() + ((function () {
          if (v.value0.sticky) {
              return "y";
          };
          if (!v.value0.sticky) {
              return "";
          };
          throw new Error("Failed pattern match at Data.String.Regex line 62, column 4 - line 62, column 32: " + [ v.value0.sticky.constructor.name ]);
      })() + (function () {
          if (v.value0.unicode) {
              return "u";
          };
          if (!v.value0.unicode) {
              return "";
          };
          throw new Error("Failed pattern match at Data.String.Regex line 63, column 4 - line 63, column 33: " + [ v.value0.unicode.constructor.name ]);
      })())));
  };

  /**
 *  | Constructs a `Regex` from a pattern string and flags. Fails with
 *  | `Left error` if the pattern contains a syntax error.
 */  
  var regex = function (s) {
      return function (f) {
          return $foreign["regex'"](Data_Either.Left.create)(Data_Either.Right.create)(s)(renderFlags(f));
      };
  };

  /**
 *  | Parses the string representation of `RegexFlags`.
 */  
  var parseFlags = function (s) {
      return new Data_String_Regex_Flags.RegexFlags({
          global: Data_String.contains("g")(s), 
          ignoreCase: Data_String.contains("i")(s), 
          multiline: Data_String.contains("m")(s), 
          sticky: Data_String.contains("y")(s), 
          unicode: Data_String.contains("u")(s)
      });
  };

  /**
 *  | Matches the string against the `Regex` and returns an array of matches
 *  | if there were any. Each match has type `Maybe String`, where `Nothing`
 *  | represents an unmatched optional capturing group.
 *  | See [reference](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/match).
 */  
  var match = $foreign._match(Data_Maybe.Just.create)(Data_Maybe.Nothing.value);

  /**
 *  | Returns the `RegexFlags` used to construct the given `Regex`.
 */  
  var flags = function ($8) {
      return Data_String_Regex_Flags.RegexFlags.create($foreign["flags'"]($8));
  };
  exports["flags"] = flags;
  exports["match"] = match;
  exports["parseFlags"] = parseFlags;
  exports["regex"] = regex;
  exports["renderFlags"] = renderFlags;
  exports["search"] = search;
  exports["showRegex"] = showRegex;
  exports["replace"] = $foreign.replace;
  exports["replace'"] = $foreign["replace'"];
  exports["source"] = $foreign.source;
  exports["split"] = $foreign.split;
  exports["test"] = $foreign.test;
})(PS["Data.String.Regex"] = PS["Data.String.Regex"] || {});
(function(exports) {
  
  /**
 *  | Utilities for n-tuples: sequences longer than two components built from
 *  | nested pairs.
 *  |
 *  | Nested tuples arise naturally in product combinators. You shouldn't
 *  | represent data using nested tuples, but if combinators you're working with
 *  | create them, utilities in this module will allow to to more easily work
 *  | with them, including translating to and from more traditional product types.
 *  |
 *  | ```purescript
 *  | data Address = Address String City (Maybe Province) Country
 *  |
 *  | exampleAddress1 = makeAddress "221B Baker Street" London Nothing UK
 *  | exampleAddress2 = makeAddressT $ "221B Baker Street" /\ London /\ Nothing /\ UK
 *  |
 *  | makeAddressT :: Tuple4 String City (Maybe Province) Country -> Address
 *  | makeAddressT = uncurry4 Address
 *  |
 *  | makeAddress :: String -> City -> (Maybe Province) -> Country -> Address
 *  | makeAddress = curry4 makeAddressT
 *  |
 *  | tupleAddress :: Address -> Tuple4 String City (Maybe Province) Country
 *  | tupleAddress (Address a b c d) = tuple4 a b c d
 *  | ```
 */  
  "use strict";
  var Data_Tuple = PS["Data.Tuple"];        

  /**
 *  | Given a function of 9 arguments, return a function that accepts a 9-tuple.
 */  
  var uncurry9 = function (f$prime) {
      return function (v) {
          return f$prime(v.value0)(v.value1.value0)(v.value1.value1.value0)(v.value1.value1.value1.value0)(v.value1.value1.value1.value1.value0)(v.value1.value1.value1.value1.value1.value0)(v.value1.value1.value1.value1.value1.value1.value0)(v.value1.value1.value1.value1.value1.value1.value1.value0)(v.value1.value1.value1.value1.value1.value1.value1.value1);
      };
  };

  /**
 *  | Given a function of 8 arguments, return a function that accepts a 8-tuple.
 */  
  var uncurry8 = function (f$prime) {
      return function (v) {
          return f$prime(v.value0)(v.value1.value0)(v.value1.value1.value0)(v.value1.value1.value1.value0)(v.value1.value1.value1.value1.value0)(v.value1.value1.value1.value1.value1.value0)(v.value1.value1.value1.value1.value1.value1.value0)(v.value1.value1.value1.value1.value1.value1.value1);
      };
  };

  /**
 *  | Given a function of 7 arguments, return a function that accepts a 7-tuple.
 */  
  var uncurry7 = function (f$prime) {
      return function (v) {
          return f$prime(v.value0)(v.value1.value0)(v.value1.value1.value0)(v.value1.value1.value1.value0)(v.value1.value1.value1.value1.value0)(v.value1.value1.value1.value1.value1.value0)(v.value1.value1.value1.value1.value1.value1);
      };
  };

  /**
 *  | Given a function of 6 arguments, return a function that accepts a 6-tuple.
 */  
  var uncurry6 = function (f$prime) {
      return function (v) {
          return f$prime(v.value0)(v.value1.value0)(v.value1.value1.value0)(v.value1.value1.value1.value0)(v.value1.value1.value1.value1.value0)(v.value1.value1.value1.value1.value1);
      };
  };

  /**
 *  | Given a function of 5 arguments, return a function that accepts a 5-tuple.
 */  
  var uncurry5 = function (f) {
      return function (v) {
          return f(v.value0)(v.value1.value0)(v.value1.value1.value0)(v.value1.value1.value1.value0)(v.value1.value1.value1.value1);
      };
  };

  /**
 *  | Given a function of 4 arguments, return a function that accepts a 4-tuple.
 */  
  var uncurry4 = function (f) {
      return function (v) {
          return f(v.value0)(v.value1.value0)(v.value1.value1.value0)(v.value1.value1.value1);
      };
  };

  /**
 *  | Given a function of 3 arguments, return a function that accepts a 3-tuple.
 */  
  var uncurry3 = function (f) {
      return function (v) {
          return f(v.value0)(v.value1.value0)(v.value1.value1);
      };
  };

  /**
 *  | Given a function of 2 arguments, return a function that accepts a 2-tuple.
 */  
  var uncurry2 = function (f) {
      return function (v) {
          return f(v.value0)(v.value1);
      };
  };

  /**
 *  | Given a function of 10 arguments, return a function that accepts a 10-tuple.
 */  
  var uncurry10 = function (f$prime) {
      return function (v) {
          return f$prime(v.value0)(v.value1.value0)(v.value1.value1.value0)(v.value1.value1.value1.value0)(v.value1.value1.value1.value1.value0)(v.value1.value1.value1.value1.value1.value0)(v.value1.value1.value1.value1.value1.value1.value0)(v.value1.value1.value1.value1.value1.value1.value1.value0)(v.value1.value1.value1.value1.value1.value1.value1.value1.value0)(v.value1.value1.value1.value1.value1.value1.value1.value1.value1);
      };
  };

  /**
 *  | Given 9 values, creates a nested 9-tuple.
 */  
  var tuple9 = function (a) {
      return function (b) {
          return function (c) {
              return function (d) {
                  return function (e) {
                      return function (f) {
                          return function (g) {
                              return function (h) {
                                  return function (i) {
                                      return new Data_Tuple.Tuple(a, new Data_Tuple.Tuple(b, new Data_Tuple.Tuple(c, new Data_Tuple.Tuple(d, new Data_Tuple.Tuple(e, new Data_Tuple.Tuple(f, new Data_Tuple.Tuple(g, new Data_Tuple.Tuple(h, i))))))));
                                  };
                              };
                          };
                      };
                  };
              };
          };
      };
  };

  /**
 *  | Given 8 values, creates a nested 8-tuple.
 */  
  var tuple8 = function (a) {
      return function (b) {
          return function (c) {
              return function (d) {
                  return function (e) {
                      return function (f) {
                          return function (g) {
                              return function (h) {
                                  return new Data_Tuple.Tuple(a, new Data_Tuple.Tuple(b, new Data_Tuple.Tuple(c, new Data_Tuple.Tuple(d, new Data_Tuple.Tuple(e, new Data_Tuple.Tuple(f, new Data_Tuple.Tuple(g, h)))))));
                              };
                          };
                      };
                  };
              };
          };
      };
  };

  /**
 *  | Given 7 values, creates a nested 7-tuple.
 */  
  var tuple7 = function (a) {
      return function (b) {
          return function (c) {
              return function (d) {
                  return function (e) {
                      return function (f) {
                          return function (g) {
                              return new Data_Tuple.Tuple(a, new Data_Tuple.Tuple(b, new Data_Tuple.Tuple(c, new Data_Tuple.Tuple(d, new Data_Tuple.Tuple(e, new Data_Tuple.Tuple(f, g))))));
                          };
                      };
                  };
              };
          };
      };
  };

  /**
 *  | Given 6 values, creates a nested 6-tuple.
 */  
  var tuple6 = function (a) {
      return function (b) {
          return function (c) {
              return function (d) {
                  return function (e) {
                      return function (f) {
                          return new Data_Tuple.Tuple(a, new Data_Tuple.Tuple(b, new Data_Tuple.Tuple(c, new Data_Tuple.Tuple(d, new Data_Tuple.Tuple(e, f)))));
                      };
                  };
              };
          };
      };
  };

  /**
 *  | Given 5 values, creates a nested 5-tuple.
 */  
  var tuple5 = function (a) {
      return function (b) {
          return function (c) {
              return function (d) {
                  return function (e) {
                      return new Data_Tuple.Tuple(a, new Data_Tuple.Tuple(b, new Data_Tuple.Tuple(c, new Data_Tuple.Tuple(d, e))));
                  };
              };
          };
      };
  };

  /**
 *  | Given 4 values, creates a nested 4-tuple.
 */  
  var tuple4 = function (a) {
      return function (b) {
          return function (c) {
              return function (d) {
                  return new Data_Tuple.Tuple(a, new Data_Tuple.Tuple(b, new Data_Tuple.Tuple(c, d)));
              };
          };
      };
  };

  /**
 *  | Given 3 values, creates a nested 3-tuple.
 */  
  var tuple3 = function (a) {
      return function (b) {
          return function (c) {
              return new Data_Tuple.Tuple(a, new Data_Tuple.Tuple(b, c));
          };
      };
  };

  /**
 *  | Given 2 values, creates a 2-tuple.
 */  
  var tuple2 = Data_Tuple.Tuple.create;

  /**
 *  | Given 10 values, creates a nested 10-tuple.
 */  
  var tuple10 = function (a) {
      return function (b) {
          return function (c) {
              return function (d) {
                  return function (e) {
                      return function (f) {
                          return function (g) {
                              return function (h) {
                                  return function (i) {
                                      return function (j) {
                                          return new Data_Tuple.Tuple(a, new Data_Tuple.Tuple(b, new Data_Tuple.Tuple(c, new Data_Tuple.Tuple(d, new Data_Tuple.Tuple(e, new Data_Tuple.Tuple(f, new Data_Tuple.Tuple(g, new Data_Tuple.Tuple(h, new Data_Tuple.Tuple(i, j)))))))));
                                      };
                                  };
                              };
                          };
                      };
                  };
              };
          };
      };
  };

  /**
 *  | Given a function that accepts a 9-tuple, return a function of 9 arguments.
 */  
  var curry9 = function (f$prime) {
      return function (a) {
          return function (b) {
              return function (c) {
                  return function (d) {
                      return function (e) {
                          return function (f) {
                              return function (g) {
                                  return function (h) {
                                      return function (i) {
                                          return f$prime(new Data_Tuple.Tuple(a, new Data_Tuple.Tuple(b, new Data_Tuple.Tuple(c, new Data_Tuple.Tuple(d, new Data_Tuple.Tuple(e, new Data_Tuple.Tuple(f, new Data_Tuple.Tuple(g, new Data_Tuple.Tuple(h, i)))))))));
                                      };
                                  };
                              };
                          };
                      };
                  };
              };
          };
      };
  };

  /**
 *  | Given a function that accepts a 8-tuple, return a function of 8 arguments.
 */  
  var curry8 = function (f$prime) {
      return function (a) {
          return function (b) {
              return function (c) {
                  return function (d) {
                      return function (e) {
                          return function (f) {
                              return function (g) {
                                  return function (h) {
                                      return f$prime(new Data_Tuple.Tuple(a, new Data_Tuple.Tuple(b, new Data_Tuple.Tuple(c, new Data_Tuple.Tuple(d, new Data_Tuple.Tuple(e, new Data_Tuple.Tuple(f, new Data_Tuple.Tuple(g, h))))))));
                                  };
                              };
                          };
                      };
                  };
              };
          };
      };
  };

  /**
 *  | Given a function that accepts a 7-tuple, return a function of 7 arguments.
 */  
  var curry7 = function (f$prime) {
      return function (a) {
          return function (b) {
              return function (c) {
                  return function (d) {
                      return function (e) {
                          return function (f) {
                              return function (g) {
                                  return f$prime(new Data_Tuple.Tuple(a, new Data_Tuple.Tuple(b, new Data_Tuple.Tuple(c, new Data_Tuple.Tuple(d, new Data_Tuple.Tuple(e, new Data_Tuple.Tuple(f, g)))))));
                              };
                          };
                      };
                  };
              };
          };
      };
  };

  /**
 *  | Given a function that accepts a 6-tuple, return a function of 6 arguments.
 */  
  var curry6 = function (f$prime) {
      return function (a) {
          return function (b) {
              return function (c) {
                  return function (d) {
                      return function (e) {
                          return function (f) {
                              return f$prime(new Data_Tuple.Tuple(a, new Data_Tuple.Tuple(b, new Data_Tuple.Tuple(c, new Data_Tuple.Tuple(d, new Data_Tuple.Tuple(e, f))))));
                          };
                      };
                  };
              };
          };
      };
  };

  /**
 *  | Given a function that accepts a 5-tuple, return a function of 5 arguments.
 */  
  var curry5 = function (f) {
      return function (a) {
          return function (b) {
              return function (c) {
                  return function (d) {
                      return function (e) {
                          return f(new Data_Tuple.Tuple(a, new Data_Tuple.Tuple(b, new Data_Tuple.Tuple(c, new Data_Tuple.Tuple(d, e)))));
                      };
                  };
              };
          };
      };
  };

  /**
 *  | Given a function that accepts a 4-tuple, return a function of 4 arguments.
 */  
  var curry4 = function (f) {
      return function (a) {
          return function (b) {
              return function (c) {
                  return function (d) {
                      return f(new Data_Tuple.Tuple(a, new Data_Tuple.Tuple(b, new Data_Tuple.Tuple(c, d))));
                  };
              };
          };
      };
  };

  /**
 *  | Given a function that accepts a 3-tuple, return a function of 3 arguments.
 */  
  var curry3 = function (f) {
      return function (a) {
          return function (b) {
              return function (c) {
                  return f(new Data_Tuple.Tuple(a, new Data_Tuple.Tuple(b, c)));
              };
          };
      };
  };

  /**
 *  | Given a function that accepts a 2-tuple, return a function of 2 arguments.
 */  
  var curry2 = function (f) {
      return function (a) {
          return function (b) {
              return f(new Data_Tuple.Tuple(a, b));
          };
      };
  };

  /**
 *  | Given a function that accepts a 10-tuple, return a function of 10 arguments.
 */  
  var curry10 = function (f$prime) {
      return function (a) {
          return function (b) {
              return function (c) {
                  return function (d) {
                      return function (e) {
                          return function (f) {
                              return function (g) {
                                  return function (h) {
                                      return function (i) {
                                          return function (j) {
                                              return f$prime(new Data_Tuple.Tuple(a, new Data_Tuple.Tuple(b, new Data_Tuple.Tuple(c, new Data_Tuple.Tuple(d, new Data_Tuple.Tuple(e, new Data_Tuple.Tuple(f, new Data_Tuple.Tuple(g, new Data_Tuple.Tuple(h, new Data_Tuple.Tuple(i, j))))))))));
                                          };
                                      };
                                  };
                              };
                          };
                      };
                  };
              };
          };
      };
  };
  exports["curry10"] = curry10;
  exports["curry2"] = curry2;
  exports["curry3"] = curry3;
  exports["curry4"] = curry4;
  exports["curry5"] = curry5;
  exports["curry6"] = curry6;
  exports["curry7"] = curry7;
  exports["curry8"] = curry8;
  exports["curry9"] = curry9;
  exports["tuple10"] = tuple10;
  exports["tuple2"] = tuple2;
  exports["tuple3"] = tuple3;
  exports["tuple4"] = tuple4;
  exports["tuple5"] = tuple5;
  exports["tuple6"] = tuple6;
  exports["tuple7"] = tuple7;
  exports["tuple8"] = tuple8;
  exports["tuple9"] = tuple9;
  exports["uncurry10"] = uncurry10;
  exports["uncurry2"] = uncurry2;
  exports["uncurry3"] = uncurry3;
  exports["uncurry4"] = uncurry4;
  exports["uncurry5"] = uncurry5;
  exports["uncurry6"] = uncurry6;
  exports["uncurry7"] = uncurry7;
  exports["uncurry8"] = uncurry8;
  exports["uncurry9"] = uncurry9;
})(PS["Data.Tuple.Nested"] = PS["Data.Tuple.Nested"] || {});
(function(exports) {
  
  /**
 *  | This module defines an applicative functor for _applicative validation_.
 *  |
 *  | Applicative validation differs from monadic validation using `Either` in
 *  | that it allows us to collect multiple errors using a `Semigroup`, whereas
 *  | `Either` terminates on the first error.
 */  
  "use strict";
  var Prelude = PS["Prelude"];
  var Data_Bifunctor = PS["Data.Bifunctor"];
  var Data_Eq = PS["Data.Eq"];
  var Data_Ord = PS["Data.Ord"];
  var Data_Ordering = PS["Data.Ordering"];
  var Data_Show = PS["Data.Show"];
  var Data_Semigroup = PS["Data.Semigroup"];
  var Data_Functor = PS["Data.Functor"];
  var Control_Apply = PS["Control.Apply"];
  var Control_Applicative = PS["Control.Applicative"];        

  /**
 *  | The `V` functor, used for applicative validation
 *  |
 *  | The `Applicative` instance collects multiple failures in
 *  | an arbitrary `Semigroup`.
 *  |
 *  | For example:
 *  |
 *  | ```purescript
 *  | validate :: Person -> V (Array Error) Person
 *  | validate person = { first: _, last: _, email: _ }
 *  |   <$> validateName person.first
 *  |   <*> validateName person.last
 *  |   <*> validateEmail person.email
 *  | ```
 */  
  var Invalid = (function () {
      function Invalid(value0) {
          this.value0 = value0;
      };
      Invalid.create = function (value0) {
          return new Invalid(value0);
      };
      return Invalid;
  })();

  /**
 *  | The `V` functor, used for applicative validation
 *  |
 *  | The `Applicative` instance collects multiple failures in
 *  | an arbitrary `Semigroup`.
 *  |
 *  | For example:
 *  |
 *  | ```purescript
 *  | validate :: Person -> V (Array Error) Person
 *  | validate person = { first: _, last: _, email: _ }
 *  |   <$> validateName person.first
 *  |   <*> validateName person.last
 *  |   <*> validateEmail person.email
 *  | ```
 */  
  var Valid = (function () {
      function Valid(value0) {
          this.value0 = value0;
      };
      Valid.create = function (value0) {
          return new Valid(value0);
      };
      return Valid;
  })();

  /**
 *  | Unpack the `V` type constructor, providing functions to handle the error
 *  | and success cases.
 */  
  var unV = function (v) {
      return function (v1) {
          return function (v2) {
              if (v2 instanceof Invalid) {
                  return v(v2.value0);
              };
              if (v2 instanceof Valid) {
                  return v1(v2.value0);
              };
              throw new Error("Failed pattern match at Data.Validation.Semigroup line 37, column 1 - line 37, column 30: " + [ v.constructor.name, v1.constructor.name, v2.constructor.name ]);
          };
      };
  };
  var showV = function (dictShow) {
      return function (dictShow1) {
          return new Data_Show.Show(function (v) {
              if (v instanceof Invalid) {
                  return "(Invalid " + (Data_Show.show(dictShow)(v.value0) + ")");
              };
              if (v instanceof Valid) {
                  return "(Valid " + (Data_Show.show(dictShow1)(v.value0) + ")");
              };
              throw new Error("Failed pattern match at Data.Validation.Semigroup line 54, column 3 - line 55, column 3: " + [ v.constructor.name ]);
          });
      };
  };

  /**
 *  | Test whether validation was successful or not
 */  
  var isValid = function (v) {
      if (v instanceof Valid) {
          return true;
      };
      return false;
  };

  /**
 *  | Fail with a validation error
 */  
  var invalid = Invalid.create;
  var functorV = new Data_Functor.Functor(function (v) {
      return function (v1) {
          if (v1 instanceof Invalid) {
              return new Invalid(v1.value0);
          };
          if (v1 instanceof Valid) {
              return new Valid(v(v1.value0));
          };
          throw new Error("Failed pattern match at Data.Validation.Semigroup line 58, column 3 - line 58, column 36: " + [ v.constructor.name, v1.constructor.name ]);
      };
  });
  var eqV = function (dictEq) {
      return function (dictEq1) {
          return new Data_Eq.Eq(function (x) {
              return function (y) {
                  if (x instanceof Invalid && y instanceof Invalid) {
                      return Data_Eq.eq(dictEq)(x.value0)(y.value0);
                  };
                  if (x instanceof Valid && y instanceof Valid) {
                      return Data_Eq.eq(dictEq1)(x.value0)(y.value0);
                  };
                  return false;
              };
          });
      };
  };
  var ordV = function (dictOrd) {
      return function (dictOrd1) {
          return new Data_Ord.Ord(function () {
              return eqV(dictOrd["__superclass_Data.Eq.Eq_0"]())(dictOrd1["__superclass_Data.Eq.Eq_0"]());
          }, function (x) {
              return function (y) {
                  if (x instanceof Invalid && y instanceof Invalid) {
                      return Data_Ord.compare(dictOrd)(x.value0)(y.value0);
                  };
                  if (x instanceof Invalid) {
                      return Data_Ordering.LT.value;
                  };
                  if (y instanceof Invalid) {
                      return Data_Ordering.GT.value;
                  };
                  if (x instanceof Valid && y instanceof Valid) {
                      return Data_Ord.compare(dictOrd1)(x.value0)(y.value0);
                  };
                  throw new Error("Failed pattern match at Data.Validation.Semigroup line 51, column 1 - line 51, column 68: " + [ x.constructor.name, y.constructor.name ]);
              };
          });
      };
  };
  var bifunctorV = new Data_Bifunctor.Bifunctor(function (v) {
      return function (v1) {
          return function (v2) {
              if (v2 instanceof Invalid) {
                  return new Invalid(v(v2.value0));
              };
              if (v2 instanceof Valid) {
                  return new Valid(v1(v2.value0));
              };
              throw new Error("Failed pattern match at Data.Validation.Semigroup line 62, column 3 - line 62, column 44: " + [ v.constructor.name, v1.constructor.name, v2.constructor.name ]);
          };
      };
  });
  var applyV = function (dictSemigroup) {
      return new Control_Apply.Apply(function () {
          return functorV;
      }, function (v) {
          return function (v1) {
              if (v instanceof Invalid && v1 instanceof Invalid) {
                  return new Invalid(Data_Semigroup.append(dictSemigroup)(v.value0)(v1.value0));
              };
              if (v instanceof Invalid) {
                  return new Invalid(v.value0);
              };
              if (v1 instanceof Invalid) {
                  return new Invalid(v1.value0);
              };
              if (v instanceof Valid && v1 instanceof Valid) {
                  return new Valid(v.value0(v1.value0));
              };
              throw new Error("Failed pattern match at Data.Validation.Semigroup line 66, column 3 - line 66, column 63: " + [ v.constructor.name, v1.constructor.name ]);
          };
      });
  };
  var applicativeV = function (dictSemigroup) {
      return new Control_Applicative.Applicative(function () {
          return applyV(dictSemigroup);
      }, Valid.create);
  };
  exports["invalid"] = invalid;
  exports["isValid"] = isValid;
  exports["unV"] = unV;
  exports["eqV"] = eqV;
  exports["ordV"] = ordV;
  exports["showV"] = showV;
  exports["functorV"] = functorV;
  exports["bifunctorV"] = bifunctorV;
  exports["applyV"] = applyV;
  exports["applicativeV"] = applicativeV;
})(PS["Data.Validation.Semigroup"] = PS["Data.Validation.Semigroup"] || {});
(function(exports) {
  
  /**
 *  | This module defines a variant of applicative validation with
 *  | an `Alternative` instance, for validators which support errors
 *  | with multiple alternatives.
 *  |
 *  | The API is equivalent to `Data.Validation`,
 *  | but uses `Semiring` instead of `Semigroup`.
 */  
  "use strict";
  var Prelude = PS["Prelude"];
  var Control_Alt = PS["Control.Alt"];
  var Control_Plus = PS["Control.Plus"];
  var Control_Alternative = PS["Control.Alternative"];
  var Data_Bifunctor = PS["Data.Bifunctor"];
  var Data_Eq = PS["Data.Eq"];
  var Data_Ord = PS["Data.Ord"];
  var Data_Ordering = PS["Data.Ordering"];
  var Data_Show = PS["Data.Show"];
  var Data_Semigroup = PS["Data.Semigroup"];
  var Data_Functor = PS["Data.Functor"];
  var Control_Apply = PS["Control.Apply"];
  var Data_Semiring = PS["Data.Semiring"];
  var Control_Applicative = PS["Control.Applicative"];        

  /**
 *  | The `V` functor, used for alternative validation
 *  |
 *  | The `Alternative` instance collects multiple failures in
 *  | an arbitrary `Semiring`.
 *  |
 *  | For example:
 *  |
 *  | ```purescript
 *  | import Data.Semiring.Free
 *  |
 *  | validate r :: Person -> V (Free Error) Person
 *  | validate person = { first: _, last: _, contact: _}
 *  |   <$> validateName person.first
 *  |   <*> validateName person.last
 *  |   <*> (validateEmail person.contact <|> validatePhone person.contact)
 *  | ```
 */  
  var Valid = (function () {
      function Valid(value0) {
          this.value0 = value0;
      };
      Valid.create = function (value0) {
          return new Valid(value0);
      };
      return Valid;
  })();

  /**
 *  | The `V` functor, used for alternative validation
 *  |
 *  | The `Alternative` instance collects multiple failures in
 *  | an arbitrary `Semiring`.
 *  |
 *  | For example:
 *  |
 *  | ```purescript
 *  | import Data.Semiring.Free
 *  |
 *  | validate r :: Person -> V (Free Error) Person
 *  | validate person = { first: _, last: _, contact: _}
 *  |   <$> validateName person.first
 *  |   <*> validateName person.last
 *  |   <*> (validateEmail person.contact <|> validatePhone person.contact)
 *  | ```
 */  
  var Invalid = (function () {
      function Invalid(value0) {
          this.value0 = value0;
      };
      Invalid.create = function (value0) {
          return new Invalid(value0);
      };
      return Invalid;
  })();

  /**
 *  | Unpack the `V` type constructor, providing functions to handle the error
 *  | and success cases.
 */  
  var unV = function (v) {
      return function (v1) {
          return function (v2) {
              if (v2 instanceof Invalid) {
                  return v(v2.value0);
              };
              if (v2 instanceof Valid) {
                  return v1(v2.value0);
              };
              throw new Error("Failed pattern match at Data.Validation.Semiring line 43, column 1 - line 43, column 30: " + [ v.constructor.name, v1.constructor.name, v2.constructor.name ]);
          };
      };
  };
  var showV = function (dictShow) {
      return function (dictShow1) {
          return new Data_Show.Show(function (v) {
              if (v instanceof Invalid) {
                  return "Invalid (" + (Data_Show.show(dictShow)(v.value0) + ")");
              };
              if (v instanceof Valid) {
                  return "Valid (" + (Data_Show.show(dictShow1)(v.value0) + ")");
              };
              throw new Error("Failed pattern match at Data.Validation.Semiring line 60, column 3 - line 61, column 3: " + [ v.constructor.name ]);
          });
      };
  };

  /**
 *  | Test whether validation was successful or not
 */  
  var isValid = function (v) {
      if (v instanceof Valid) {
          return true;
      };
      return false;
  };

  /**
 *  | Fail with a validation error
 */  
  var invalid = Invalid.create;
  var functorV = new Data_Functor.Functor(function (v) {
      return function (v1) {
          if (v1 instanceof Invalid) {
              return new Invalid(v1.value0);
          };
          if (v1 instanceof Valid) {
              return new Valid(v(v1.value0));
          };
          throw new Error("Failed pattern match at Data.Validation.Semiring line 64, column 3 - line 64, column 36: " + [ v.constructor.name, v1.constructor.name ]);
      };
  });
  var eqV = function (dictEq) {
      return function (dictEq1) {
          return new Data_Eq.Eq(function (x) {
              return function (y) {
                  if (x instanceof Valid && y instanceof Valid) {
                      return Data_Eq.eq(dictEq1)(x.value0)(y.value0);
                  };
                  if (x instanceof Invalid && y instanceof Invalid) {
                      return Data_Eq.eq(dictEq)(x.value0)(y.value0);
                  };
                  return false;
              };
          });
      };
  };
  var ordV = function (dictOrd) {
      return function (dictOrd1) {
          return new Data_Ord.Ord(function () {
              return eqV(dictOrd["__superclass_Data.Eq.Eq_0"]())(dictOrd1["__superclass_Data.Eq.Eq_0"]());
          }, function (x) {
              return function (y) {
                  if (x instanceof Valid && y instanceof Valid) {
                      return Data_Ord.compare(dictOrd1)(x.value0)(y.value0);
                  };
                  if (x instanceof Valid) {
                      return Data_Ordering.LT.value;
                  };
                  if (y instanceof Valid) {
                      return Data_Ordering.GT.value;
                  };
                  if (x instanceof Invalid && y instanceof Invalid) {
                      return Data_Ord.compare(dictOrd)(x.value0)(y.value0);
                  };
                  throw new Error("Failed pattern match at Data.Validation.Semiring line 57, column 1 - line 57, column 68: " + [ x.constructor.name, y.constructor.name ]);
              };
          });
      };
  };
  var bifunctorV = new Data_Bifunctor.Bifunctor(function (v) {
      return function (v1) {
          return function (v2) {
              if (v2 instanceof Invalid) {
                  return new Invalid(v(v2.value0));
              };
              if (v2 instanceof Valid) {
                  return new Valid(v1(v2.value0));
              };
              throw new Error("Failed pattern match at Data.Validation.Semiring line 68, column 3 - line 68, column 44: " + [ v.constructor.name, v1.constructor.name, v2.constructor.name ]);
          };
      };
  });
  var applyV = function (dictSemiring) {
      return new Control_Apply.Apply(function () {
          return functorV;
      }, function (v) {
          return function (v1) {
              if (v instanceof Invalid && v1 instanceof Invalid) {
                  return new Invalid(Data_Semiring.mul(dictSemiring)(v.value0)(v1.value0));
              };
              if (v instanceof Invalid) {
                  return new Invalid(v.value0);
              };
              if (v1 instanceof Invalid) {
                  return new Invalid(v1.value0);
              };
              if (v instanceof Valid && v1 instanceof Valid) {
                  return new Valid(v.value0(v1.value0));
              };
              throw new Error("Failed pattern match at Data.Validation.Semiring line 72, column 3 - line 72, column 62: " + [ v.constructor.name, v1.constructor.name ]);
          };
      });
  };
  var applicativeV = function (dictSemiring) {
      return new Control_Applicative.Applicative(function () {
          return applyV(dictSemiring);
      }, Valid.create);
  };
  var altV = function (dictSemiring) {
      return new Control_Alt.Alt(function () {
          return functorV;
      }, function (v) {
          return function (v1) {
              if (v instanceof Invalid && v1 instanceof Invalid) {
                  return new Invalid(Data_Semiring.add(dictSemiring)(v.value0)(v1.value0));
              };
              if (v instanceof Invalid) {
                  return v1;
              };
              if (v instanceof Valid) {
                  return new Valid(v.value0);
              };
              throw new Error("Failed pattern match at Data.Validation.Semiring line 81, column 3 - line 81, column 60: " + [ v.constructor.name, v1.constructor.name ]);
          };
      });
  };
  var plusV = function (dictSemiring) {
      return new Control_Plus.Plus(function () {
          return altV(dictSemiring);
      }, new Invalid(Data_Semiring.zero(dictSemiring)));
  };
  var alernativeV = function (dictSemiring) {
      return new Control_Alternative.Alternative(function () {
          return applicativeV(dictSemiring);
      }, function () {
          return plusV(dictSemiring);
      });
  };
  exports["invalid"] = invalid;
  exports["isValid"] = isValid;
  exports["unV"] = unV;
  exports["eqV"] = eqV;
  exports["ordV"] = ordV;
  exports["showV"] = showV;
  exports["functorV"] = functorV;
  exports["bifunctorV"] = bifunctorV;
  exports["applyV"] = applyV;
  exports["applicativeV"] = applicativeV;
  exports["altV"] = altV;
  exports["plusV"] = plusV;
  exports["alernativeV"] = alernativeV;
})(PS["Data.Validation.Semiring"] = PS["Data.Validation.Semiring"] || {});
(function(exports) {
    "use strict";
  var Prelude = PS["Prelude"];
  var Control_Comonad = PS["Control.Comonad"];
  var Control_Extend = PS["Control.Extend"];
  var Control_Monad_Trans_Class = PS["Control.Monad.Trans.Class"];
  var Data_Functor = PS["Data.Functor"];
  var Control_Semigroupoid = PS["Control.Semigroupoid"];
  var Control_Apply = PS["Control.Apply"];
  var Control_Category = PS["Control.Category"];
  var Control_Applicative = PS["Control.Applicative"];
  var Control_Bind = PS["Control.Bind"];
  var Control_Monad = PS["Control.Monad"];        

  /**
 *  | The Yoneda `Functor`
 *  |
 *  | `Yoneda f` is a `Functor` for any type constructor `f`.
 */  
  var Yoneda = function (x) {
      return x;
  };

  /**
 *  | Run a computation of type `Yoneda f a`.
 */  
  var runYoneda = function (v) {
      return function (k) {
          return v(k);
      };
  };

  /**
 *  | Lower a value of type `Yoneda f a` to the type constructor `f`.
 */  
  var lowerYoneda = function (v) {
      return v(Control_Category.id(Control_Category.categoryFn));
  };

  /**
 *  | Lift a value described by the `Functor` `f` to the `Functor` `Yoneda f`.
 */  
  var liftYoneda = function (dictFunctor) {
      return function (m) {
          return function (k) {
              return Data_Functor.map(dictFunctor)(k)(m);
          };
      };
  };
  var monadTransYoneda = new Control_Monad_Trans_Class.MonadTrans(function (dictMonad) {
      return liftYoneda(((dictMonad["__superclass_Control.Bind.Bind_1"]())["__superclass_Control.Apply.Apply_0"]())["__superclass_Data.Functor.Functor_0"]());
  });

  /**
 *  | Use a natural transformation to change the generating type constructor of a
 *  | `Yoneda`.
 */  
  var hoistYoneda = function (nat) {
      return function (v) {
          return Data_Functor.map(Data_Functor.functorFn)(nat)(v);
      };
  };
  var functorYoneda = new Data_Functor.Functor(function (f) {
      return function (m) {
          return function (k) {
              return runYoneda(m)(function ($26) {
                  return k(f($26));
              });
          };
      };
  });
  var extendYoneda = function (dictExtend) {
      return new Control_Extend.Extend(function () {
          return functorYoneda;
      }, function (f) {
          return function (v) {
              return function (k) {
                  return Control_Extend.extend(dictExtend)(function ($27) {
                      return k(f(liftYoneda(dictExtend["__superclass_Data.Functor.Functor_0"]())($27)));
                  })(v(Control_Category.id(Control_Category.categoryFn)));
              };
          };
      });
  };
  var comonadYoneda = function (dictComonad) {
      return new Control_Comonad.Comonad(function () {
          return extendYoneda(dictComonad["__superclass_Control.Extend.Extend_0"]());
      }, function ($28) {
          return Control_Comonad.extract(dictComonad)(lowerYoneda($28));
      });
  };
  var applyYoneda = function (dictApply) {
      return new Control_Apply.Apply(function () {
          return functorYoneda;
      }, function (v) {
          return function (v1) {
              return function (k) {
                  return Control_Apply.apply(dictApply)(v(Control_Semigroupoid.compose(Control_Semigroupoid.semigroupoidFn)(k)))(v1(Control_Category.id(Control_Category.categoryFn)));
              };
          };
      });
  };
  var bindYoneda = function (dictBind) {
      return new Control_Bind.Bind(function () {
          return applyYoneda(dictBind["__superclass_Control.Apply.Apply_0"]());
      }, function (v) {
          return function (g) {
              return function (k) {
                  return Control_Bind.bind(dictBind)(v(Control_Category.id(Control_Category.categoryFn)))(function (a) {
                      return runYoneda(g(a))(k);
                  });
              };
          };
      });
  };
  var applicativeYoneda = function (dictApplicative) {
      return new Control_Applicative.Applicative(function () {
          return applyYoneda(dictApplicative["__superclass_Control.Apply.Apply_0"]());
      }, function ($29) {
          return liftYoneda((dictApplicative["__superclass_Control.Apply.Apply_0"]())["__superclass_Data.Functor.Functor_0"]())(Control_Applicative.pure(dictApplicative)($29));
      });
  };
  var monadYoneda = function (dictMonad) {
      return new Control_Monad.Monad(function () {
          return applicativeYoneda(dictMonad["__superclass_Control.Applicative.Applicative_0"]());
      }, function () {
          return bindYoneda(dictMonad["__superclass_Control.Bind.Bind_1"]());
      });
  };
  exports["Yoneda"] = Yoneda;
  exports["hoistYoneda"] = hoistYoneda;
  exports["liftYoneda"] = liftYoneda;
  exports["lowerYoneda"] = lowerYoneda;
  exports["runYoneda"] = runYoneda;
  exports["functorYoneda"] = functorYoneda;
  exports["applyYoneda"] = applyYoneda;
  exports["applicativeYoneda"] = applicativeYoneda;
  exports["bindYoneda"] = bindYoneda;
  exports["monadYoneda"] = monadYoneda;
  exports["monadTransYoneda"] = monadTransYoneda;
  exports["extendYoneda"] = extendYoneda;
  exports["comonadYoneda"] = comonadYoneda;
})(PS["Data.Yoneda"] = PS["Data.Yoneda"] || {});
(function(exports) {
  /* globals exports */
  "use strict";

  // module Global

  exports.nan = NaN;

  exports.isNaN = isNaN;

  exports.infinity = Infinity;

  exports.isFinite = isFinite;

  exports.readInt = function (radix) {
    return function (n) {
      return parseInt(n, radix);
    };
  };

  exports.readFloat = parseFloat;

  exports.decodeURI = decodeURI;
  exports.encodeURI = encodeURI;
  exports.decodeURIComponent = decodeURIComponent;
  exports.encodeURIComponent = encodeURIComponent;
})(PS["Global"] = PS["Global"] || {});
(function(exports) {
  
  /**
 *  | This module defines types for some global Javascript functions
 *  | and values.
 */  
  "use strict";
  var $foreign = PS["Global"];
  exports["decodeURI"] = $foreign["decodeURI"];
  exports["decodeURIComponent"] = $foreign["decodeURIComponent"];
  exports["encodeURI"] = $foreign["encodeURI"];
  exports["encodeURIComponent"] = $foreign["encodeURIComponent"];
  exports["infinity"] = $foreign.infinity;
  exports["isFinite"] = $foreign["isFinite"];
  exports["isNaN"] = $foreign["isNaN"];
  exports["nan"] = $foreign.nan;
  exports["readFloat"] = $foreign.readFloat;
  exports["readInt"] = $foreign.readInt;
})(PS["Global"] = PS["Global"] || {});
(function(exports) {
  /* globals exports, JSON */
  "use strict";

  // module Global.Unsafe

  exports.unsafeStringify = function (x) {
    return JSON.stringify(x);
  };

  exports.unsafeToFixed = function (digits) {
    return function (n) {
      return n.toFixed(digits);
    };
  };

  exports.unsafeToExponential = function (digits) {
    return function (n) {
      return n.toExponential(digits);
    };
  };

  exports.unsafeToPrecision  = function (digits) {
    return function (n) {
      return n.toPrecision(digits);
    };
  };
})(PS["Global.Unsafe"] = PS["Global.Unsafe"] || {});
(function(exports) {
    "use strict";
  var $foreign = PS["Global.Unsafe"];
  exports["unsafeStringify"] = $foreign.unsafeStringify;
  exports["unsafeToExponential"] = $foreign.unsafeToExponential;
  exports["unsafeToFixed"] = $foreign.unsafeToFixed;
  exports["unsafeToPrecision"] = $foreign.unsafeToPrecision;
})(PS["Global.Unsafe"] = PS["Global.Unsafe"] || {});
(function(exports) {
  
  /**
 *  | This module provides support for the
 *  | PureScript interactive mode, PSCI.
 */  
  "use strict";
  var Prelude = PS["Prelude"];
  var Control_Monad_Eff = PS["Control.Monad.Eff"];
  var Control_Monad_Eff_Console = PS["Control.Monad.Eff.Console"];
  var Control_Monad_Eff_Unsafe = PS["Control.Monad.Eff.Unsafe"];
  var Control_Bind = PS["Control.Bind"];        

  /**
 *  | The `Eval` class captures those types which can be
 *  | evaluated in the REPL.
 *  |
 *  | There are (possibly overlapping) instances provided for
 *  | the `Eff` type constructor and any `Show`able types.
 */  
  var Eval = function ($$eval) {
      this["eval"] = $$eval;
  };
  var evalShow = function (dictShow) {
      return new Eval(Control_Monad_Eff_Console.logShow(dictShow));
  };

  /**
 *  | The `Eval` class captures those types which can be
 *  | evaluated in the REPL.
 *  |
 *  | There are (possibly overlapping) instances provided for
 *  | the `Eff` type constructor and any `Show`able types.
 */  
  var $$eval = function (dict) {
      return dict["eval"];
  };
  var evalEff = function (dictEval) {
      return new Eval(function (x) {
          return function __do() {
              var v = Control_Monad_Eff_Unsafe.unsafeCoerceEff(x)();
              return $$eval(dictEval)(v)();
          };
      });
  };
  exports["Eval"] = Eval;
  exports["eval"] = $$eval;
  exports["evalShow"] = evalShow;
  exports["evalEff"] = evalEff;
})(PS["PSCI.Support"] = PS["PSCI.Support"] || {});
(function(exports) {
    "use strict";

  // module Test.Assert

  exports["assert'"] = function (message) {
    return function (success) {
      return function () {
        if (!success) throw new Error(message);
        return {};
      };
    };
  };

  exports.checkThrows = function (fn) {
    return function () {
      try {
        fn();
        return false;
      } catch (e) {
        if (e instanceof Error) return true;
        var err = new Error("Threw something other than an Error");
        err.something = e;
        throw err;
      }
    };
  };
})(PS["Test.Assert"] = PS["Test.Assert"] || {});
(function(exports) {
    "use strict";
  var $foreign = PS["Test.Assert"];
  var Control_Monad_Eff = PS["Control.Monad.Eff"];
  var Control_Monad = PS["Control.Monad"];
  var Data_Unit = PS["Data.Unit"];
  var Control_Bind = PS["Control.Bind"];        

  /**
 *  | Throws a runtime exception with the specified message, unless the argument
 *  | throws an exception when evaluated.
 *  |
 *  | This function is specifically for testing unsafe pure code; for example,
 *  | to make sure that an exception is thrown if a precondition is not
 *  | satisfied. Functions which use `Eff (err :: EXCEPTION | eff) a` can be
 *  | tested with `catchException` instead.
 */  
  var assertThrows$prime = function (msg) {
      return function (fn) {
          return Control_Bind.bindFlipped(Control_Monad_Eff.bindEff)($foreign["assert'"](msg))($foreign.checkThrows(fn));
      };
  };

  /**
 *  | Throws a runtime exception with message "Assertion failed: An error should
 *  | have been thrown", unless the argument throws an exception when evaluated.
 *  |
 *  | This function is specifically for testing unsafe pure code; for example,
 *  | to make sure that an exception is thrown if a precondition is not
 *  | satisfied. Functions which use `Eff (err :: EXCEPTION | eff) a` can be
 *  | tested with `catchException` instead.
 */  
  var assertThrows = assertThrows$prime("Assertion failed: An error should have been thrown");

  /**
 *  | Throws a runtime exception with message "Assertion failed" when the boolean
 *  | value is false.
 */  
  var assert = $foreign["assert'"]("Assertion failed");
  exports["assert"] = assert;
  exports["assertThrows"] = assertThrows;
  exports["assertThrows'"] = assertThrows$prime;
  exports["assert'"] = $foreign["assert'"];
})(PS["Test.Assert"] = PS["Test.Assert"] || {});
(function(exports) {
  /* global exports, ArrayBuffer, Float32Array, Int32Array */
  "use strict";

  // module Test.QuickCheck.Gen

  exports.float32ToInt32 = function (n) {
    var arr = new ArrayBuffer(4);
    var fv = new Float32Array(arr);
    var iv = new Int32Array(arr);
    fv[0] = n;
    return iv[0];
  };
})(PS["Test.QuickCheck.Gen"] = PS["Test.QuickCheck.Gen"] || {});
(function(exports) {
    "use strict";
  var Prelude = PS["Prelude"];
  var Control_Monad_Eff = PS["Control.Monad.Eff"];
  var Control_Monad_Eff_Random = PS["Control.Monad.Eff.Random"];
  var Data_Int = PS["Data.Int"];
  var Data_Maybe = PS["Data.Maybe"];
  var $$Math = PS["Math"];
  var Partial_Unsafe = PS["Partial.Unsafe"];
  var Data_Show = PS["Data.Show"];
  var Data_Semigroup = PS["Data.Semigroup"];
  var Data_Eq = PS["Data.Eq"];
  var Data_Ring = PS["Data.Ring"];
  var Data_Function = PS["Data.Function"];
  var Data_Semiring = PS["Data.Semiring"];
  var Control_Semigroupoid = PS["Control.Semigroupoid"];
  var Data_EuclideanRing = PS["Data.EuclideanRing"];
  var Data_Ord = PS["Data.Ord"];
  var Data_Functor = PS["Data.Functor"];        

  /**
 *  | A seed for the linear congruential generator. We omit a `Semiring`
 *  | instance because there is no `zero` value, as 0 is not an acceptable
 *  | seed for the generator.
 */  
  var Seed = function (x) {
      return x;
  };
  var showSeed = new Data_Show.Show(function (v) {
      return "Seed " + Data_Show.show(Data_Show.showInt)(v);
  });

  /**
 *  | The minimum permissible Seed value.
 */  
  var seedMin = 1;
  var runSeed = function (v) {
      return v;
  };

  /**
 *  | The *modulus*: a magic constant for the linear congruential generator.
 *  | It is equal to 2^31 - 1, a Mersenne prime. It is useful for this value to
 *  | be prime, because then the requirement of the initial seed being coprime
 *  | to the modulus is satisfied when the seed is between 1 and lcgN - 1.
 */  
  var lcgN = 2147483647;

  /**
 *  | The maximum permissible Seed value.
 */  
  var seedMax = lcgN - 1;

  /**
 *  | The *multiplier*: a magic constant for the linear congruential generator
 */  
  var lcgM = 48271;

  /**
 *  | Perturb a seed value
 */  
  var lcgPerturb = function (d) {
      var go = function (n) {
          return Partial_Unsafe.unsafePartial(function (dictPartial) {
              return Data_Maybe.fromJust(dictPartial)(Data_Int.fromNumber($$Math.remainder(Data_Int.toNumber(lcgM) * Data_Int.toNumber(n) + d)(Data_Int.toNumber(lcgN))));
          });
      };
      return function ($10) {
          return Seed(go(runSeed($10)));
      };
  };

  /**
 *  | The *increment*: a magic constant for the linear congruential generator
 */  
  var lcgC = 0;

  /**
 *  | Step the linear congruential generator
 */  
  var lcgNext = lcgPerturb(Data_Int.toNumber(lcgC));
  var eqSeed = new Data_Eq.Eq(function (v) {
      return function (v1) {
          return v === v1;
      };
  });
  var ensureBetween = function (min) {
      return function (max) {
          return function (n) {
              var rangeSize = max - min;
              var n$prime = n % rangeSize;
              var $9 = n$prime < min;
              if ($9) {
                  return n$prime + max | 0;
              };
              if (!$9) {
                  return n$prime;
              };
              throw new Error("Failed pattern match at Test.QuickCheck.LCG line 80, column 5 - line 80, column 38: " + [ $9.constructor.name ]);
          };
      };
  };
  var mkSeed = function (x) {
      return ensureBetween(seedMin)(seedMax)(x);
  };

  /**
 *  | Create a random seed
 */  
  var randomSeed = Data_Functor.map(Control_Monad_Eff.functorEff)(mkSeed)(Control_Monad_Eff_Random.randomInt(seedMin)(seedMax));
  exports["lcgC"] = lcgC;
  exports["lcgM"] = lcgM;
  exports["lcgN"] = lcgN;
  exports["lcgNext"] = lcgNext;
  exports["lcgPerturb"] = lcgPerturb;
  exports["mkSeed"] = mkSeed;
  exports["randomSeed"] = randomSeed;
  exports["runSeed"] = runSeed;
  exports["showSeed"] = showSeed;
  exports["eqSeed"] = eqSeed;
})(PS["Test.QuickCheck.LCG"] = PS["Test.QuickCheck.LCG"] || {});
(function(exports) {
  
  /**
 *  | This module defines the random generator monad used by the `Test.QuickCheck`
 *  | module, as well as helper functions for constructing random generators.
 */  
  "use strict";
  var $foreign = PS["Test.QuickCheck.Gen"];
  var Prelude = PS["Prelude"];
  var Control_Alt = PS["Control.Alt"];
  var Control_Monad_Eff = PS["Control.Monad.Eff"];
  var Control_Monad_Eff_Random = PS["Control.Monad.Eff.Random"];
  var Control_Monad_Rec_Class = PS["Control.Monad.Rec.Class"];
  var Control_Monad_State = PS["Control.Monad.State"];
  var Control_Monad_State_Class = PS["Control.Monad.State.Class"];
  var Control_Monad_State_Trans = PS["Control.Monad.State.Trans"];
  var Data_Array = PS["Data.Array"];
  var Data_Foldable = PS["Data.Foldable"];
  var Data_Identity = PS["Data.Identity"];
  var Data_Int = PS["Data.Int"];
  var Data_List = PS["Data.List"];
  var Data_Maybe = PS["Data.Maybe"];
  var Data_Monoid_Additive = PS["Data.Monoid.Additive"];
  var Data_Newtype = PS["Data.Newtype"];
  var Data_Tuple = PS["Data.Tuple"];
  var $$Math = PS["Math"];
  var Test_QuickCheck_LCG = PS["Test.QuickCheck.LCG"];
  var Data_Functor = PS["Data.Functor"];
  var Control_Apply = PS["Control.Apply"];
  var Control_Applicative = PS["Control.Applicative"];
  var Control_Bind = PS["Control.Bind"];
  var Control_Monad = PS["Control.Monad"];
  var Control_Semigroupoid = PS["Control.Semigroupoid"];
  var Data_Function = PS["Data.Function"];
  var Data_Ord = PS["Data.Ord"];
  var Data_List_Types = PS["Data.List.Types"];
  var Data_Ring = PS["Data.Ring"];
  var Data_EuclideanRing = PS["Data.EuclideanRing"];
  var Data_Unfoldable = PS["Data.Unfoldable"];
  var Data_Semiring = PS["Data.Semiring"];
  var Data_Boolean = PS["Data.Boolean"];
  var Data_Eq = PS["Data.Eq"];        

  /**
 *  | The random generator monad
 *  |
 *  | `Gen` is a state monad which encodes a linear congruential generator.
 */  
  var Gen = function (x) {
      return x;
  };

  /**
 *  | Exposes the underlying State implementation.
 */  
  var unGen = function (v) {
      return v;
  };

  /**
 *  | Run a random generator
 */  
  var runGen = function ($55) {
      return Control_Monad_State.runState(unGen($55));
  };

  /**
 *  | Create a random generator which uses the generator state explicitly.
 */  
  var stateful = function (f) {
      return Gen(Control_Monad_State_Class.state(Control_Monad_State_Trans.monadStateStateT(Data_Identity.monadIdentity))(function (s) {
          return runGen(f(s))(s);
      }));
  };

  /**
 *  | Create a random generator which depends on the size parameter.
 */  
  var sized = function (f) {
      return stateful(function (s) {
          return f(s.size);
      });
  };

  /**
 *  | Modify a random generator by setting a new random seed.
 */  
  var variant = function (n) {
      return function (g) {
          return Gen(Control_Monad_State_Class.state(Control_Monad_State_Trans.monadStateStateT(Data_Identity.monadIdentity))(function (s) {
              return runGen(g)((function () {
                  var $14 = {};
                  for (var $15 in s) {
                      if ({}.hasOwnProperty.call(s, $15)) {
                          $14[$15] = s[$15];
                      };
                  };
                  $14.newSeed = n;
                  return $14;
              })());
          }));
      };
  };

  /**
 *  | Modify a random generator by setting a new size parameter.
 */  
  var resize = function (sz) {
      return function (g) {
          return Gen(Control_Monad_State_Class.state(Control_Monad_State_Trans.monadStateStateT(Data_Identity.monadIdentity))(function (s) {
              return runGen(g)((function () {
                  var $17 = {};
                  for (var $18 in s) {
                      if ({}.hasOwnProperty.call(s, $18)) {
                          $17[$18] = s[$18];
                      };
                  };
                  $17.size = sz;
                  return $17;
              })());
          }));
      };
  };
  var replicateMRec = function (dictMonadRec) {
      return function (k) {
          return function (v) {
              if (k <= 0) {
                  return Control_Applicative.pure((dictMonadRec["__superclass_Control.Monad.Monad_0"]())["__superclass_Control.Applicative.Applicative_0"]())(Data_List_Types.Nil.value);
              };
              var go = function (v1) {
                  if (v1.value1 === 0) {
                      return Control_Applicative.pure((dictMonadRec["__superclass_Control.Monad.Monad_0"]())["__superclass_Control.Applicative.Applicative_0"]())(new Control_Monad_Rec_Class.Done(v1.value0));
                  };
                  return Data_Functor.mapFlipped((((dictMonadRec["__superclass_Control.Monad.Monad_0"]())["__superclass_Control.Bind.Bind_1"]())["__superclass_Control.Apply.Apply_0"]())["__superclass_Data.Functor.Functor_0"]())(v)(function (x) {
                      return new Control_Monad_Rec_Class.Loop(new Data_Tuple.Tuple(new Data_List_Types.Cons(x, v1.value0), v1.value1 - 1));
                  });
              };
              return Control_Monad_Rec_Class.tailRecM(dictMonadRec)(go)(new Data_Tuple.Tuple(Data_List_Types.Nil.value, k));
          };
      };
  };

  /**
 *  | Create a random generator for a function type.
 */  
  var repeatable = function (f) {
      return Gen(Control_Monad_State_Class.state(Control_Monad_State_Trans.monadStateStateT(Data_Identity.monadIdentity))(function (s) {
          return new Data_Tuple.Tuple(function (a) {
              return Data_Tuple.fst(runGen(f(a))(s));
          }, (function () {
              var $27 = {};
              for (var $28 in s) {
                  if ({}.hasOwnProperty.call(s, $28)) {
                      $27[$28] = s[$28];
                  };
              };
              $27.newSeed = Test_QuickCheck_LCG.lcgNext(s.newSeed);
              return $27;
          })());
      }));
  };

  /**
 *  | Perturb a random generator by modifying the current seed
 */  
  var perturbGen = function (n) {
      return function (gen) {
          return Control_Bind.bind(Control_Monad_State_Trans.bindStateT(Data_Identity.monadIdentity))(Control_Monad_State_Class.modify(Control_Monad_State_Trans.monadStateStateT(Data_Identity.monadIdentity))(function (s) {
              var $30 = {};
              for (var $31 in s) {
                  if ({}.hasOwnProperty.call(s, $31)) {
                      $30[$31] = s[$31];
                  };
              };
              $30.newSeed = Test_QuickCheck_LCG.lcgPerturb(Data_Int.toNumber($foreign.float32ToInt32(n)))(s.newSeed);
              return $30;
          }))(function () {
              return unGen(gen);
          });
      };
  };
  var monadRecGen = Control_Monad_State_Trans.monadRecStateT(Control_Monad_Rec_Class.monadRecIdentity);
  var monadGen = Control_Monad_State_Trans.monadStateT(Data_Identity.monadIdentity);

  /**
 *  | Create a random generator which generates a list of random values of the specified size.
 */  
  var listOf = replicateMRec(monadRecGen);

  /**
 *  | A random generator which simply outputs the current seed
 */  
  var lcgStep = (function () {
      var f = function (s) {
          return new Data_Tuple.Tuple(Test_QuickCheck_LCG.runSeed(s.newSeed), (function () {
              var $33 = {};
              for (var $34 in s) {
                  if ({}.hasOwnProperty.call(s, $34)) {
                      $33[$34] = s[$34];
                  };
              };
              $33.newSeed = Test_QuickCheck_LCG.lcgNext(s.newSeed);
              return $33;
          })());
      };
      return Gen(Control_Monad_State_Class.state(Control_Monad_State_Trans.monadStateStateT(Data_Identity.monadIdentity))(f));
  })();
  var functorGen = Control_Monad_State_Trans.functorStateT(Data_Identity.functorIdentity);

  /**
 *  | A random generator which approximates a uniform random variable on `[0, 1]`
 */  
  var uniform = Data_Functor.map(functorGen)(function (n) {
      return Data_Int.toNumber(n) / Data_Int.toNumber(Test_QuickCheck_LCG.lcgN);
  })(lcgStep);

  /**
 *  | Create a random generator which generates a vector of random values of a specified size.
 */  
  var vectorOf = function (k) {
      return function (g) {
          return Data_Functor.map(functorGen)(Data_List.toUnfoldable(Data_Unfoldable.unfoldableArray))(listOf(k)(g));
      };
  };

  /**
 *  | Run a random generator, keeping only the randomly-generated result
 */  
  var evalGen = function ($56) {
      return Control_Monad_State.evalState(unGen($56));
  };

  /**
 *  | Sample a random generator
 */  
  var sample = function (seed) {
      return function (sz) {
          return function (g) {
              return evalGen(vectorOf(sz)(g))({
                  newSeed: seed, 
                  size: sz
              });
          };
      };
  };

  /**
 *  | Sample a random generator, using a randomly generated seed
 */  
  var randomSample$prime = function (n) {
      return function (g) {
          return function __do() {
              var v = Test_QuickCheck_LCG.randomSeed();
              return sample(v)(n)(g);
          };
      };
  };

  /**
 *  | Get a random sample of 10 values
 */  
  var randomSample = randomSample$prime(10);

  /**
 *  | Create a random generator which chooses uniformly distributed
 *  | integers from the closed interval `[a, b]`.
 */  
  var chooseInt = function (a) {
      return function (b) {
          var clamp = function (x) {
              var $37 = x % ((b - a) + 1 | 0);
              if ($37 >= 0) {
                  return a + $37 | 0;
              };
              if (Data_Boolean.otherwise) {
                  return (b + $37 | 0) + 1 | 0;
              };
              throw new Error("Failed pattern match at Test.QuickCheck.Gen line 112, column 13 - line 114, column 43: " + [ $37.constructor.name ]);
          };
          return Data_Functor.map(functorGen)(clamp)(lcgStep);
      };
  };

  /**
 *  | Create a random generator which samples a range of `Number`s i
 *  | with uniform probability.
 */  
  var choose = function (a) {
      return function (b) {
          var min = $$Math.min(a)(b);
          var max = $$Math.max(a)(b);
          return Data_Functor.map(functorGen)(function ($57) {
              return min + (max - min) * $57;
          })(uniform);
      };
  };
  var bindGen = Control_Monad_State_Trans.bindStateT(Data_Identity.monadIdentity);

  /**
 *  | Create a random generator which selects and executes a random generator from
 *  | a non-empty, weighted collection of random generators.
 */  
  var frequency = function (x) {
      return function (xs) {
          var xxs = new Data_List_Types.Cons(x, xs);
          var total = Data_Newtype.unwrap(Data_Monoid_Additive.newtypeAdditive)(Data_Foldable.fold(Data_List_Types.foldableList)(Data_Monoid_Additive.monoidAdditive(Data_Semiring.semiringNumber))(Data_Functor.map(Data_List_Types.functorList)(function ($58) {
              return Data_Monoid_Additive.Additive(Data_Tuple.fst($58));
          })(xxs)));
          var pick = function (__copy_n) {
              return function (__copy_d) {
                  return function (__copy_v) {
                      var n = __copy_n;
                      var d = __copy_d;
                      var v = __copy_v;
                      tco: while (true) {
                          if (v instanceof Data_List_Types.Nil) {
                              return d;
                          };
                          if (v instanceof Data_List_Types.Cons) {
                              var $41 = n <= v.value0.value0;
                              if ($41) {
                                  return v.value0.value1;
                              };
                              if (!$41) {
                                  var __tco_n = n - v.value0.value0;
                                  var __tco_d = d;
                                  var __tco_v = v.value1;
                                  n = __tco_n;
                                  d = __tco_d;
                                  v = __tco_v;
                                  continue tco;
                              };
                              throw new Error("Failed pattern match at Test.QuickCheck.Gen line 130, column 38 - line 130, column 77: " + [ $41.constructor.name ]);
                          };
                          throw new Error("Failed pattern match at Test.QuickCheck.Gen line 126, column 18 - line 133, column 23: " + [ n.constructor.name, d.constructor.name, v.constructor.name ]);
                      };
                  };
              };
          };
          return Control_Bind.bind(bindGen)(choose(0)(total))(function (v) {
              return pick(v)(Data_Tuple.snd(x))(xxs);
          });
      };
  };

  /**
 *  | Create a random generator which selects and executes a random generator from
 *  | a non-empty collection of random generators with uniform probability.
 */  
  var oneOf = function (x) {
      return function (xs) {
          return Control_Bind.bind(bindGen)(chooseInt(0)(Data_Array.length(xs)))(function (v) {
              var $48 = v < 1;
              if ($48) {
                  return x;
              };
              if (!$48) {
                  return Data_Maybe.fromMaybe(x)(Data_Array.index(xs)(v - 1));
              };
              throw new Error("Failed pattern match at Test.QuickCheck.Gen line 121, column 3 - line 121, column 55: " + [ $48.constructor.name ]);
          });
      };
  };

  /**
 *  | Create a random generator which generates an array of random values.
 */  
  var arrayOf = function (g) {
      return sized(function (n) {
          return Control_Bind.bind(bindGen)(chooseInt(0)(n))(function (v) {
              return vectorOf(v)(g);
          });
      });
  };
  var applyGen = Control_Monad_State_Trans.applyStateT(Data_Identity.monadIdentity);
  var applicativeGen = Control_Monad_State_Trans.applicativeStateT(Data_Identity.monadIdentity);

  /**
 *  | Create a random generator which generates a non-empty array of random values.
 */  
  var arrayOf1 = function (g) {
      return sized(function (n) {
          return Control_Bind.bind(bindGen)(chooseInt(0)(n))(function (v) {
              return Control_Bind.bind(bindGen)(g)(function (v1) {
                  return Control_Bind.bind(bindGen)(vectorOf(v - 1)(g))(function (v2) {
                      return Control_Applicative.pure(applicativeGen)(new Data_Tuple.Tuple(v1, v2));
                  });
              });
          });
      });
  };

  /**
 *  | Create a random generator which selects a value from a non-empty collection with
 *  | uniform probability.
 */  
  var elements = function (x) {
      return function (xs) {
          return Control_Bind.bind(bindGen)(chooseInt(0)(Data_Array.length(xs)))(function (v) {
              return Control_Applicative.pure(applicativeGen)((function () {
                  var $54 = v === 0;
                  if ($54) {
                      return x;
                  };
                  if (!$54) {
                      return Data_Maybe.fromMaybe(x)(Data_Array.index(xs)(v - 1));
                  };
                  throw new Error("Failed pattern match at Test.QuickCheck.Gen line 170, column 8 - line 170, column 62: " + [ $54.constructor.name ]);
              })());
          });
      };
  };
  var altGen = Control_Monad_State_Trans.altStateT(Data_Identity.monadIdentity)(Data_Identity.altIdentity);
  exports["arrayOf"] = arrayOf;
  exports["arrayOf1"] = arrayOf1;
  exports["choose"] = choose;
  exports["chooseInt"] = chooseInt;
  exports["elements"] = elements;
  exports["evalGen"] = evalGen;
  exports["frequency"] = frequency;
  exports["listOf"] = listOf;
  exports["oneOf"] = oneOf;
  exports["perturbGen"] = perturbGen;
  exports["randomSample"] = randomSample;
  exports["randomSample'"] = randomSample$prime;
  exports["repeatable"] = repeatable;
  exports["resize"] = resize;
  exports["runGen"] = runGen;
  exports["sample"] = sample;
  exports["sized"] = sized;
  exports["stateful"] = stateful;
  exports["unGen"] = unGen;
  exports["uniform"] = uniform;
  exports["variant"] = variant;
  exports["vectorOf"] = vectorOf;
  exports["functorGen"] = functorGen;
  exports["applyGen"] = applyGen;
  exports["applicativeGen"] = applicativeGen;
  exports["bindGen"] = bindGen;
  exports["monadGen"] = monadGen;
  exports["altGen"] = altGen;
  exports["monadRecGen"] = monadRecGen;
})(PS["Test.QuickCheck.Gen"] = PS["Test.QuickCheck.Gen"] || {});
(function(exports) {
    "use strict";
  var Prelude = PS["Prelude"];
  var Data_Char = PS["Data.Char"];
  var Data_Either = PS["Data.Either"];
  var Data_Foldable = PS["Data.Foldable"];
  var Data_Identity = PS["Data.Identity"];
  var Data_Int = PS["Data.Int"];
  var Data_Lazy = PS["Data.Lazy"];
  var Data_List = PS["Data.List"];
  var Data_Maybe = PS["Data.Maybe"];
  var Data_Newtype = PS["Data.Newtype"];
  var Data_String = PS["Data.String"];
  var Data_Tuple = PS["Data.Tuple"];
  var Test_QuickCheck_Gen = PS["Test.QuickCheck.Gen"];
  var Control_Bind = PS["Control.Bind"];
  var Data_Function = PS["Data.Function"];
  var Control_Applicative = PS["Control.Applicative"];
  var Data_Ord = PS["Data.Ord"];
  var Data_Semiring = PS["Data.Semiring"];
  var Data_Ring = PS["Data.Ring"];
  var Control_Semigroupoid = PS["Control.Semigroupoid"];
  var Data_Functor = PS["Data.Functor"];
  var Data_Unit = PS["Data.Unit"];
  var Data_Ordering = PS["Data.Ordering"];
  var Control_Category = PS["Control.Category"];
  var Control_Apply = PS["Control.Apply"];
  var Data_List_Types = PS["Data.List.Types"];        

  /**
 *  | The `Arbitrary` class represents those types whose values can be
 *  | _randomly-generated_.
 *  |
 *  | `arbitrary` uses the `Gen` monad to express a random generator for
 *  | the type `t`. Combinators in the `Test.QuickCheck.Gen`
 *  | module can be used to construct random generators.
 */  
  var Arbitrary = function (arbitrary) {
      this.arbitrary = arbitrary;
  };

  /**
 *  | The `Coarbitrary` class represents types which appear on the left of
 *  | an `Arbitrary` function arrow.
 *  |
 *  | To construct an `Arbitrary` instance for the type `a -> b`, we need to
 *  | use the input of type `a` to _perturb_ a random generator for `b`. This
 *  | is the role of the `coarbitrary` function.
 *  |
 *  | `Coarbitrary` instances can be written using the `perturbGen` function.
 */  
  var Coarbitrary = function (coarbitrary) {
      this.coarbitrary = coarbitrary;
  };

  /**
 *  | The `Coarbitrary` class represents types which appear on the left of
 *  | an `Arbitrary` function arrow.
 *  |
 *  | To construct an `Arbitrary` instance for the type `a -> b`, we need to
 *  | use the input of type `a` to _perturb_ a random generator for `b`. This
 *  | is the role of the `coarbitrary` function.
 *  |
 *  | `Coarbitrary` instances can be written using the `perturbGen` function.
 */  
  var coarbitrary = function (dict) {
      return dict.coarbitrary;
  };
  var coarbUnit = new Coarbitrary(function (v) {
      return Test_QuickCheck_Gen.perturbGen(1.0);
  });
  var coarbTuple = function (dictCoarbitrary) {
      return function (dictCoarbitrary1) {
          return new Coarbitrary(function (v) {
              return function ($50) {
                  return coarbitrary(dictCoarbitrary1)(v.value1)(coarbitrary(dictCoarbitrary)(v.value0)($50));
              };
          });
      };
  };
  var coarbOrdering = new Coarbitrary(function (v) {
      if (v instanceof Data_Ordering.LT) {
          return Test_QuickCheck_Gen.perturbGen(1.0);
      };
      if (v instanceof Data_Ordering.EQ) {
          return Test_QuickCheck_Gen.perturbGen(2.0);
      };
      if (v instanceof Data_Ordering.GT) {
          return Test_QuickCheck_Gen.perturbGen(3.0);
      };
      throw new Error("Failed pattern match at Test.QuickCheck.Arbitrary line 87, column 3 - line 88, column 3: " + [ v.constructor.name ]);
  });
  var coarbNumber = new Coarbitrary(Test_QuickCheck_Gen.perturbGen);
  var coarbMaybe = function (dictCoarbitrary) {
      return new Coarbitrary(function (v) {
          if (v instanceof Data_Maybe.Nothing) {
              return Test_QuickCheck_Gen.perturbGen(1.0);
          };
          if (v instanceof Data_Maybe.Just) {
              return coarbitrary(dictCoarbitrary)(v.value0);
          };
          throw new Error("Failed pattern match at Test.QuickCheck.Arbitrary line 117, column 3 - line 118, column 3: " + [ v.constructor.name ]);
      });
  };
  var coarbList = function (dictCoarbitrary) {
      return new Coarbitrary(Data_Foldable.foldl(Data_List_Types.foldableList)(function (f) {
          return function (x) {
              return function ($51) {
                  return f(coarbitrary(dictCoarbitrary)(x)($51));
              };
          };
      })(Control_Category.id(Control_Category.categoryFn)));
  };
  var coarbLazy = function (dictCoarbitrary) {
      return new Coarbitrary(function (a) {
          return coarbitrary(dictCoarbitrary)(Data_Lazy.force(a));
      });
  };
  var coarbInt = new Coarbitrary(function ($52) {
      return Test_QuickCheck_Gen.perturbGen(Data_Int.toNumber($52));
  });
  var coarbIdentity = function (dictCoarbitrary) {
      return new Coarbitrary(function (v) {
          return coarbitrary(dictCoarbitrary)(v);
      });
  };
  var coarbEither = function (dictCoarbitrary) {
      return function (dictCoarbitrary1) {
          return new Coarbitrary(function (v) {
              if (v instanceof Data_Either.Left) {
                  return coarbitrary(dictCoarbitrary)(v.value0);
              };
              if (v instanceof Data_Either.Right) {
                  return coarbitrary(dictCoarbitrary1)(v.value0);
              };
              throw new Error("Failed pattern match at Test.QuickCheck.Arbitrary line 126, column 3 - line 126, column 40: " + [ v.constructor.name ]);
          });
      };
  };
  var coarbChar = new Coarbitrary(function (c) {
      return coarbitrary(coarbInt)(Data_Char.toCharCode(c));
  });
  var coarbBoolean = new Coarbitrary(function (v) {
      if (v) {
          return Test_QuickCheck_Gen.perturbGen(1.0);
      };
      if (!v) {
          return Test_QuickCheck_Gen.perturbGen(2.0);
      };
      throw new Error("Failed pattern match at Test.QuickCheck.Arbitrary line 50, column 3 - line 51, column 3: " + [ v.constructor.name ]);
  });
  var coarbArray = function (dictCoarbitrary) {
      return new Coarbitrary(Data_Foldable.foldl(Data_Foldable.foldableArray)(function (f) {
          return function (x) {
              return function ($53) {
                  return f(coarbitrary(dictCoarbitrary)(x)($53));
              };
          };
      })(Control_Category.id(Control_Category.categoryFn)));
  };
  var coarbString = new Coarbitrary(function (s) {
      return coarbitrary(coarbArray(coarbMaybe(coarbInt)))(Data_Functor.map(Data_Functor.functorArray)(Data_String.charCodeAt(0))(Data_String.split(Data_Newtype.wrap(Data_String.newtypePattern)(""))(s)));
  });

  /**
 *  | The `Arbitrary` class represents those types whose values can be
 *  | _randomly-generated_.
 *  |
 *  | `arbitrary` uses the `Gen` monad to express a random generator for
 *  | the type `t`. Combinators in the `Test.QuickCheck.Gen`
 *  | module can be used to construct random generators.
 */  
  var arbitrary = function (dict) {
      return dict.arbitrary;
  };
  var arbitraryIdentity = function (dictArbitrary) {
      return new Arbitrary(Data_Functor.map(Test_QuickCheck_Gen.functorGen)(Data_Identity.Identity)(arbitrary(dictArbitrary)));
  };
  var arbitraryLazy = function (dictArbitrary) {
      return new Arbitrary(Control_Bind.bind(Test_QuickCheck_Gen.bindGen)(arbitrary(dictArbitrary))(function ($54) {
          return Control_Applicative.pure(Test_QuickCheck_Gen.applicativeGen)(Data_Lazy.defer(Data_Function["const"]($54)));
      }));
  };
  var arbitraryList = function (dictArbitrary) {
      return new Arbitrary(Test_QuickCheck_Gen.sized(function (n) {
          return Control_Bind.bind(Test_QuickCheck_Gen.bindGen)(Test_QuickCheck_Gen.chooseInt(0)(n))(Data_Function.flip(Test_QuickCheck_Gen.listOf)(arbitrary(dictArbitrary)));
      }));
  };
  var arbUnit = new Arbitrary(Control_Applicative.pure(Test_QuickCheck_Gen.applicativeGen)(Data_Unit.unit));
  var arbTuple = function (dictArbitrary) {
      return function (dictArbitrary1) {
          return new Arbitrary(Control_Apply.apply(Test_QuickCheck_Gen.applyGen)(Data_Functor.map(Test_QuickCheck_Gen.functorGen)(Data_Tuple.Tuple.create)(arbitrary(dictArbitrary)))(arbitrary(dictArbitrary1)));
      };
  };
  var arbOrdering = new Arbitrary(Test_QuickCheck_Gen.oneOf(Control_Applicative.pure(Test_QuickCheck_Gen.applicativeGen)(Data_Ordering.LT.value))([ Control_Applicative.pure(Test_QuickCheck_Gen.applicativeGen)(Data_Ordering.EQ.value), Control_Applicative.pure(Test_QuickCheck_Gen.applicativeGen)(Data_Ordering.GT.value) ]));
  var arbNumber = new Arbitrary(Test_QuickCheck_Gen.uniform);
  var arbInt = new Arbitrary(Test_QuickCheck_Gen.chooseInt(-1000000)(1000000));
  var arbFunction = function (dictCoarbitrary) {
      return function (dictArbitrary) {
          return new Arbitrary(Test_QuickCheck_Gen.repeatable(function (a) {
              return coarbitrary(dictCoarbitrary)(a)(arbitrary(dictArbitrary));
          }));
      };
  };
  var arbChar = new Arbitrary(Data_Functor.map(Test_QuickCheck_Gen.functorGen)(Data_Char.fromCharCode)(Test_QuickCheck_Gen.chooseInt(0)(65536)));
  var arbBoolean = new Arbitrary(Control_Bind.bind(Test_QuickCheck_Gen.bindGen)(Test_QuickCheck_Gen.uniform)(function (v) {
      return Control_Applicative.pure(Test_QuickCheck_Gen.applicativeGen)(v * 2.0 < 1.0);
  }));
  var arbEither = function (dictArbitrary) {
      return function (dictArbitrary1) {
          return new Arbitrary(Control_Bind.bind(Test_QuickCheck_Gen.bindGen)(arbitrary(arbBoolean))(function (v) {
              if (v) {
                  return Data_Functor.map(Test_QuickCheck_Gen.functorGen)(Data_Either.Left.create)(arbitrary(dictArbitrary));
              };
              if (!v) {
                  return Data_Functor.map(Test_QuickCheck_Gen.functorGen)(Data_Either.Right.create)(arbitrary(dictArbitrary1));
              };
              throw new Error("Failed pattern match at Test.QuickCheck.Arbitrary line 123, column 5 - line 123, column 58: " + [ v.constructor.name ]);
          }));
      };
  };
  var arbMaybe = function (dictArbitrary) {
      return new Arbitrary(Control_Bind.bind(Test_QuickCheck_Gen.bindGen)(arbitrary(arbBoolean))(function (v) {
          if (v) {
              return Control_Applicative.pure(Test_QuickCheck_Gen.applicativeGen)(Data_Maybe.Nothing.value);
          };
          if (!v) {
              return Data_Functor.map(Test_QuickCheck_Gen.functorGen)(Data_Maybe.Just.create)(arbitrary(dictArbitrary));
          };
          throw new Error("Failed pattern match at Test.QuickCheck.Arbitrary line 114, column 5 - line 114, column 51: " + [ v.constructor.name ]);
      }));
  };
  var arbArray = function (dictArbitrary) {
      return new Arbitrary(Test_QuickCheck_Gen.arrayOf(arbitrary(dictArbitrary)));
  };
  var arbString = new Arbitrary(Data_Functor.map(Test_QuickCheck_Gen.functorGen)(Data_String.fromCharArray)(arbitrary(arbArray(arbChar))));
  var coarbFunction = function (dictArbitrary) {
      return function (dictCoarbitrary) {
          return new Coarbitrary(function (f) {
              return function (gen) {
                  return Control_Bind.bind(Test_QuickCheck_Gen.bindGen)(arbitrary(arbArray(dictArbitrary)))(function (v) {
                      return coarbitrary(coarbArray(dictCoarbitrary))(Data_Functor.map(Data_Functor.functorArray)(f)(v))(gen);
                  });
              };
          });
      };
  };
  exports["Arbitrary"] = Arbitrary;
  exports["Coarbitrary"] = Coarbitrary;
  exports["arbitrary"] = arbitrary;
  exports["coarbitrary"] = coarbitrary;
  exports["arbBoolean"] = arbBoolean;
  exports["coarbBoolean"] = coarbBoolean;
  exports["arbNumber"] = arbNumber;
  exports["coarbNumber"] = coarbNumber;
  exports["arbInt"] = arbInt;
  exports["coarbInt"] = coarbInt;
  exports["arbString"] = arbString;
  exports["coarbString"] = coarbString;
  exports["arbChar"] = arbChar;
  exports["coarbChar"] = coarbChar;
  exports["arbUnit"] = arbUnit;
  exports["coarbUnit"] = coarbUnit;
  exports["arbOrdering"] = arbOrdering;
  exports["coarbOrdering"] = coarbOrdering;
  exports["arbArray"] = arbArray;
  exports["coarbArray"] = coarbArray;
  exports["arbFunction"] = arbFunction;
  exports["coarbFunction"] = coarbFunction;
  exports["arbTuple"] = arbTuple;
  exports["coarbTuple"] = coarbTuple;
  exports["arbMaybe"] = arbMaybe;
  exports["coarbMaybe"] = coarbMaybe;
  exports["arbEither"] = arbEither;
  exports["coarbEither"] = coarbEither;
  exports["arbitraryList"] = arbitraryList;
  exports["coarbList"] = coarbList;
  exports["arbitraryIdentity"] = arbitraryIdentity;
  exports["coarbIdentity"] = coarbIdentity;
  exports["arbitraryLazy"] = arbitraryLazy;
  exports["coarbLazy"] = coarbLazy;
})(PS["Test.QuickCheck.Arbitrary"] = PS["Test.QuickCheck.Arbitrary"] || {});
(function(exports) {
  
  /**
 *  | This module is a partial port of the Haskell QuickCheck library.
 *  |
 *  | QuickCheck provides a way to write _property-based_ tests.
 *  |
 *  | The `Arbitrary` and `CoArbitrary` type classes allow us to create
 *  | random data with which we can run our tests. This module provides
 *  | instances of both classes for PureScript's core data structures,
 *  | as well as functions for writing new instances.
 *  |
 *  | Test suites can use the `quickCheck` and `quickCheckPure` functions
 *  | to test properties.
 *  |
 *  | For example:
 *  |
 *  | ```purescript
 *  | main = quickCheck \n -> n + 1 > n
 *  | ```
 */  
  "use strict";
  var Prelude = PS["Prelude"];
  var Control_Monad_Eff = PS["Control.Monad.Eff"];
  var Control_Monad_Eff_Console = PS["Control.Monad.Eff.Console"];
  var Control_Monad_Eff_Exception = PS["Control.Monad.Eff.Exception"];
  var Control_Monad_Eff_Random = PS["Control.Monad.Eff.Random"];
  var Control_Monad_Rec_Class = PS["Control.Monad.Rec.Class"];
  var Data_Foldable = PS["Data.Foldable"];
  var Data_List = PS["Data.List"];
  var Data_Maybe = PS["Data.Maybe"];
  var Data_Maybe_First = PS["Data.Maybe.First"];
  var Data_Monoid = PS["Data.Monoid"];
  var Data_Tuple = PS["Data.Tuple"];
  var Data_Unfoldable = PS["Data.Unfoldable"];
  var Test_QuickCheck_Arbitrary = PS["Test.QuickCheck.Arbitrary"];
  var Test_QuickCheck_Gen = PS["Test.QuickCheck.Gen"];
  var Test_QuickCheck_LCG = PS["Test.QuickCheck.LCG"];
  var Control_Applicative = PS["Control.Applicative"];
  var Data_Function = PS["Data.Function"];
  var Control_Bind = PS["Control.Bind"];
  var Control_Semigroupoid = PS["Control.Semigroupoid"];
  var Data_Show = PS["Data.Show"];
  var Data_Semigroup = PS["Data.Semigroup"];
  var Data_Eq = PS["Data.Eq"];
  var Data_Boolean = PS["Data.Boolean"];
  var Data_Semiring = PS["Data.Semiring"];
  var Data_List_Types = PS["Data.List.Types"];        

  /**
 *  | The result of a test: success or failure (with an error message).
 */  
  var Success = (function () {
      function Success() {

      };
      Success.value = new Success();
      return Success;
  })();

  /**
 *  | The result of a test: success or failure (with an error message).
 */  
  var Failed = (function () {
      function Failed(value0) {
          this.value0 = value0;
      };
      Failed.create = function (value0) {
          return new Failed(value0);
      };
      return Failed;
  })();

  /**
 *  | The `Testable` class represents _testable properties_.
 *  |
 *  | A testable property is a function of zero or more `Arbitrary` arguments,
 *  | returning a `Boolean` or `Result`.
 *  |
 *  | Testable properties can be passed to the `quickCheck` function.
 */  
  var Testable = function (test) {
      this.test = test;
  };

  /**
 *  | This operator attaches an error message to a failed test.
 *  |
 *  | For example:
 *  |
 *  | ```purescript
 *  | test x = myProperty x <?> ("myProperty did not hold for " <> show x)
 *  | ```
 */  
  var withHelp = function (v) {
      return function (v1) {
          if (v) {
              return Success.value;
          };
          if (!v) {
              return new Failed(v1);
          };
          throw new Error("Failed pattern match at Test.QuickCheck line 159, column 1 - line 159, column 26: " + [ v.constructor.name, v1.constructor.name ]);
      };
  };
  var testableResult = new Testable(Control_Applicative.pure(Test_QuickCheck_Gen.applicativeGen));
  var testableBoolean = new Testable(function (v) {
      if (v) {
          return Control_Applicative.pure(Test_QuickCheck_Gen.applicativeGen)(Success.value);
      };
      if (!v) {
          return Control_Applicative.pure(Test_QuickCheck_Gen.applicativeGen)(new Failed("Test returned false"));
      };
      throw new Error("Failed pattern match at Test.QuickCheck line 135, column 3 - line 135, column 27: " + [ v.constructor.name ]);
  });

  /**
 *  | The `Testable` class represents _testable properties_.
 *  |
 *  | A testable property is a function of zero or more `Arbitrary` arguments,
 *  | returning a `Boolean` or `Result`.
 *  |
 *  | Testable properties can be passed to the `quickCheck` function.
 */  
  var test = function (dict) {
      return dict.test;
  };
  var testableFunction = function (dictArbitrary) {
      return function (dictTestable) {
          return new Testable(function (f) {
              return Control_Bind.bind(Test_QuickCheck_Gen.bindGen)(Test_QuickCheck_Arbitrary.arbitrary(dictArbitrary))(function ($39) {
                  return test(dictTestable)(f($39));
              });
          });
      };
  };
  var testableGen = function (dictTestable) {
      return new Testable(Data_Function.flip(Control_Bind.bind(Test_QuickCheck_Gen.bindGen))(test(dictTestable)));
  };
  var showResult = new Data_Show.Show(function (v) {
      if (v instanceof Success) {
          return "Success";
      };
      if (v instanceof Failed) {
          return "Failed: " + v.value0;
      };
      throw new Error("Failed pattern match at Test.QuickCheck line 148, column 3 - line 149, column 3: " + [ v.constructor.name ]);
  });

  /**
 *  | A variant of the `quickCheck'` function that accepts a specific seed as
 *  | well as the number tests that should be run.
 */  
  var quickCheckWithSeed = function (dictTestable) {
      return function (seed) {
          return function (n) {
              return function (prop) {
                  var loop = function (v) {
                      if (v.index === n) {
                          return new Control_Monad_Rec_Class.Done(v);
                      };
                      if (Data_Boolean.otherwise) {
                          var $24 = Test_QuickCheck_Gen.runGen(test(dictTestable)(prop))({
                              newSeed: v.seed, 
                              size: 10
                          });
                          if ($24.value0 instanceof Success) {
                              return new Control_Monad_Rec_Class.Loop({
                                  seed: $24.value1.newSeed, 
                                  index: v.index + 1 | 0, 
                                  successes: v.successes + 1 | 0, 
                                  firstFailure: v.firstFailure
                              });
                          };
                          if ($24.value0 instanceof Failed) {
                              return new Control_Monad_Rec_Class.Loop({
                                  seed: $24.value1.newSeed, 
                                  index: v.index + 1 | 0, 
                                  successes: v.successes, 
                                  firstFailure: Data_Semigroup.append(Data_Maybe_First.semigroupFirst)(v.firstFailure)(new Data_Maybe.Just({
                                      index: v.index, 
                                      message: $24.value0.value0, 
                                      seed: v.seed
                                  }))
                              });
                          };
                          throw new Error("Failed pattern match at Test.QuickCheck line 91, column 9 - line 106, column 16: " + [ $24.constructor.name ]);
                      };
                      throw new Error("Failed pattern match at Test.QuickCheck line 88, column 3 - line 106, column 16: " + [ v.constructor.name ]);
                  };
                  var result = Control_Monad_Rec_Class.tailRec(loop)({
                      seed: seed, 
                      index: 0, 
                      successes: 0, 
                      firstFailure: Data_Monoid.mempty(Data_Maybe_First.monoidFirst)
                  });
                  return function __do() {
                      Control_Monad_Eff_Console.log(Data_Show.show(Data_Show.showInt)(result.successes) + ("/" + (Data_Show.show(Data_Show.showInt)(n) + " test(s) passed.")))();
                      return Data_Foldable.for_(Control_Monad_Eff.applicativeEff)(Data_Foldable.foldableFirst)(result.firstFailure)(function (v) {
                          return Control_Monad_Eff_Exception.throwException(Control_Monad_Eff_Exception.error("Test " + (Data_Show.show(Data_Show.showInt)(v.index + 1 | 0) + (" (seed " + (Data_Show.show(Data_Show.showInt)(Test_QuickCheck_LCG.runSeed(v.seed)) + (") failed: \x0a" + v.message))))));
                      })();
                  };
              };
          };
      };
  };

  /**
 *  | Test a property, returning all test results as an array.
 *  |
 *  | The first argument is the _random seed_ to be passed to the random generator.
 *  | The second argument is the number of tests to run.
 */  
  var quickCheckPure = function (dictTestable) {
      return function (s) {
          return function (n) {
              return function (prop) {
                  return Test_QuickCheck_Gen.evalGen(Data_Unfoldable.replicateA(Test_QuickCheck_Gen.applicativeGen)(Data_List_Types.unfoldableList)(Data_List_Types.traversableList)(n)(test(dictTestable)(prop)))({
                      newSeed: s, 
                      size: 10
                  });
              };
          };
      };
  };

  /**
 *  | A variant of the `quickCheck` function which accepts an extra parameter
 *  | representing the number of tests which should be run.
 */  
  var quickCheck$prime = function (dictTestable) {
      return function (n) {
          return function (prop) {
              return function __do() {
                  var v = Test_QuickCheck_LCG.randomSeed();
                  return quickCheckWithSeed(dictTestable)(v)(n)(prop)();
              };
          };
      };
  };

  /**
 *  | Test a property.
 *  |
 *  | This function generates a new random seed, runs 100 tests and
 *  | prints the test results to the console.
 */  
  var quickCheck = function (dictTestable) {
      return function (prop) {
          return quickCheck$prime(dictTestable)(100)(prop);
      };
  };

  /**
 *  | Self-documenting inequality assertion
 */  
  var assertNotEquals = function (dictEq) {
      return function (dictShow) {
          return function (a) {
              return function (b) {
                  return withHelp(Data_Eq.notEq(dictEq)(a)(b))(Data_Show.show(dictShow)(a) + (" == " + Data_Show.show(dictShow)(b)));
              };
          };
      };
  };

  /**
 *  | Self-documenting equality assertion
 */  
  var assertEquals = function (dictEq) {
      return function (dictShow) {
          return function (a) {
              return function (b) {
                  return withHelp(Data_Eq.eq(dictEq)(a)(b))(Data_Show.show(dictShow)(a) + (" /= " + Data_Show.show(dictShow)(b)));
              };
          };
      };
  };
  exports["Success"] = Success;
  exports["Failed"] = Failed;
  exports["Testable"] = Testable;
  exports["assertEquals"] = assertEquals;
  exports["assertNotEquals"] = assertNotEquals;
  exports["quickCheck"] = quickCheck;
  exports["quickCheck'"] = quickCheck$prime;
  exports["quickCheckPure"] = quickCheckPure;
  exports["quickCheckWithSeed"] = quickCheckWithSeed;
  exports["test"] = test;
  exports["withHelp"] = withHelp;
  exports["testableResult"] = testableResult;
  exports["testableBoolean"] = testableBoolean;
  exports["testableFunction"] = testableFunction;
  exports["testableGen"] = testableGen;
  exports["showResult"] = showResult;
})(PS["Test.QuickCheck"] = PS["Test.QuickCheck"] || {});
(function(exports) {
    "use strict";
  var Prelude = PS["Prelude"];
  var Data_Newtype = PS["Data.Newtype"];
  var Data_String = PS["Data.String"];
  var Test_QuickCheck_Gen = PS["Test.QuickCheck.Gen"];
  var Test_QuickCheck_Arbitrary = PS["Test.QuickCheck.Arbitrary"];
  var Data_Eq = PS["Data.Eq"];
  var Data_Ord = PS["Data.Ord"];
  var Control_Applicative = PS["Control.Applicative"];
  var Data_Functor = PS["Data.Functor"];
  var Control_Semigroupoid = PS["Control.Semigroupoid"];        

  /**
 *  | A newtype for `String` whose `Arbitrary` instance generated random
 *  | alphanumeric strings.
 */  
  var AlphaNumString = function (x) {
      return x;
  };
  var ordAlphaNumString = Data_Ord.ordString;
  var newtypeAlphaNumString = new Data_Newtype.Newtype(function (n) {
      return n;
  }, AlphaNumString);
  var eqAlphaNumString = Data_Eq.eqString;
  var coarbAlphaNumString = Test_QuickCheck_Arbitrary.coarbString;
  var arbAlphaNumString = new Test_QuickCheck_Arbitrary.Arbitrary((function () {
      var rest = Data_String.toCharArray("bcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789");
      var anyChar = Test_QuickCheck_Gen.oneOf(Control_Applicative.pure(Test_QuickCheck_Gen.applicativeGen)("a"))(Data_Functor.map(Data_Functor.functorArray)(Control_Applicative.pure(Test_QuickCheck_Gen.applicativeGen))(rest));
      return Data_Functor.map(Test_QuickCheck_Gen.functorGen)(function ($3) {
          return AlphaNumString(Data_String.fromCharArray($3));
      })(Test_QuickCheck_Gen.arrayOf(anyChar));
  })());
  exports["AlphaNumString"] = AlphaNumString;
  exports["newtypeAlphaNumString"] = newtypeAlphaNumString;
  exports["eqAlphaNumString"] = eqAlphaNumString;
  exports["ordAlphaNumString"] = ordAlphaNumString;
  exports["arbAlphaNumString"] = arbAlphaNumString;
  exports["coarbAlphaNumString"] = coarbAlphaNumString;
})(PS["Test.QuickCheck.Data.AlphaNumString"] = PS["Test.QuickCheck.Data.AlphaNumString"] || {});
(function(exports) {
    "use strict";

  exports.setInnerHTML = function(html) {
    return function() {
      document.body.innerHTML += html;
    };
  };

  exports.encode = function(text) {
    return text.
       replace('<', '&lt;')
      .replace('>', '&gt;')
      .replace('&', '&amp;')
      .replace('"', '&quot;');
  };

  exports.withConsoleImpl = function(f) {
    return function() {
      var oldLog = console.log;
      var oldError = console.error;
      var oldWindowError = window.onerror;
      var lines = [];

      console.log = console.error = function(s) {
        lines.push(s);
      };

      window.onerror = function(e) {
        lines.push(e.message);
        return true;
      };

      try {
        f();
      } catch (e) {
        lines.push(e.message);
      } finally {
        console.log = oldLog;
        console.error = oldError;
        window.onerror = oldWindowError;
      }

      return lines;
    };
  };
})(PS["TryPureScript"] = PS["TryPureScript"] || {});
(function(exports) {
    "use strict";
  var $foreign = PS["TryPureScript"];
  var Prelude = PS["Prelude"];
  var Control_Monad_Eff = PS["Control.Monad.Eff"];
  var Data_Foldable = PS["Data.Foldable"];
  var Data_String = PS["Data.String"];
  var Data_Monoid = PS["Data.Monoid"];
  var Data_Semigroup = PS["Data.Semigroup"];
  var Control_Semigroupoid = PS["Control.Semigroupoid"];
  var Data_Functor = PS["Data.Functor"];        
  var Inline = function (x) {
      return x;
  };
  var Doc = function (x) {
      return x;
  };
  var unInline = function (v) {
      return v;
  };
  var unDoc = function (v) {
      return v;
  };
  var text = function ($28) {
      return Inline($foreign.encode($28));
  };
  var tag = function (open) {
      return function (close) {
          return function (html) {
              return "<" + (open + (">" + (html + ("</" + (close + ">")))));
          };
      };
  };
  var tag$prime = function (open) {
      return tag(open)(open);
  };
  var withConsole = function (f) {
      var toDoc = function ($29) {
          return Doc(tag$prime("pre")(tag$prime("code")(Data_String.joinWith("\x0a")($29))));
      };
      return Data_Functor.map(Control_Monad_Eff.functorEff)(toDoc)($foreign.withConsoleImpl(f));
  };
  var semigroupInline = Data_Semigroup.semigroupString;
  var semigroupDoc = Data_Semigroup.semigroupString;
  var render = function (v) {
      return $foreign.setInnerHTML(v);
  };
  var p = function (v) {
      return tag$prime("p")(v);
  };
  var monoidInline = Data_Monoid.monoidString;
  var monoidDoc = Data_Monoid.monoidString;
  var list = function (dictFoldable) {
      return function ($30) {
          return Doc(tag$prime("ul")(unDoc(Data_Foldable.foldMap(dictFoldable)(monoidDoc)(function ($31) {
              return Doc(tag$prime("li")(unInline($31)));
          })($30))));
      };
  };
  var link = function (url) {
      return function (v) {
          return tag("a href=\"" + ($foreign.encode(url) + "\" target=\"_top\""))("a")(v);
      };
  };
  var indent = function (v) {
      return tag$prime("blockquote")(v);
  };
  var h6 = function (v) {
      return tag$prime("h6")(v);
  };
  var h5 = function (v) {
      return tag$prime("h5")(v);
  };
  var h4 = function (v) {
      return tag$prime("h4")(v);
  };
  var h3 = function (v) {
      return tag$prime("h3")(v);
  };
  var h2 = function (v) {
      return tag$prime("h2")(v);
  };
  var h1 = function (v) {
      return tag$prime("h1")(v);
  };
  var code = function (v) {
      return tag$prime("code")(v);
  };
  exports["code"] = code;
  exports["h1"] = h1;
  exports["h2"] = h2;
  exports["h3"] = h3;
  exports["h4"] = h4;
  exports["h5"] = h5;
  exports["h6"] = h6;
  exports["indent"] = indent;
  exports["link"] = link;
  exports["list"] = list;
  exports["p"] = p;
  exports["render"] = render;
  exports["text"] = text;
  exports["withConsole"] = withConsole;
  exports["semigroupInline"] = semigroupInline;
  exports["monoidInline"] = monoidInline;
  exports["semigroupDoc"] = semigroupDoc;
  exports["monoidDoc"] = monoidDoc;
})(PS["TryPureScript"] = PS["TryPureScript"] || {});
