<!DOCTYPE html>
<html>
  <head>
    <title>Πroject λamp</title>
    <meta charset="utf-8" />
    <meta content='text/html; charset=utf-8' http-equiv='Content-Type'>
    <meta http-equiv='X-UA-Compatible' content='IE=edge'>
    <meta name='viewport' content='width=device-width, initial-scale=1.0, maximum-scale=1.0'>
    <!--[if lt IE 9]>
      <script src="http://html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link rel="stylesheet" type="text/css" href="https://ivanthetricourne.github.io/style.css" />
    <link rel="stylesheet" type="text/css" href="css/index.css" />
    <script type="text/javascript" src="//cdnjs.cloudflare.com/ajax/libs/jquery/1.10.2/jquery.js"></script>
  </head>

  <body>
    <div class="wrapper-masthead">
      <div class="container">
        <header class="masthead clearfix">
          <div class="site-info">
            <h1 class="site-name"><a href="/">Πroject λamp</a></h1>
            <p class="site-description">Leaving the light on for anyone else who wants to follow down the bright path of FP and Haskell.</p>
          </div>
          <nav>
            <a href="/">Table of contents</a>
            <a href="https://github.com/lazywithclass/project-lamp">Github</a>
            <a href="/about.html">About</a>
          </nav>
        </header>
      </div>
    </div>

    <div id="main" role="main" class="container">
<article class="page">

  <h1>Chapter 1 - First Steps</h1>

  <div class="entry">
    <p>In this chapter, we introduce the foundation of all functional languages and its related concepts, we talk about types and their relationship with functional languages, and end with a discussion on the different ways that we commonly write purely functional programs.</p>

<h3 id="1-the-λ-calculus">1. The λ-calculus</h3>
<p>One might be thinking <em>“Calculus? I thought this was about programming?”</em> It might come as a surprise to some, but mathematics and computer programming actually have quite a long history and continue to find themselves intertwined as time goes on. One can easily find themselves lost in the history and the theory of it all, but that’s not the purpose of this book. We introduce the λ-calculus solely for the reason that it is the foundation of all functional languages.</p>

<h4 id="a-foundations">a. Foundations</h4>
<p>The λ-calculus can be thought of as a simple programming language made up of three components: variables, functions, and function application. In many functional languages, the λ-calculus is used at the fundamental level (e.g. function representation and function application) but some of them use it for many other interesting things, which is a testament to how flexible the calculus truly is.</p>

<p>How about a few examples?</p>
<div class="language-haskell highlighter-rouge"><pre class="highlight"><code><span class="c1">-- these are variables</span>
<span class="n">x</span> <span class="o">=</span> <span class="mi">5</span>
<span class="n">y</span> <span class="o">=</span> <span class="mi">6</span>

<span class="c1">-- this is a function</span>
<span class="n">foo1</span> <span class="o">=</span> <span class="nf">\</span><span class="n">x</span> <span class="o">-&gt;</span> <span class="n">x</span>

<span class="c1">-- this is also a function</span>
<span class="n">foo2</span> <span class="n">f</span> <span class="n">x</span> <span class="n">y</span> <span class="o">=</span> <span class="n">f</span> <span class="n">x</span>

<span class="c1">-- function application</span>
<span class="n">app1</span> <span class="o">=</span> <span class="n">foo1</span> <span class="n">x</span>
<span class="n">app2</span> <span class="o">=</span> <span class="n">foo2</span> <span class="n">foo1</span> <span class="n">y</span> <span class="n">x</span>
</code></pre>
</div>
<p>In functional languages, one is free to assign values (i.e., Integers, Booleans, etc.) to variables. As is the case in PureScript and Haskell, variables are constrained by <em>lower-case</em> names. It is, however, impossible to <em>re-assign</em> new values to variables (i.e., we cannot re-associate <code class="highlighter-rouge">x</code> with another value; it’s always <code class="highlighter-rouge">5</code>).</p>

<p>A key feature in functional languages is the appearance of functions as <em>first-class</em> values. This simply means that one can do with functions as one can do with normal values, as is the case with <code class="highlighter-rouge">foo1</code>, which itself is a variable associated with the value <code class="highlighter-rouge">(\x -&gt; x)</code>, an example of an <em>anonymous function</em>. Having functions first-class allows one to pass functions as arguments to other functions (as is the case in <code class="highlighter-rouge">foo2</code>’s first argument, <code class="highlighter-rouge">f</code>). As we see later on in this chapter, this allows a considerable amount of flexibility in writing our code.</p>

<p>Finally, functions are applied using <em>juxtaposition</em>, or simply placing the function beside its arguments. An interesting part of function application in similar functional languages is that we can use <em>partial function application</em>. That is, the expression <code class="highlighter-rouge">(foo2 foo1)</code> is just as valid as <code class="highlighter-rouge">(foo2 foo1 y)</code>, etc., all of which are also considered first-class values! Imagine the possibilities.</p>

<h4 id="b-the-fine-print--β-reduction">b. The Fine Print – β-reduction</h4>

<p>Another thing to note about functions is that they have what is known as a <em>local namespace</em>. This means that names contained within functions (i.e, the names of their parameters) are different from those defined outside of the function. In the above examples, we have defined <code class="highlighter-rouge">x</code> and <code class="highlighter-rouge">y</code> to hold the value <code class="highlighter-rouge">5</code> and <code class="highlighter-rouge">6</code>, respectively. We then later pass these names through function application into <code class="highlighter-rouge">foo1</code> and <code class="highlighter-rouge">foo2</code>, which themselves make reference to a certain <code class="highlighter-rouge">x</code> and <code class="highlighter-rouge">y</code>. It might then come as a surprise that the value that <code class="highlighter-rouge">app2</code> results in is <code class="highlighter-rouge">6</code> and not <code class="highlighter-rouge">5</code>! The reason for this is that the <code class="highlighter-rouge">x</code> and <code class="highlighter-rouge">y</code> defined outside of <code class="highlighter-rouge">foo1</code> and <code class="highlighter-rouge">foo2</code> are said to be defined <em>globally</em>, while the <code class="highlighter-rouge">x</code> and <code class="highlighter-rouge">y</code> in the definition of <code class="highlighter-rouge">foo1</code> and <code class="highlighter-rouge">foo2</code> are defined <em>locally</em> and are thus different from one another.</p>

<p>To make this concept a bit clearer, it might help to see how <code class="highlighter-rouge">app2</code> comes up with its answer. In the λ-calculus, this is done through what is known as <em>β-reduction</em>. The name <em>reduction</em> seems a bit off-putting, since each step in a <em>β-reduction</em> is essentially an expansion of expressions into their respective values. This is where a language like PureScript becomes rather helpful, since the act of reducing is simply taking an expression from the left hand side of an <code class="highlighter-rouge">=</code> sign to the value on the right. Another thing that happens at each step is that with every function application, a function’s namespace grows, where the names of its parameters are associated with the values passed in their place. We represent this <em>namespace growth</em> as the expression contained within curly braces, <code class="highlighter-rouge"><span class="p">{}</span></code>, placed beside the given function being applied. Once all of a function’s parameters have their associated value, all occurances of names inside of its body (i.e., the expression after the <code class="highlighter-rouge">-&gt;</code>) are replaced with the respective values mapped inside of its namespace. This continues until there is no other possible reduction. In a later chapter, we show how to simulate this step-by-step calculation inside of PureScript itself!</p>

<p>For now, let’s see β-reduction in action!:</p>
<div class="highlighter-rouge"><pre class="highlight"><code>app2
= foo2 foo1 y x 
= (\f x y -&gt; f x) foo1 y x
= (\f x y -&gt; f x) (\x -&gt; x) 6 5
= ((\f x y -&gt; f x){}) (\x -&gt; x) 6 5
= ((\x y -&gt; f x){f : (\x -&gt; x)}) 6 5
= ((\y -&gt; f x){f : (\x -&gt; x), x : 6}) 5
= ((f x){f : (\x -&gt; x), x : 6, y : 5})
= (\x -&gt; x) 6
= ((\x -&gt; x){}) 6
= (x{x : 6})
= 6
</code></pre>
</div>

<!-- The λ-calculus is a simple programming language made up of only 3 components: variables, abstractions and applications. We can succintly represent every expression in the language (i.e., λ-expression, Λ), by way of a *grammar*: -->
<!-- ``` -->
<!-- Λ = x | λx . Λ | Λ Λ -->
<!-- ``` -->
<!-- In general, grammars are defined *recursively* but don't necessarily have to be. The grammar for λ-calculus (above) is defined recursively to reflect that λ-expressions can be composed with other λ-expressions. In PureScript, we can define the grammar for the λ-calculus in the following way: -->
<!-- ```haskell -->
<!-- data Lam = Var String -->
<!--          | Abs String Lam -->
<!--          | Lam Lam -->
<!-- ``` -->
<!-- In languages like PureScript, representing a language in such way also defines what is known as a *data type* and allows us to manipulate expressions as data. For example, let's define the *identity function* of the λ-calculus as an expression of our grammar: -->
<!-- ```haskell -->
<!-- identity = Abs "x" (Var "x") -->
<!-- ``` -->
<!-- Of course, since PureScript is already founded on the λ-calculus, we can define the identity function using PureScript's own representation, which is: -->
<!-- ```haskell -->
<!-- id = \x -> x -->
<!-- ``` -->
<!-- The benefit of defining a language using our own defined data type is that we are not constrained in the manner of using our language. We take advantage of this benefit in a later chapter ([Chapter 3]()). -->

<!-- The phrase *Turing-complete* is just a fancy way of describing a language that can encode *every possible computation*, which makes the λ-calculus the perfect foundation for a programming language. -->

<h3 id="2-what-is-this-about-types-and-programming-languages">2. What is this about Types and Programming Languages?</h3>
<h3 id="3-recursion-and-its-principles">3. Recursion and its Principles</h3>

  </div>
</article>


    </div>

    <div class="wrapper-footer">
      <div class="container">
        <footer class="footer">
          <a href="https://github.com/lazywithclass/project-lamp"><i class="svg-icon github"></i></a>
        </footer>
      </div>
    </div>

    <script src="js/ace.min.js" type="text/javascript" charset="utf-8"></script>
    <script src="js/mode-haskell.min.js" type="text/javascript" charset="utf-8"></script>
    <script src="js/index.js" type="text/javascript" charset="utf-8"></script>
    <script src="js/recursion-principles-and-foldables.js" type="text/javascript" charset="utf-8"></script>
    <script type="text/javascript">
    </script>
  </body>
</html>
