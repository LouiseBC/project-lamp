<!DOCTYPE html>
<html>
  <head>
    <title>Πroject λamp</title>
    <meta charset="utf-8" />
    <meta content='text/html; charset=utf-8' http-equiv='Content-Type'>
    <meta http-equiv='X-UA-Compatible' content='IE=edge'>
    <meta name='viewport' content='width=device-width, initial-scale=1.0, maximum-scale=1.0'>
    <!--[if lt IE 9]>
      <script src="http://html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link rel="stylesheet" type="text/css" href="https://ivanthetricourne.github.io/style.css" />
    <script type="text/javascript" src="//cdnjs.cloudflare.com/ajax/libs/jquery/1.10.2/jquery.js"></script>
  </head>

  <body>
    <div class="wrapper-masthead">
      <div class="container">
        <header class="masthead clearfix">
          <div class="site-info">
            <h1 class="site-name"><a href="/">Πroject λamp</a></h1>
            <p class="site-description">Leaving the light on for anyone else who wants to follow down the bright path of FP and Haskell.</p>
          </div>
          <nav>
            <a href="/">Table of contents</a>
            <a href="https://github.com/lazywithclass/project-lamp">Github</a>
            <a href="/about">About</a>
          </nav>
        </header>
      </div>
    </div>

    <div id="main" role="main" class="container">
      <article class="page">

        <h1>Recursion Principles and Foldables</h1>

        <div class="entry">
          <p>Consider the definition of the simplest foldable data structure: the <em>Natural Number</em>!</p>

          <div class="js-editor" style="width: auto; height: 200px;">toInt :: Nat -> Int
toInt = foldNat 0 (\acc -> 1 + acc)

data Nat = Zero
         | Add1 Nat

-- How to print natural numbers a nice way :P
instance showNat :: Show Nat where
    show n = show $ toInt n</div>

          <p>A natural number is either <code class="highlighter-rouge">Zero</code> or the successor of (i.e., 1 value greater than) another natural number. Think <em>peano numbers</em>. With this, we have defined a data structure that includes all positive integers and as well as 0.</p>
          <p class="js-results"></p>

          <p>Let’s define some basic functions for Natural Numbers:</p>

          <div class="js-editor" style="width: auto; height:350px;">-- add two natural numbers together.
plus :: Nat -> Nat -> Nat
plus Zero     y = y
plus (Add1 x) y = Add1 (x `plus` y)

-- multiply two natural numbers.
times :: Nat -> Nat -> Nat
times Zero     _ = Zero
times (Add1 x) y = (x `times` y) `plus` y

-- pow raises its first argument to the power of the
-- second argument.
pow :: Nat -> Nat -> Nat
pow _ Zero     = Add1 Zero
pow x (Add1 y) = (x `pow` y) `times` x </div>
          <p class="js-results"></p>

          <p>Cool, but nothing really out of the ordinary here. These are just your average, every-day run of the mill recursively defined functions, but we can make things a bit more interesting.</p>

          <p>Consider the following definition of <code class="highlighter-rouge">foldNat</code>, which behaves exactly like a reducer (i.e., a <em>recursion principle</em>) for natural numbers.</p>

          <p>Any data structure that is defined similarly to natural numbers (e.g. Lists) has a corresponding <code class="highlighter-rouge">fold</code> function. Looking at its type definition, <code class="highlighter-rouge">foldNat</code> takes an <code class="highlighter-rouge">a</code>, a function of type <code class="highlighter-rouge">a -&gt; a</code>, a <code class="highlighter-rouge">Nat</code> and returns an <code class="highlighter-rouge">a</code>. One should think of <code class="highlighter-rouge">a</code> as equivalent to <em>any</em> type, which makes <code class="highlighter-rouge">foldNat</code> an example of a <strong>polymorphic function</strong>. I will write more about those later on :)</p>

          <p>Essentially, the job of <code class="highlighter-rouge">foldNat</code> is to take <em>any</em> natural number into the appropriate <code class="highlighter-rouge">a</code>. For example, reading the first line of <code class="highlighter-rouge">foldNat</code> says that:</p>

          <p><em>In the event that</em> <code class="highlighter-rouge">n</code> <em>is the natural number</em> <code class="highlighter-rouge">Zero</code>, <code class="highlighter-rouge">foldNat</code> <em>should return</em> <code class="highlighter-rouge">base</code>.</p>

          <p>Consequently, the second line of <code class="highlighter-rouge">foldNat</code> is called in the event that the given <code class="highlighter-rouge">n</code> is <strong>not</strong> <code class="highlighter-rouge">Zero</code> but is instead the <code class="highlighter-rouge">Add1</code> of another natural number <code class="highlighter-rouge">n</code>. Thus, <code class="highlighter-rouge">foldNat</code> would then recur on the smaller natural number, <code class="highlighter-rouge">n</code>, resulting in an <code class="highlighter-rouge">a</code> which is then passed to <code class="highlighter-rouge">recur</code> that does whatever it is it’s meant to do. The real magic that happens is mostly contained within the function <code class="highlighter-rouge">recur</code> passed to <code class="highlighter-rouge">foldNat</code> (<strong>hint</strong> <strong>hint</strong>).</p>

          <div class="js-editor" style="width: auto; height:80px;">foldNat :: forall a. a -> (a -> a) -> Nat -> a
foldNat base recur Zero     = base
foldNat base recur (Add1 n) = recur $ foldNat base recur n</div>

          <p>To further understand what exactly <code class="highlighter-rouge">foldNat</code> is meant to do, I’ve included some exercises! As an example, I’ve done the first of these.</p>

          <p>For those who want a little bit more, I’ve also included a bonus question to define factorial (<code class="highlighter-rouge">fact</code>) in terms of <code class="highlighter-rouge">foldNat</code>.</p>

          <p>Good luck!</p>

          <p><em>Hint</em>: You may find it useful to define a few natural numbers to avoid having to write out a long series of <code class="highlighter-rouge">Add1</code>s every time you want to test your functions. For example:</p>

          <div class="js-editor" style="width: auto; height:120px;">two :: Nat
two = Add1 (Add1 Zero)

five :: Nat
five = Add1 (Add1 (Add1 (Add1 (Add1 Zero))))</div>

          <p><strong>Exercises</strong>:</p>

          <div class="js-editor" style="width: auto; height:80px;">-- 1. Define `plusFold` that behaves like `plus` but uses `foldNat`
plusFold :: Nat -> Nat -> Nat
plusFold m n = foldNat n Add1 m</div>
          <p class="js-results"></p>

          <div class="js-editor" style="width: auto; height:80px;">-- 2. Define `timesFold` that behaves like `times` but uses `foldNat`
timesFold :: Nat -> Nat -> Nat
timesFold = undefined</div>
          <p class="js-results"></p>

          <div class="js-editor" style="width: auto; height:80px;"> -- 3. Define `powFold` that behaves like `pow` but uses `foldNat`
powFold :: Nat -> Nat -> Nat
powFold = undefined</div>
          <p class="js-results"></p>

          <div class="js-editor" style="width: auto; height: 150px;">-- BONUS!! This is rather difficult...
fact :: Nat -> Nat
fact Zero     = Add1 Zero
fact (Add1 n) = (Add1 n) `times` (fact n)

factFold :: Nat -> Nat
factFold = undefined</div>
          <p class="js-results"></p>

        </div>
      </article>

    </div>

    <div class="wrapper-footer">
      <div class="container">
        <footer class="footer">
          <a href="https://github.com/lazywithclass/project-lamp"><i class="svg-icon github"></i></a>
        </footer>
      </div>
    </div>

    <script src="js/ace.min.js" type="text/javascript" charset="utf-8"></script>
    <script src="js/mode-haskell.min.js" type="text/javascript" charset="utf-8"></script>
    <script src="js/index.js" type="text/javascript" charset="utf-8"></script>
    <script type="text/javascript">
      $(function() {
        console.log('oh hai!');
        $('.js-editor').each(function() {
          createEditor(this);
        });
      });
    </script>
  </body>
</html>
