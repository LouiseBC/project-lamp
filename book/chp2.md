---
layout: page
title: Chapter 2 - Little Languages w/ Style
permalink: /pl-chp2/
---
In the previous chapter, we introduced the foundation of FP languages, a few key concepts on types and the basis of writing recursive programs in a functional language. In this chapter, we take a little bit of all three and introduce the simplicity of writing *interpreters* in a functional language.

### 1. The Big Picture

#### a. We're Not in PureScript Anymore -- The Î»-calculus (Reprise)
<!--
Thank you Alonzo Church
Turing complete
-->

#### b. No Hacks Required -- Envs, Values and Terms
<!--
obviously
interpreter goes here
show what it can do (factorial)
-->

### 2. Show Me the Data

#### a. One Does Not Simply Show Functions -- Function Representation
<!--
Why can't we show functions?
show how other languages do it (haskell, racket, javascript)
-->
#### b. A Happy Medium -- Closures
<!--
The essence of a function (pieces)
interpreter goes here (little changes only)
-->

### 3. Continuing with Interpreters

#### a. One Step at a Time -- Continuation Passing Style
<!-- 
What is a continuation
Convert a few basic function
-->
#### b. If You Squint Your Eyes -- Tail Calls
<!--
calling in tail position
graze on what writing in this way looks like
interpreter goes here
-->
